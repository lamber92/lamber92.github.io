

<!DOCTYPE html>
<html lang="zh-CN" >



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.jpg">
  <link rel="icon" href="/img/icon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Lamber Chen">
  <meta name="keywords" content="">
  
    <meta name="description" content="通过对比C++和Go语言内存分配机制，以及简略地阅读源码，更进一步认识Go1.17的指针。">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang-指针">
<meta property="og:url" content="https://lamber92.github.io/2021/08/02/golang/pointer/index.html">
<meta property="og:site_name" content="Lamber的学习笔记">
<meta property="og:description" content="通过对比C++和Go语言内存分配机制，以及简略地阅读源码，更进一步认识Go1.17的指针。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lamber92.github.io/2021/08/02/golang/pointer/pointer.png">
<meta property="og:image" content="https://lamber92.github.io/2021/08/02/golang/pointer/memory.jpg">
<meta property="og:image" content="https://lamber92.github.io/2021/08/02/golang/pointer/manbook.png">
<meta property="article:published_time" content="2021-08-02T13:50:01.000Z">
<meta property="article:modified_time" content="2023-02-28T13:50:01.000Z">
<meta property="article:author" content="Lamber Chen">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="指针">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://lamber92.github.io/2021/08/02/golang/pointer/pointer.png">
  
  
  
  <title>Golang-指针 - Lamber的学习笔记</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"lamber92.github.io","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"left","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"zPUsZUPeBQSuuuPubrF7oUya-gzGzoHsz","app_key":"Ru7EOypuGHkIcmxERkIJ26Cv","server_url":"https://zpuszupe.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Lamber的学习笔记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/god_of_war.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Golang-指针"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-08-02 21:50" pubdate>
          2021年8月2日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          32k 字
        
      </span>
    

    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="padding-left: 2rem; margin-right: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Golang-指针</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="Golang-指针"><a href="#Golang-指针" class="headerlink" title="Golang-指针"></a>Golang-指针</h1><p align="right">Lamber</p>
<p align="right">2021-08-02</p>



<h2 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1. 什么是指针"></a>1. 什么是指针</h2><h3 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h3><p>引自：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">https://en.wikipedia.org/wiki/Pointer_(computer_programming)</a></p>
<blockquote>
<p>在1964年，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%93%88%E7%BE%85%E5%BE%B7%C2%B7%E5%8B%9E%E6%A3%AE">哈罗德·劳森</a>发明了最早的指针。他在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/PL/I">PL&#x2F;I</a>中实现出了这个概念，其他高级编程语言也很快跟进，使用了这个想法。指针（pointer）这个名称首次出现在系统发展公司（System Development Corporation，SDC）的技术文件，当中使用了堆栈指针（stack pointer）这个名词。</p>
</blockquote>
<h3 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2 简介"></a>1.2 简介</h3><p>引自：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">https://en.wikipedia.org/wiki/Pointer_(computer_programming)</a></p>
<blockquote>
<p>在计算机科学中，指针是许多编程语言中的一个对象，用于存储一个内存地址。它可以是位于计算机内存中的另一个值，或者在某些情况下，是内存映射的计算机硬件的值。指针引用(referencing)了内存中的一个位置，获得存储在该位置的值被称为解引用(dereferencing)。</p>
<p>做一个比喻，一本书索引中的页码可以被认为是一个指向相应页面的指针；通过翻到具有给定页码的页面并阅读该页面上的文本，就可以对这样一个指针进行解引用。指针变量的实际格式和内容取决于底层计算机结构。</p>
<p>使用指针可以显著提高重复性操作的性能，如遍历可迭代数据结构（如字符串、查找表、控制表和树形结构）。特别是，在时间和空间上，复制和取消引用指针往往比复制和访问指针所指向的数据要便宜得多。</p>
<p>指针也被用来保存程序设计中被调用的子程序的入口点地址，以及运行时链接到动态链接库（DLL）。在面向对象编程中，函数的指针用于绑定方法，通常使用虚拟方法表（这里说的是C++的虚函数表）。</p>
<p>但是指针本身也存在一些可被滥用之处，在访问某个数据结构时，可能会超出可用范围，使软件或操作系统出现异常，严重时可造成死机。利用指针去访问或修改非合法可取用的资料，也可能造成安全性问题。为此，C与C++语言规定指针类型为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%B1%E7%B1%BB%E5%9E%8B">强类型</a>，即指针值不仅是一个内存地址，同时它的数据类型说明了存在这个地址可以安全访问的地址的范围，例如，float<em>可以访问4个字节的内存空间，double</em>可以访问8个字节的内存空间。</p>
<p>许多编程语言中都支持某种形式的指针，最著名的是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C语言</a>，但是有些编程语言对指针的运用采取比较严格的限制。因为指针的机制比较简单，其功能可以被集中重新实现成更抽象化的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>（reference）资料形别，如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Java">Java</a>一般避免用指针，改为使用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>。</p>
</blockquote>
<p><img src="pointer.png" srcset="/img/loading.gif" lazyload></p>
<center>上图源自：https://www.runoob.com/cprogramming/c-pointers.html</center>



<h3 id="1-3-为什么需要指针？"><a href="#1-3-为什么需要指针？" class="headerlink" title="1.3 为什么需要指针？"></a>1.3 为什么需要指针？</h3><ol>
<li>提供了一种间接的途径来访问和修改值；</li>
<li>提高”大体积”的数据结构或数据类型在方法间的效率；</li>
<li>在某些语言中(如C&#x2F;C++)，直接控制变量的生命周期；</li>
</ol>
<h3 id="1-4-内存堆栈空间"><a href="#1-4-内存堆栈空间" class="headerlink" title="1.4 内存堆栈空间"></a>1.4 内存堆栈空间</h3><blockquote>
<p>内存堆栈空间有非常多的知识点，本篇只记录与指针有关的部分。</p>
</blockquote>
<p><img src="memory.jpg" srcset="/img/loading.gif" lazyload></p>
<center>上图源自：https://www.cnblogs.com/clover-toeic/p/3754433.html</center>

<p>在用户内存空间中，栈(stack)和堆(heap)，如上图所示。</p>
<p>栈由高地址向低地址延伸，堆由低地址向高地址延伸。</p>
<p>在C&#x2F;C++中，堆栈空间的边界可以很清晰地看到，并且<strong>需要编程人员自己决策</strong>内存从堆还是在栈中分配：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-number">4</span> <br> <span class="hljs-number">5</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> 8 </span>&#123;<br> <span class="hljs-number">9</span>     <span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);   &lt;-- 通过<span class="hljs-keyword">new</span>()方法，在堆上开辟空间<br><span class="hljs-number">10</span>     <span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span>     <span class="hljs-type">int</span> p3 = <span class="hljs-number">3</span>;   &lt;-- 不通过<span class="hljs-keyword">new</span>()方法，在栈上开辟空间<br><span class="hljs-number">13</span>     <span class="hljs-type">int</span> p4 = <span class="hljs-number">4</span>;<br><span class="hljs-number">14</span> <br><span class="hljs-number">15</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1: %016p\n&quot;</span>, p1);<br><span class="hljs-number">16</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2: %016p\n&quot;</span>, p2);<br><span class="hljs-number">17</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3: %016p\n&quot;</span>, &amp;p3);<br><span class="hljs-number">18</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p4: %016p\n&quot;</span>, &amp;p4);<br><span class="hljs-number">19</span> <br><span class="hljs-number">20</span>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-number">21</span>         <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">22</span>     &#125;<br><span class="hljs-number">23</span> <br><span class="hljs-number">24</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">25</span> &#125;<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@czy memory]# ./a.out <br>p1: 0x000000016f2010<br>p2: 0x000000016f2030   // &lt;-- p1和p2在堆上申请，内存地址由低往高<br>p3: 0x007ffcfb6dfb7c<br>p4: 0x007ffcfb6dfb78<br></code></pre></td></tr></table></figure>

<p>我们看下这时a.out进程的内存分配信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@czy ~]# ps -ef | grep a.out<br>root      18707  18389  0 19:01 pts/1    00:00:00 ./a.out<br>root      18751  18708  0 19:02 pts/2    00:00:00 grep --color=auto a.out<br>[root@czy ~]# cd /proc/18707<br>[root@czy 18707]# cat maps <br>00400000-00401000 r-xp 00000000 fd:00 4579414                            /usr/local/tools/share/memory/a.out<br>00600000-00601000 r--p 00000000 fd:00 4579414                            /usr/local/tools/share/memory/a.out<br>00601000-00602000 rw-p 00001000 fd:00 4579414                            /usr/local/tools/share/memory/a.out<br>016f2000-01713000 rw-p 00000000 00:00 0                                  [heap]<br>7f731e061000-7f731e223000 r-xp 00000000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e223000-7f731e423000 ---p 001c2000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e423000-7f731e427000 r--p 001c2000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e427000-7f731e429000 rw-p 001c6000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e429000-7f731e42e000 rw-p 00000000 00:00 0 <br>7f731e42e000-7f731e443000 r-xp 00000000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e443000-7f731e642000 ---p 00015000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e642000-7f731e643000 r--p 00014000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e643000-7f731e644000 rw-p 00015000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e644000-7f731e745000 r-xp 00000000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e745000-7f731e944000 ---p 00101000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e944000-7f731e945000 r--p 00100000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e945000-7f731e946000 rw-p 00101000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e946000-7f731ea2f000 r-xp 00000000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ea2f000-7f731ec2e000 ---p 000e9000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ec2e000-7f731ec36000 r--p 000e8000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ec36000-7f731ec38000 rw-p 000f0000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ec38000-7f731ec4d000 rw-p 00000000 00:00 0 <br>7f731ec4d000-7f731ec6f000 r-xp 00000000 fd:00 2776504                    /usr/lib64/ld-2.17.so<br>7f731ee53000-7f731ee58000 rw-p 00000000 00:00 0 <br>7f731ee6c000-7f731ee6e000 rw-p 00000000 00:00 0 <br>7f731ee6e000-7f731ee6f000 r--p 00021000 fd:00 2776504                    /usr/lib64/ld-2.17.so<br>7f731ee6f000-7f731ee70000 rw-p 00022000 fd:00 2776504                    /usr/lib64/ld-2.17.so<br>7f731ee70000-7f731ee71000 rw-p 00000000 00:00 0 <br>7ffcfb6c0000-7ffcfb6e1000 rw-p 00000000 00:00 0                          [stack]<br>7ffcfb701000-7ffcfb703000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br></code></pre></td></tr></table></figure>

<p>重点关注这两行：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">016f2000-01713000 rw-p 00000000 00:00 0                                  [heap]<br>7ffcfb6c0000-7ffcfb6e1000 rw-p 00000000 00:00 0                          [stack]<br></code></pre></td></tr></table></figure>

<p>对比程序中的打印信息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">p1: 0x000000016f2010<br>p2: 0x000000016f2030   // &lt;-- p1和p2落在016f2000-01713000的内存空间上[heap]<br>p3: 0x007ffcfb6dfb7c<br>p4: 0x007ffcfb6dfb78   // &lt;-- p3和p4落在7ffcfb6c0000-7ffcfb6e1000的内存空间上[stack]<br></code></pre></td></tr></table></figure>



<p>Go也有**New()**方法，通过New()申请的内存空间是否也存在于heap上呢？这里我带着疑问往下学习。</p>
<h3 id="1-5-Golang的指针"><a href="#1-5-Golang的指针" class="headerlink" title="1.5 Golang的指针"></a>1.5 Golang的指针</h3><p>引自：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Go">https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Go</a></p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Go_(programming_language)">Go</a> has pointers. Its declaration syntax is equivalent to that of C, but written the other way around, ending with the type. Unlike C, Go has garbage collection, and disallows pointer arithmetic. Reference types, like in C++, do not exist. Some built-in types, like maps and channels, are boxed (i.e. internally they are pointers to mutable structures), and are initialized using the <code>make</code> function. In an approach to unified syntax between pointers and non-pointers, the arrow (<code>-&gt;</code>) operator has been dropped: the dot operator on a pointer refers to the field or method of the dereferenced object. This, however, only works with 1 level of indirection.</p>
</blockquote>
<blockquote>
<p>Go有指针。它的声明语法等同于C语言，但反过来写，以类型结束。与C不同的是，Go有垃圾收集（GC），并且不允许指针运算。像C++中的引用类型并不存在。一些内置类型，如map和channel，是盒式的（即在内部它们是指向可变结构的指针），并使用make函数进行初始化。为了统一指针和非指针之间的语法，箭头（-&gt;）操作符被放弃了：指针上的点操作符指的是被解引用对象的字段或方法。然而，这只适用于一级指针(1 level of indirection)。</p>
</blockquote>
<p>引自：《go101》：</p>
<blockquote>
<p>一个内存地址表示操作系统管理的整个内存中的一个偏移量（相对于从整个内存的起始， 以字节计数）。</p>
<p>通常地，一个内存地址用一个操作系统原生字（native word）来存储。 一个原生字在32 位操作系统上占4个字节，在64位操作系统上占8个字节。所以，32位操作系统上的理论 最大支持内存容量为4GB（1GB &#x3D;&#x3D; 2 30字节），64位操作系统上的理论最大支持内存容量 为2^64Byte，即16EB（EB：艾字节，1EB &#x3D;&#x3D; 1024PB, 1PB &#x3D;&#x3D; 1024TB, 1TB &#x3D;&#x3D; 1024GB）。 </p>
<p>内存地址的字面形式常用整数的十六进制字面量来表示，比如0x1234CDEF。 以后我们常简称内存地址为地址。</p>
<p>为了安全起见，Go指针在使用上相对于C指针有很多限制。 通过施加这些限制，Go指针保 留了C指针的好处，同时也避免了C指针的危险性。</p>
</blockquote>
<ul>
<li><p>因为在C&#x2F;C++中，没有GC帮忙回收堆内存，指针存储的堆栈地址是需要显式调用 free()&#x2F;delete() 释放的，并且释放后需要重新把指针指向NULL，否则会产生许多严重后果：</p>
<ol>
<li><p>指针原本指向的堆内存没有被释放，又指向了另一块堆内存，从而导致原本申请的堆内存块无法被找到且释放（<strong>内存泄露</strong>）；</p>
</li>
<li><p>访问指向为NULL的指针，会产生<strong>空指针错误</strong>而让程序崩溃（<strong>Segment fault</strong>）；</p>
</li>
<li><p>如果指针指向的地址空间被释放，但未置NULL，且恰好被其他逻辑复用，那么代码逻辑的走向将不能控制（<strong>野指针</strong>）。这时段错误已经是最好的后果，其他后果例如不知为什么其他代码逻辑走向非常诡异 或 使得其他代码段访问相同地址后段错误，造成其他代码段有问题的假象。</p>
</li>
</ol>
</li>
<li><p><strong>庆幸的是</strong>，Go拥有runtime和GC，并且刻意地”隐藏”裸指针。</p>
</li>
</ul>
<p>​	因此我们只需要考虑以上的一种情况情况：<strong>空指针</strong>。</p>
<p>​	在Go中，访问空指针，会触发panic。</p>
<ul>
<li><p><strong>Go是如何限制指针操作来避免上述问题的呢？</strong></p>
<ol>
<li><p>Go指针不支持算术运算</p>
<blockquote>
<p>在Go中，指针是不能参与算术运算的。比如，对于一个指针p， 运算p++和p-2都是非法 的。</p>
</blockquote>
</li>
<li><p>一个指针类型的值不能被随意转换为另一个指针类型</p>
   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int64</span> <br><span class="hljs-keyword">type</span> Ta *<span class="hljs-type">int64</span> <br><span class="hljs-keyword">type</span> Tb *MyInt<br></code></pre></td></tr></table></figure>

<blockquote>
<p>对于上面所示的这些指针类型，下面的事实成立： </p>
<ol>
<li>类型*int64的值可以被隐式转换到类型Ta，反之亦然（因为它们的底层类型均 为*int64）。 </li>
<li>类型*MyInt的值可以被隐式转换到类型Tb，反之亦然（因为它们的底层类型均 为*MyInt）。 </li>
<li>类型MyInt的值可以被显式转换为类型*int64，反之亦然（因为它们都是非定义 的并且它们的基类型的底层类型均为int64）。 </li>
<li>类型Ta的值不能直接被转换为类型Tb，即使是显式转换也是不行的。 但是，通过 上述三条事实，通过三层显式转换Tb((*MyInt)((*int64)(ta)))，一个类型 为Ta的值ta可以被间接地转换为类型Tb。 </li>
<li>这些指针类型的任何值都无法被转换到类型*uint64。</li>
</ol>
</blockquote>
</li>
<li><p>一个指针值不能和其它任一指针类型的值进行比较</p>
<blockquote>
<p>Go指针值是支持（使用比较运算符&#x3D;&#x3D;和!&#x3D;）比较的。 </p>
<p>但是，两个指针只有在下列任一 条件被满足的时候才可以比较： </p>
<ol>
<li>这两个指针的类型相同。 </li>
<li>其中一个指针可以被隐式转换为另一个指针的类型。换句话说，这两个指针的类型 的底层类型必须一致并且其中一个指针类型为非定义的（考虑结构体字段的标签）。 </li>
<li>其中一个并且只有一个指针用类型不确定的nil标识符表示。</li>
</ol>
</blockquote>
   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	<span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int64</span><br>	<span class="hljs-keyword">type</span> Ta *<span class="hljs-type">int64</span><br>	<span class="hljs-keyword">type</span> Tb *MyInt<br>	<br>	<span class="hljs-comment">// 4个不同类型的指针：</span><br>	<span class="hljs-keyword">var</span> pa0 Ta<br> 	<span class="hljs-keyword">var</span> pa1 *<span class="hljs-type">int64</span><br> 	<span class="hljs-keyword">var</span> pb0 Tb<br> 	<span class="hljs-keyword">var</span> pb1 *MyInt<br><br> 	<span class="hljs-comment">// 下面这6行编译没问题。它们的比较结果都为true。</span><br> 	_ = pa0 == pa1<br> 	_ = pb0 == pb1<br> 	_ = pa0 == <span class="hljs-literal">nil</span><br> 	_ = pa1 == <span class="hljs-literal">nil</span><br> 	_ = pb0 == <span class="hljs-literal">nil</span><br> 	_ = pb1 == <span class="hljs-literal">nil</span><br><br> 	<span class="hljs-comment">// 下面这三行编译不通过。</span><br> 	<span class="hljs-comment">/*</span><br><span class="hljs-comment"> 	_ = pa0 == pb0</span><br><span class="hljs-comment"> 	_ = pa1 == pb1</span><br><span class="hljs-comment"> 	_ = pa0 == Tb(nil)</span><br><span class="hljs-comment"> 	*/</span><br> &#125;<br>一个指针值不能被赋值给其它任意类型的指针值<br></code></pre></td></tr></table></figure>
</li>
<li><p>一个指针值不能被赋值给其它任意类型的指针值</p>
<blockquote>
<p>一个指针值可以被赋值给另一个指针值的条件和这两个指针值可以比较的条件（见上一小 节）是一致的。</p>
</blockquote>
<p>   <strong>但是！上述Go指针的限制是可以被打破的</strong>，Go给老哥们开了一道”后门”。</p>
<blockquote>
<p>unsafe标准库包中提供的非类型安全指针（unsafe.Pointer）机制可以被 用来打破上述Go指针的安全限制。 </p>
<p>unsafe.Pointer类型类似于C语言中的void*。</p>
<p>但是，非类型安全指针机制不推荐在Go业务编码中使用，而偏向于解决抽象性问题，例如封装一些通用的工具方法。</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h2 id="2-Go指针的使用姿势"><a href="#2-Go指针的使用姿势" class="headerlink" title="2. Go指针的使用姿势"></a>2. Go指针的使用姿势</h2><h3 id="2-1-指针（一级指针-）"><a href="#2-1-指针（一级指针-）" class="headerlink" title="2.1 指针（一级指针 *）"></a>2.1 指针（一级指针 *）</h3><p>最常见的指针形式，不赘述。</p>
<h3 id="2-2-空指针（nil）"><a href="#2-2-空指针（nil）" class="headerlink" title="2.2 空指针（nil）"></a>2.2 空指针（nil）</h3><blockquote>
<p>空指针-没有存储任何内存地址的指针。</p>
</blockquote>
<p>在go中，声明一个空指针类型，可以用nil表示</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNilPtr</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 以下两句效果等价</span><br>	<span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span><br>	<span class="hljs-keyword">var</span> b *<span class="hljs-type">int</span> = <span class="hljs-literal">nil</span><br>	fmt.Println(a)<br>	fmt.Println(b)<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// === RUN   TestNilPtr</span><br><span class="hljs-comment">// &lt;nil&gt;</span><br><span class="hljs-comment">// &lt;nil&gt;</span><br><span class="hljs-comment">// --- PASS: TestNilPtr (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure>



<h3 id="2-3-取地址（-amp-）"><a href="#2-3-取地址（-amp-）" class="headerlink" title="2.3 取地址（&amp;）"></a>2.3 取地址（&amp;）</h3><p>获得一个变量的地址，用以赋予给一个指针变量。使用%p，可以格式化打印变量的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrGetAddr</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span><br>	<span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>	a = &amp;b<br>	fmt.Println(a)<br>	fmt.Println(&amp;b)<br>    fmt.Printf(<span class="hljs-string">&quot;b.addr: %p\n&quot;</span>, &amp;b)<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// 0xc000094288</span><br><span class="hljs-comment">// 0xc000094288</span><br><span class="hljs-comment">// b.addr: 0xc000094288</span><br></code></pre></td></tr></table></figure>



<h3 id="2-4-指针传递（-Type）"><a href="#2-4-指针传递（-Type）" class="headerlink" title="2.4 指针传递（* Type）"></a>2.4 指针传递（* Type）</h3><blockquote>
<p>指针传递 - 一般指使用指针传参</p>
</blockquote>
<p>指针传参的好处与规范：</p>
<p>引自：<a target="_blank" rel="noopener" href="https://golang.google.cn/doc/faq#methods_on_values_or_pointers">https://golang.google.cn/doc/faq#methods_on_values_or_pointers</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyStruct)</span></span> pointerMethod() &#123; &#125; <span class="hljs-comment">// method on pointer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s MyStruct)</span></span>  valueMethod()   &#123; &#125; <span class="hljs-comment">// method on value</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>将接收器定义为一个值还是一个指针，与函数参数应该是一个值还是一个指针的问题是一样的。这里有几个考虑因素。</p>
<p>首先，也是最重要的，方法是否需要修改接收器？如果需要，那么接收器必须是一个指针。(slice和map作为引用传递，所以它们的故事更微妙一些，但例如在一个方法中改变一个slice的长度，接收器仍然必须是一个指针。) 在上面的例子中，如果pointerMethod修改了s的字段，那么调用者会看到这些变化，但是valueMethod是用调用者参数的副本来调用的（这就是传递值的定义），所以它所做的变化对调用者来说是不可见的。</p>
<p>顺便说一下，在Java中，方法接收者总是指针，尽管它们的指针性质在某种程度上被掩盖了（有一个建议是在语言中增加值接收者）。Go中的值接收器才是不寻常的。</p>
<p>其次是对效率的考虑。如果接收器很大，例如一个大的结构体，那么使用指针接收器就会便宜很多。</p>
<p>其次是一致性。如果该类型的一些方法必须有指针接收器，那么其他的也应该有，所以无论该类型如何使用，方法集都是一致的。详见关于方法集的章节。</p>
<p>对于基本类型、切片和小结构等类型，值接收器是非常便宜的，所以除非方法的语义需要指针，否则值接收器是高效且清晰的。</p>
</blockquote>
<p>结构体传递，也是最常见的参数，必须使用指针来避免不必要的值拷贝，提高效率。对应开篇里的例子，指针就像一本书的索引目录，在一般情况下（上文情况），告诉别人看这本书的目录索引来查找对应章节内容，总比直接告诉别人对应章节的所有内容要快。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> XXXXXX <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-number">10</span>+个字段<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(x *XXXXXX)</span></span> &#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-5-解引用（-）"><a href="#2-5-解引用（-）" class="headerlink" title="2.5 解引用（*）"></a>2.5 解引用（*）</h3><blockquote>
<p>解引用 - dereference </p>
</blockquote>
<p>引自：<a target="_blank" rel="noopener" href="https://www.golang-book.com/books/intro/8#section1">https://www.golang-book.com/books/intro/8#section1</a> </p>
<blockquote>
<p>‘*’ 也被用来 “解除引用 “指针变量。</p>
<p>解除对一个指针的引用使我们能够访问指针所指向的值。</p>
<p>当我们写<strong>*xPtr &#x3D; 0</strong>时，是指在<strong>xPtr</strong>所指的内存位置存储0（整型0）。</p>
<p>如果我们尝试<strong>xPtr &#x3D; 0</strong>，我们会得到一个编译器错误，因为<strong>xPtr</strong>不是一个<strong>int</strong>，而是一个 <strong>*int</strong> (int的指针类型)，它只能被赋予另一个<strong>*int</strong>。</p>
</blockquote>
<p>我们经常会用到解引用，其主要作用是改变指针变量指向的值的内容，简单的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDereference</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<br>	a := <span class="hljs-number">1</span><br>	fmt.Println(a)  <span class="hljs-comment">// 1</span><br>	iPtr := &amp;a<br>	*iPtr = <span class="hljs-number">2</span>  <span class="hljs-comment">// &lt;-- 这里就是利用dereference修改a的值</span><br>	fmt.Println(a)  <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Go的Reflect包反射赋值方法中，也多处使用<strong>解引用</strong>，下面摘出其一：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetBool sets v&#x27;s underlying value.</span><br><span class="hljs-comment">// It panics if v&#x27;s Kind is not Bool or if CanSet() is false.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> SetBool(x <span class="hljs-type">bool</span>) &#123;<br>	v.mustBeAssignable()<br>	v.mustBe(Bool)<br>	*(*<span class="hljs-type">bool</span>)(v.ptr) = x<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-6-new-amp-make"><a href="#2-6-new-amp-make" class="headerlink" title="2.6 new &amp; make"></a>2.6 new &amp; make</h3><blockquote>
<p>In short: <code>new</code> allocates memory, while <code>make</code> initializes the slice, map, and channel types.</p>
</blockquote>
<p>上面这句话表达得比较粗暴。</p>
<p>实际上new用于基础数据类型申请内存，并返回一个指针对象；</p>
<p>而make用于初始化slice、map、channel类型，返回的是一个对象实例（值），不是指针。</p>
<p>至于go为什么要这样设计？这个答案比较长，有兴趣了解请看：</p>
<p><a target="_blank" rel="noopener" href="https://golang.google.cn/doc/effective_go#data">https://golang.google.cn/doc/effective_go#data</a></p>
<p><a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go#allocation_make">https://golang.org/doc/effective_go#allocation_make</a></p>
<p>借文中这段搞怪的代码来体验new和make：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *[]<span class="hljs-type">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>*p = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure>



<h3 id="2-7-二级指针（-）"><a href="#2-7-二级指针（-）" class="headerlink" title="2.7 二级指针（**）"></a>2.7 二级指针（**）</h3><blockquote>
<p>二级指针 - 指向一级指针的指针变量</p>
</blockquote>
<p>指针不仅仅只有二级，而是多维；二级指针在go中已经是比较 “罕见” 了，但我们仍然需要学习它来解决和辨别一些问题。</p>
<p>引自：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection">https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection</a></p>
<blockquote>
<p>在一些语言中，一个指针可以引用另一个指针，这就需要进行多次转指操作来获取原始值。虽然每一级转指可能会增加性能成本，但为了给复杂的[数据结构]提供正确的行为，这有时是必要的。</p>
</blockquote>
<p>所以二级指针的本质也是一个指针变量，<strong>二级指针</strong>这个名字其实是对于 第一级指针 而言的，在C&#x2F;C++语言中经常出现；</p>
<p>例如在著名开源项目redis中</p>
<p>用于改变一级指针的指向（<strong>指针偏移</strong>）：</p>
<p>引自：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/ziplist.c">https://github.com/redis/redis/blob/unstable/src/ziplist.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete a single entry from the ziplist, pointed to by *p.</span><br><span class="hljs-comment"> * Also update *p in place, to be able to iterate over the</span><br><span class="hljs-comment"> * ziplist, while deleting entries. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">ziplistDelete</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **p)</span> &#123;<br>    <span class="hljs-type">size_t</span> offset = *p-zl;<br>    zl = __ziplistDelete(zl,*p,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* Store pointer to current element in p, because ziplistDelete will</span><br><span class="hljs-comment">     * do a realloc which might result in a different &quot;zl&quot;-pointer.</span><br><span class="hljs-comment">     * When the delete direction is back to front, we might delete the last</span><br><span class="hljs-comment">     * entry and end up with &quot;p&quot; pointing to ZIP_END, so check this. */</span><br>    *p = zl+offset;<br>    <span class="hljs-keyword">return</span> zl;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用于<strong>给一级指针分配堆内存空间</strong>：</p>
<p>引自：<a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/server.c">https://github.com/redis/redis/blob/unstable/src/server.c</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create the string returned by the INFO command. This is decoupled</span><br><span class="hljs-comment"> * by the INFO command itself as we need to report the same information</span><br><span class="hljs-comment"> * on memory corruption problems. */</span><br>sds <span class="hljs-title function_">genRedisInfoString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *section)</span> &#123;<br>    ......<br>        <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">char</span> *tmpsafe;  <span class="hljs-comment">// &lt;--声明tmpsafe的地方，并没有分配内存</span><br>            c = (<span class="hljs-keyword">struct</span> redisCommand *) dictGetVal(de);<br>            <span class="hljs-keyword">if</span> (!c-&gt;calls &amp;&amp; !c-&gt;failed_calls &amp;&amp; !c-&gt;rejected_calls)<br>                <span class="hljs-keyword">continue</span>;<br>            info = sdscatprintf(info,<br>                <span class="hljs-string">&quot;cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f&quot;</span><br>                <span class="hljs-string">&quot;,rejected_calls=%lld,failed_calls=%lld\r\n&quot;</span>,<br>                                <br>                <span class="hljs-comment">// 注意下面这个tmpsafe，取地址传入</span><br>                getSafeInfoString(c-&gt;name, <span class="hljs-built_in">strlen</span>(c-&gt;name), &amp;tmpsafe), c-&gt;calls, c-&gt;microseconds,<br>                <br>                (c-&gt;calls == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : ((<span class="hljs-type">float</span>)c-&gt;microseconds/c-&gt;calls),<br>                c-&gt;rejected_calls, c-&gt;failed_calls);<br>            <br>            <span class="hljs-comment">// sdscatprintf方法中可能没有释放这个tmpsafe的内存，在这里释放（sdscatprintf外部），防止内存泄露</span><br>            <span class="hljs-keyword">if</span> (tmpsafe != <span class="hljs-literal">NULL</span>) zfree(tmpsafe);<br>        &#125;<br>    ......<br>&#125;<br><br><span class="hljs-comment">/* Returns a sanitized version of s that contains no unsafe info string chars.</span><br><span class="hljs-comment"> * If no unsafe characters are found, simply returns s. Caller needs to</span><br><span class="hljs-comment"> * free tmp if it is non-null on return.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">getSafeInfoString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> len, <span class="hljs-type">char</span> **tmp)</span> &#123;<br>    *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (mempbrk(s, len, unsafe_info_chars,<span class="hljs-keyword">sizeof</span>(unsafe_info_chars)<span class="hljs-number">-1</span>)<br>        == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-type">char</span> *new = *tmp = zmalloc(len + <span class="hljs-number">1</span>);  <span class="hljs-comment">// &lt;--这里给tmpsafe分配了内存</span><br>    <span class="hljs-built_in">memcpy</span>(new, s, len);<br>    new[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,<br>                       <span class="hljs-keyword">sizeof</span>(unsafe_info_chars)<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<p>我们回到go，在go中也有对应的用法，但我们可能还不太理解 二级指针 的重要性，这里举一个示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AA <span class="hljs-keyword">struct</span> &#123;<br>	B <span class="hljs-type">string</span><br>	C <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AA)</span></span> SetB(b <span class="hljs-type">string</span>) &#123;<br>	<span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>		a = <span class="hljs-built_in">new</span>(AA)<br>	&#125;<br>	a.B = b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrNew</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a *AA<br>	<span class="hljs-comment">//a.B = &quot;bb&quot; 这里必然panic，上面学了new的支持已经明白</span><br>	a.SetB(<span class="hljs-string">&quot;bb&quot;</span>)<br>	fmt.Println(a.B)<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference [recovered]<br></code></pre></td></tr></table></figure>

<p>这个例子在 *<em>func (a <em>AA) SetB(b string)</em></em> 中已经给 <strong>指针对象 a</strong> 申请了内存，为什么仍然报空指针错误呢？</p>
<p>大家能说出引发panic的是哪一行代码吗？</p>
<p>我们来打印 <strong>对象a</strong> 在new前后的自身地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AA <span class="hljs-keyword">struct</span> &#123;<br>	B <span class="hljs-type">string</span><br>	C <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AA)</span></span> SetB(b <span class="hljs-type">string</span>) &#123;<br>	fmt.Printf(<span class="hljs-string">&quot;Before New: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br>	<span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>		a = <span class="hljs-built_in">new</span>(AA)<br>	&#125;<br>	a.B = b<br>	fmt.Printf(<span class="hljs-string">&quot;After New: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrNew</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a *AA<br>	fmt.Printf(<span class="hljs-string">&quot;Before SetB: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br>	<span class="hljs-comment">//a.B = &quot;bb&quot;</span><br>	a.SetB(<span class="hljs-string">&quot;bb&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;After SetB: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br>	fmt.Println(a.B)<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-comment">// === RUN   TestPtrNew</span><br><span class="hljs-comment">// Before SetB: value: &lt;nil&gt;, addr: 0xc000006038</span><br><span class="hljs-comment">// Before New: value: &lt;nil&gt;, addr: 0xc000006040</span><br><span class="hljs-comment">// After New: value: &amp;&#123;B:bb C:&#125;, addr: 0xc000006040</span><br><span class="hljs-comment">// After SetB: value: &lt;nil&gt;, addr: 0xc000006038</span><br><span class="hljs-comment">// --- FAIL: TestPtrNew (0.00s)</span><br><span class="hljs-comment">// panic: runtime error: invalid memory address or nil pointer dereference [recovered]</span><br></code></pre></td></tr></table></figure>

<p>这里可以看到，*<em>var a <em>AA</em></em> 的a变量 和 *<em>func (a <em>AA) SetB(b string)</em></em> 的a变量 ，</p>
<p>本质上不是同一个东西（不是同一个变量，即不是同一块内存地址），</p>
<p>只是他们都指向名为 <strong>AA</strong> 的结构体对象的指针罢了。</p>
<p>在 *<em>func (a <em>AA) SetB(b string)</em></em> 中给 a变量 申请内存，对 <strong>TestPtrNew()</strong> 中的a变量没有产生影响；</p>
<p>因为 <strong>a.SetB(“bb”)</strong> 这个动作中，a变量是指针传递，传递了<strong>nil</strong>，</p>
<p>而没有把 *<em>var a <em>AA</em></em> 的本身内存地址，传递到 *<em>func (a <em>AA) SetB(b string)</em></em> 中。</p>
<p>那我如果就是要在方法内给 <strong>a</strong>指针对象 申请内存，如何实现？</p>
<p><strong>方案一：</strong>将上文在 *<em>func (a <em>AA) SetB(b string)</em></em> 申请的 <strong>a</strong> 对象 return 出去，很常见的做法；</p>
<p><strong>方案二：</strong>传递二级指针：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*AA)</span></span> SetB_P2(b <span class="hljs-type">string</span>, a **AA)  &#123;<br>	<span class="hljs-keyword">if</span> *a == <span class="hljs-literal">nil</span> &#123;<br>		*a = <span class="hljs-built_in">new</span>(AA)<br>	&#125;<br>	(*a).B = b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrNew_P2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	<span class="hljs-keyword">var</span> a *AA<br>	a.SetB_P2(<span class="hljs-string">&quot;bb&quot;</span>, &amp;a)<br>	fmt.Println(a.B)<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// === RUN   TestPtrNew_P2</span><br><span class="hljs-comment">// bb</span><br><span class="hljs-comment">// --- PASS: TestPtrNew_P2 (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure>



<h2 id="3-Go变量存储的内存位置"><a href="#3-Go变量存储的内存位置" class="headerlink" title="3. Go变量存储的内存位置"></a>3. Go变量存储的内存位置</h2><p>Go是否像C&#x2F;C++一样，是在堆内存上申请？</p>
<p>我们来看官方说法：<a target="_blank" rel="noopener" href="https://golang.org/doc/effective_go#allocation_make">https://golang.org/doc/effective_go#allocation_make</a></p>
<blockquote>
<p>从正确性的角度来看，你不需要知道。</p>
<p>在Go中，每个变量的生命周期取决于它是否被引用。</p>
<p>实现所选择的存储位置与语言的语义无关。</p>
<p>存储位置确实对编写高效程序有影响。</p>
<p>在可能的情况下，Go编译器会在一个函数的堆栈框架中分配属于该函数的局部变量。</p>
<p>然而，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在GC的堆上分配该变量，以避免[悬空指针]错误。</p>
<p>另外，如果一个局部变量非常大，它会被存储在堆上。</p>
<p>在目前的编译器中，如果一个变量的地址被占用，那么这个变量就是在堆上分配的候选变量。</p>
<p>然而，编译期间的<strong>逃逸分析</strong>会识别哪些变量可以存放在栈空间上。</p>
</blockquote>
<p><strong>在上面的一大段文字可以总结出几个关键信息：</strong></p>
<ol>
<li><strong>Go的变量在内存中存储的位置与语法无关；</strong></li>
<li><strong>Go的变量生命周期与该变量本身被引用的范围有关；</strong></li>
<li><strong>Go的变量内存在GC的堆栈上分配；</strong></li>
<li><strong>Go的变量太大会强制在堆上分配；</strong></li>
<li><strong>Go编译期的逃逸分析对变量存储位置有决定性作用；</strong></li>
</ol>
<h3 id="3-1-堆-or-栈？"><a href="#3-1-堆-or-栈？" class="headerlink" title="3.1 堆 or 栈？"></a>3.1 堆 or 栈？</h3><p>我们来实际验证一下，上代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-number">1</span> <span class="hljs-keyword">package</span> main<br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span> <span class="hljs-keyword">import</span> (<br> <span class="hljs-number">4</span>     <span class="hljs-string">&quot;time&quot;</span><br> <span class="hljs-number">5</span> )<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHeap</span><span class="hljs-params">()</span></span> (*<span class="hljs-type">int</span>, *<span class="hljs-type">int</span>) &#123;<br> <span class="hljs-number">8</span>     <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br> <span class="hljs-number">9</span>     <span class="hljs-keyword">var</span> y <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br><span class="hljs-number">10</span> <br><span class="hljs-number">11</span>     z := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span>     <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br><span class="hljs-number">14</span>     <span class="hljs-keyword">var</span> j = <span class="hljs-number">2</span><br><span class="hljs-number">15</span> <br><span class="hljs-number">16</span>     <span class="hljs-built_in">println</span>(&amp;x, &amp;y, z, &amp;i, &amp;j)<br><span class="hljs-number">17</span> <br><span class="hljs-number">18</span>     <span class="hljs-keyword">return</span> &amp;x, &amp;y<br><span class="hljs-number">19</span> &#125;<br><span class="hljs-number">20</span> <br><span class="hljs-number">21</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-number">22</span>     <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-number">23</span>     <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br><span class="hljs-number">24</span> <br><span class="hljs-number">25</span>     x, y := testHeap()<br><span class="hljs-number">26</span>     s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>)<br><span class="hljs-number">27</span> <br><span class="hljs-number">28</span>     <span class="hljs-built_in">println</span>(&amp;a, &amp;b, x, y, &amp;(s[<span class="hljs-number">0</span>]))<br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span>     <span class="hljs-keyword">for</span> &#123;<br><span class="hljs-number">31</span>         time.Sleep(time.Second)<br><span class="hljs-number">32</span>     &#125;<br><span class="hljs-number">33</span> &#125;<br><br></code></pre></td></tr></table></figure>

<p>使用 <strong>go run -gcflags ‘-m -l’ memory.go</strong> 命令观察”逃逸”（-m：逃逸分析  -l：禁止内联）</p>
<p>输出结果如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"># command-line-arguments<br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>:<span class="hljs-number">9</span>: moved to heap: x    <span class="hljs-comment">// &lt;- x,y因为要返回给func外部使用，因此在heap上存储</span><br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>:<span class="hljs-number">9</span>: moved to heap: y<br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">11</span>:<span class="hljs-number">13</span>: <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) does not escape  <span class="hljs-comment">// &lt;- z虽然是指针并且new()，但没有逃逸出func，因此在stack上存储</span><br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">26</span>:<span class="hljs-number">14</span>: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>) escapes to heap  <span class="hljs-comment">// &lt;- s这个变量很大，逃逸到heap上存储</span><br><span class="hljs-number">0xc0000140a0</span> <span class="hljs-number">0xc0000140a8</span> <span class="hljs-number">0xc000066ea0</span> <span class="hljs-number">0xc000066e98</span> <span class="hljs-number">0xc000066e90</span><br><span class="hljs-number">0xc000066f20</span> <span class="hljs-number">0xc000066f18</span> <span class="hljs-number">0xc0000140a0</span> <span class="hljs-number">0xc0000140a8</span> [<span class="hljs-number">0</span>/<span class="hljs-number">10000</span>]<span class="hljs-number">0xc000080000</span><br></code></pre></td></tr></table></figure>

<p>我们再来整理出各个变量的地址：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>内:<br>x: <span class="hljs-number">0xc0000140a0</span><br>y: <span class="hljs-number">0xc0000140a8</span>  <span class="hljs-comment">// &lt;--相比x的地址高了8个byte</span><br>z: <span class="hljs-number">0xc000066ea0</span><br>i: <span class="hljs-number">0xc000066e98</span>  <span class="hljs-comment">// &lt;--相比z的地址低了8个byte</span><br>j: <span class="hljs-number">0xc000066e90</span>  <span class="hljs-comment">// &lt;--相比j的地址低了8个byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>外:<br>a: <span class="hljs-number">0xc000066f20</span><br>b: <span class="hljs-number">0xc000066f18</span>  <span class="hljs-comment">// &lt;--相比a的地址低了8个byte</span><br>x: <span class="hljs-number">0xc0000140a0</span><br>y: <span class="hljs-number">0xc0000140a8</span>  <span class="hljs-comment">// &lt;--相比x的地址高了8个byte</span><br>s: <span class="hljs-number">0xc000080000</span><br></code></pre></td></tr></table></figure>

<p>可以看出：其中x，y，s符合堆内存空间增长方向（递增）；a、b、z、i、j符合栈内存空间增长方向（递减）。</p>
<p>这部分数据证明了上述的1、2、5点。</p>
<h3 id="3-2-内存预申请"><a href="#3-2-内存预申请" class="headerlink" title="3.2 内存预申请"></a>3.2 内存预申请</h3><p>那在GO中，栈空间地址是否一定大于堆空间地址？试验几次之后，发现并不是~</p>
<p>我们看下这个进程的内存分布情况：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go">[root@czy memory]# ps -ef | grep <span class="hljs-keyword">go</span><br>czy       <span class="hljs-number">17772</span>      <span class="hljs-number">1</span>  <span class="hljs-number">0</span> Aug26 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/libexec/goa-daemon<br>czy       <span class="hljs-number">17810</span>      <span class="hljs-number">1</span>  <span class="hljs-number">0</span> Aug26 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/libexec/gvfs-goa-volume-monitor<br>czy       <span class="hljs-number">17839</span>      <span class="hljs-number">1</span>  <span class="hljs-number">0</span> Aug26 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/libexec/goa-identity-service<br>root      <span class="hljs-number">26104</span>  <span class="hljs-number">20319</span>  <span class="hljs-number">0</span> Aug26 pts/<span class="hljs-number">1</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-keyword">go</span> run -gcflags -m -N -l memory.<span class="hljs-keyword">go</span><br>root      <span class="hljs-number">26139</span>  <span class="hljs-number">26104</span>  <span class="hljs-number">0</span> Aug26 pts/<span class="hljs-number">1</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory <span class="hljs-comment">// &lt;-- 注意这个才是</span><br>root      <span class="hljs-number">26280</span>  <span class="hljs-number">22527</span>  <span class="hljs-number">0</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span> pts/<span class="hljs-number">2</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> grep --color=auto <span class="hljs-keyword">go</span><br>[root@czy memory]# cd /proc/<span class="hljs-number">26139</span><br>[root@czy <span class="hljs-number">26139</span>]# cat maps<br><span class="hljs-number">00400000</span><span class="hljs-number">-00458000</span> r-xp <span class="hljs-number">00000000</span> fd:<span class="hljs-number">00</span> <span class="hljs-number">57563390</span>                           /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory<br><span class="hljs-number">00458000</span><span class="hljs-number">-004</span>bf000 r--p <span class="hljs-number">00058000</span> fd:<span class="hljs-number">00</span> <span class="hljs-number">57563390</span>                           /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory<br><span class="hljs-number">004</span>bf000<span class="hljs-number">-004</span>c4000 rw-p <span class="hljs-number">000</span>bf000 fd:<span class="hljs-number">00</span> <span class="hljs-number">57563390</span>                           /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory<br><span class="hljs-number">004</span>c4000<span class="hljs-number">-004</span>f7000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br>c000000000-c000400000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>    <span class="hljs-comment">// &lt;-- 重点看这段可读可写的内存，上面输出的变量地址均落在这个区间。</span><br>c000400000-c004000000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f2d974000<span class="hljs-number">-7</span>f4f2fce5000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f2fce5000<span class="hljs-number">-7</span>f4f3fe65000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f3fe65000<span class="hljs-number">-7</span>f4f3fe66000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f3fe66000<span class="hljs-number">-7</span>f4f51d15000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f51d15000<span class="hljs-number">-7</span>f4f51d16000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f51d16000<span class="hljs-number">-7</span>f4f540eb000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f540eb000<span class="hljs-number">-7</span>f4f540ec000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f540ec000<span class="hljs-number">-7</span>f4f54565000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f54565000<span class="hljs-number">-7</span>f4f54566000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f54566000<span class="hljs-number">-7</span>f4f545e5000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f545e5000<span class="hljs-number">-7</span>f4f54645000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>ffe8c4cb000<span class="hljs-number">-7</span>ffe8c4ec000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                          [stack]<br><span class="hljs-number">7</span>ffe8c56f000<span class="hljs-number">-7</span>ffe8c571000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                  [vsyscall]<br></code></pre></td></tr></table></figure>



<p>为啥不能像C&#x2F;C++进程一样可以准确显示出 <strong>[heap]</strong> 和 <strong>[stack]</strong> 的内存分布呢？</p>
<p>来回顾到第3点，内存在GC上分配。</p>
<p>难道GO的内存是由GC统一申请一块大内存块，再按需进行分配给个个变量的？类似于内存池？</p>
<p>我们来看go1.17源码：src&#x2F;runtime&#x2F;malloc.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Allocate an object of size bytes.</span><br><span class="hljs-comment">// Small objects are allocated from the per-P cache&#x27;s free lists.</span><br><span class="hljs-comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-type">uintptr</span>, typ *_type, needzero <span class="hljs-type">bool</span>)</span></span> unsafe.Pointer &#123;<br>	<span class="hljs-keyword">if</span> gcphase == _GCmarktermination &#123;<br>		throw(<span class="hljs-string">&quot;mallocgc called with gcphase == _GCmarktermination&quot;</span>)<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zerobase)<br>	&#125;<br><br>	<span class="hljs-comment">// Set mp.mallocing to keep from being preempted by GC.</span><br>	......<br>    <br>	<span class="hljs-keyword">if</span> size &lt;= maxSmallSize &#123;<br>		......<br>        <br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		shouldhelpgc = <span class="hljs-literal">true</span><br>		span = c.allocLarge(size, needzero, noscan)  <span class="hljs-comment">// &lt;--- 根据描述，大size必然在heap申请，我们关注这个方法</span><br>		span.freeindex = <span class="hljs-number">1</span><br>		span.allocCount = <span class="hljs-number">1</span><br>		x = unsafe.Pointer(span.base())<br>		size = span.elemsize<br>	&#125;<br><br>    ......<br>    <br>	<span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// allocLarge allocates a span for a large object.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *mcache)</span></span> allocLarge(size <span class="hljs-type">uintptr</span>, needzero <span class="hljs-type">bool</span>, noscan <span class="hljs-type">bool</span>) *mspan &#123;<br>	......<br><br>	spc := makeSpanClass(<span class="hljs-number">0</span>, noscan)<br>	s := mheap_.alloc(npages, spc, needzero)  <span class="hljs-comment">// &lt;--- 注意这个方法</span><br>	<span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>		throw(<span class="hljs-string">&quot;out of memory&quot;</span>)<br>	&#125;<br>    <br>	......<br>&#125;<br><br><span class="hljs-keyword">var</span> mheap_ mheap  &lt;--- !!!!原来<span class="hljs-keyword">go</span>一开始就定义一块全局<span class="hljs-keyword">struct</span>来管理heap<br><br><span class="hljs-comment">// Main malloc heap.</span><br><span class="hljs-comment">// The heap itself is the &quot;free&quot; and &quot;scav&quot; treaps,</span><br><span class="hljs-comment">// but all the other global data is here too.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// mheap must not be heap-allocated because it contains mSpanLists,</span><br><span class="hljs-comment">// which must not be heap-allocated.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//go:notinheap</span><br><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看到这里，已经猜测到十有八九，但没有再继续精细研究 <code>mheap_</code> 如何在各种情况下调度，姑且证明第4点。而第3点，在 <code>func mallocgc()</code> 的注释有说明：<strong>Large objects (&gt; 32 kB) are allocated straight from the heap.</strong></p>
<h2 id="4-unsafe-Pointer："><a href="#4-unsafe-Pointer：" class="headerlink" title="4. unsafe.Pointer："></a>4. unsafe.Pointer：</h2><h3 id="4-1-unsafe-Pointer的内部结构"><a href="#4-1-unsafe-Pointer的内部结构" class="headerlink" title="4.1 unsafe.Pointer的内部结构"></a>4.1 unsafe.Pointer的内部结构</h3><p>go1.16源码：unsafe&#x2F;unsafe.go，</p>
<p>unsafe.Pointer，请容我称之为真正的指针！我们来看看它的内部结构：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pointer *ArbitraryType<br><br><span class="hljs-comment">// ArbitraryType 仅用于文档目的，实际上并不是 unsafe 包的一部分。它代表任意 Go 表达式的类型。</span><br><span class="hljs-keyword">type</span> ArbitraryType <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure>

<p>所以，unsafe.Pointer的类型，就是一个<strong>int指针</strong>，随操作系统位数，指向4或8个字节的内存地址。</p>
<p>unsafe&#x2F;unsafe.go 这个文件中还有非常多关于 unsafe.Pointer 的使用说明，有空可以仔细阅读，有助于理解底层代码实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pointer表示指向任意类型的指针。有四种特殊操作:</span><br><span class="hljs-comment">// Pointer有着其他指针类型不具备的能力：</span><br><span class="hljs-comment">// - 任何类型的指针值都可以转换为Pointer。</span><br><span class="hljs-comment">// - Pointer可以转换为任何类型的指针值。</span><br><span class="hljs-comment">// - uintptr可以转换为Pointer。</span><br><span class="hljs-comment">// - 可以将Pointer转换为uintptr。</span><br><span class="hljs-comment">// 因此Pointer允许程序突破golang类型系统的限制并读写任意内存。应该非常小心地使用它。</span><br></code></pre></td></tr></table></figure>



<h3 id="4-2-从string简析unsafe-Pointer"><a href="#4-2-从string简析unsafe-Pointer" class="headerlink" title="4.2 从string简析unsafe.Pointer"></a>4.2 从string简析unsafe.Pointer</h3><h4 id="4-1-1-string的内部结构"><a href="#4-1-1-string的内部结构" class="headerlink" title="4.1.1 string的内部结构"></a>4.1.1 string的内部结构</h4><p>我们就用string的底层结构来稍微了解下unsafe.Pointer的意义。</p>
<p>首先是位于 src&#x2F;builtin&#x2F;builtin.go 作者对 string 的描述：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="hljs-comment">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="hljs-comment">// not nil. Values of string type are immutable.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">string</span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure>

<p>包含几个信息：</p>
<blockquote>
<p>string是所有8位的字节的字符串的集合，通常但不一定代表UTF-8编码的文本。<br>string对象可以是空的，但不会nil。<br>string类型的值是不可变的。（这句话有点迷惑性~。[不可变]的意思是，可以被替换的。甚至在一些情况下，是可以被修改的，哪些情况，看下文）</p>
</blockquote>
<p>为什么是**[不可变]**？源码注释这样写，总有他的道理。</p>
<p>我们来看 string 的底层结构，可以看出由一个指针和一个int组成：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>	str unsafe.Pointer  <span class="hljs-comment">// 指向内存地址起点的指针</span><br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>             <span class="hljs-comment">// 内容的长度(占内存的字节数)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>你看这个string的结构开头小写，而且成员变量都是小写开头，按Go的语法，是<strong>私有</strong>的，当然不可修改啦~（不可变）。所以，[不可变]是对于<strong>常规手段</strong>而言的。</p>
<h4 id="4-1-2-string的拼接过程"><a href="#4-1-2-string的拼接过程" class="headerlink" title="4.1.2 string的拼接过程"></a>4.1.2 string的拼接过程</h4><p>探索一下string是如何构造的，我们来写一段代码：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span> <span class="hljs-keyword">package</span> main<br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-number">4</span>     a := <span class="hljs-string">&quot;1111111111&quot;</span><br><span class="hljs-number">5</span>     b := a + <span class="hljs-string">&quot;2222&quot;</span><br><span class="hljs-number">6</span>     <span class="hljs-built_in">print</span>(a, b)<br><span class="hljs-number">7</span> &#125;<br></code></pre></td></tr></table></figure>

<p>使用 go tool 工具分析编译过程：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool compile -S concat.go<br></code></pre></td></tr></table></figure>

<p>会产出非常多的信息，我们重点关注以下几段：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000 00000 (concat.go:3)	TEXT	&quot;&quot;.main(SB), ABIInternal, $96-0<br>0x0000 00000 (concat.go:3)	CMPQ	SP, 16(R14)<br>0x0004 00004 (concat.go:3)	PCDATA	$0, $-2<br>0x0004 00004 (concat.go:3)	JLS	116<br>0x0006 00006 (concat.go:3)	PCDATA	$0, $-1<br>0x0006 00006 (concat.go:3)	SUBQ	$96, SP<br>0x000a 00010 (concat.go:3)	MOVQ	BP, 88(SP)<br>0x000f 00015 (concat.go:3)	LEAQ	88(SP), BP<br>0x0014 00020 (concat.go:3)	FUNCDATA	$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)<br>0x0014 00020 (concat.go:3)	FUNCDATA	$1, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)<br>0x0014 00020 (concat.go:5)	LEAQ	&quot;&quot;..autotmp_2+48(SP), AX<br>0x0019 00025 (concat.go:5)	LEAQ	go.string.&quot;1111111111&quot;(SB), BX  // &lt;-- 这个暂时不分析，后面讲<br>0x0020 00032 (concat.go:5)	MOVL	$10, CX<br>0x0025 00037 (concat.go:5)	LEAQ	go.string.&quot;2222&quot;(SB), DI  // &lt;-- 这个暂时不分析，后面讲<br>0x002c 00044 (concat.go:5)	MOVL	$4, SI<br>0x0031 00049 (concat.go:5)	PCDATA	$1, $0<br>0x0031 00049 (concat.go:5)	CALL	runtime.concatstring2(SB)  // &lt;-- 重点关注这个<br></code></pre></td></tr></table></figure>

<p> 我们来到这个文件：src&#x2F;runtime&#x2F;string.go</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstring2</span><span class="hljs-params">(buf *tmpBuf, a [2]<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	<span class="hljs-keyword">return</span> concatstrings(buf, a[:])<br>&#125;<br><br><span class="hljs-comment">// concatstrings implements a Go string concatenation x+y+z+...</span><br><span class="hljs-comment">// The operands are passed in the slice a.</span><br><span class="hljs-comment">// If buf != nil, the compiler has determined that the result does not</span><br><span class="hljs-comment">// escape the calling function, so the string data can be stored in buf</span><br><span class="hljs-comment">// if small enough.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstrings</span><span class="hljs-params">(buf *tmpBuf, a []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	idx := <span class="hljs-number">0</span><br>	l := <span class="hljs-number">0</span><br>	count := <span class="hljs-number">0</span><br>	<span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> a &#123;<br>		n := <span class="hljs-built_in">len</span>(x)<br>		<span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>			<span class="hljs-keyword">continue</span><br>		&#125;<br>		<span class="hljs-keyword">if</span> l+n &lt; l &#123;<br>			throw(<span class="hljs-string">&quot;string concatenation too long&quot;</span>)<br>		&#125;<br>		l += n     <span class="hljs-comment">// &lt;---累加总长度</span><br>		count++<br>		idx = i<br>	&#125;<br>	<span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>	&#125;<br><br>	<span class="hljs-comment">// If there is just one string and either it is not on the stack</span><br>	<span class="hljs-comment">// or our result does not escape the calling frame (buf != nil),</span><br>	<span class="hljs-comment">// then we can return that string directly.</span><br>	<span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> &amp;&amp; (buf != <span class="hljs-literal">nil</span> || !stringDataOnStack(a[idx])) &#123;<br>		<span class="hljs-keyword">return</span> a[idx]<br>	&#125;<br>	s, b := rawstringtmp(buf, l)  <span class="hljs-comment">// &lt;--一次性申请一块完整内存</span><br>	<span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> a &#123;         <span class="hljs-comment">// &lt;--遍历原始字符串再逐个拷贝到空的已分配内存的slice中</span><br>		<span class="hljs-built_in">copy</span>(b, x)<br>		b = b[<span class="hljs-built_in">len</span>(x):]            <span class="hljs-comment">// &lt;--切片指向往后偏移，方便下一次赋值。</span><br>	&#125;<br>	<span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rawstringtmp</span><span class="hljs-params">(buf *tmpBuf, l <span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">string</span>, b []<span class="hljs-type">byte</span>) &#123;<br>	<span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; l &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>		b = buf[:l]<br>		s = slicebytetostringtmp(&amp;b[<span class="hljs-number">0</span>], <span class="hljs-built_in">len</span>(b))<br>	&#125; <span class="hljs-keyword">else</span> &#123;<br>		s, b = rawstring(l)  <span class="hljs-comment">// &lt;-- 抛开这个判断，我们重点看buf==nil的情况</span><br>	&#125;<br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringStructOf</span><span class="hljs-params">(sp *<span class="hljs-type">string</span>)</span></span> *stringStruct &#123;<br>	<span class="hljs-keyword">return</span> (*stringStruct)(unsafe.Pointer(sp))<br>&#125;<br><br><span class="hljs-comment">// rawstring allocates storage for a new string. The returned</span><br><span class="hljs-comment">// string and byte slice both refer to the same storage.</span><br><span class="hljs-comment">// The storage is not zeroed. Callers should use</span><br><span class="hljs-comment">// b to set the string contents and then drop b.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rawstring</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">string</span>, b []<span class="hljs-type">byte</span>) &#123;<br>	p := mallocgc(<span class="hljs-type">uintptr</span>(size), <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>) <span class="hljs-comment">// &lt;--给p申请一块size个byte的内存空间</span><br><br>	stringStructOf(&amp;s).str = p<br>	stringStructOf(&amp;s).<span class="hljs-built_in">len</span> = size<br><br>    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;  <span class="hljs-comment">// &lt;--这里切片构造三个参数是slice&#123;array, len, cap&#125;，把p交给slice对象的array指针接管。就是构造一个有size大小的[]byte类型的空切片。</span><br><br>	<span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这就是字符串拼接时，指针对内存的操作，但这里的copy()方法我没有找到实现，比较遗憾，还不够明显看到如何拷贝内存</p>
<p>再来看下go对外提供插件生成字符串的的gostring()方法，从中看到指针偏移拷贝内存的过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// This is exported via linkname to assembly in syscall (for Plan9).</span><br><span class="hljs-comment">//go:linkname gostring</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gostring</span><span class="hljs-params">(p *<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>	l := findnull(p)<br>	<span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>	&#125;<br>    s, b := rawstring(l)  <span class="hljs-comment">// &lt;--获取一个string对象s及s.str(已申请l个byte内存的[]byte切片)</span><br>    memmove(unsafe.Pointer(&amp;b[<span class="hljs-number">0</span>]), unsafe.Pointer(p), <span class="hljs-type">uintptr</span>(l))  <span class="hljs-comment">// &lt;--相当于memcpy()，将p地址起始的值逐个拷贝到b[0]指向的地址(就是[]byte的头地址)，逐个偏移，偏移l个字节。</span><br>	<span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// memmove copies n bytes from &quot;from&quot; to &quot;to&quot;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// memmove ensures that any pointer in &quot;from&quot; is written to &quot;to&quot; with</span><br><span class="hljs-comment">// an indivisible write, so that racy reads cannot observe a</span><br><span class="hljs-comment">// half-written pointer. This is necessary to prevent the garbage</span><br><span class="hljs-comment">// collector from observing invalid pointers, and differs from memmove</span><br><span class="hljs-comment">// in unmanaged languages. However, memmove is only required to do</span><br><span class="hljs-comment">// this if &quot;from&quot; and &quot;to&quot; may contain pointers, which can only be the</span><br><span class="hljs-comment">// case if &quot;from&quot;, &quot;to&quot;, and &quot;n&quot; are all be word-aligned.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Implementations are in memmove_*.s.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//go:noescape</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">memmove</span><span class="hljs-params">(to, from unsafe.Pointer, n <span class="hljs-type">uintptr</span>)</span></span>   <span class="hljs-comment">// &lt;--系统函数</span><br></code></pre></td></tr></table></figure>

<p>我们再来看下memmove在linux系统函数中的定义（下图来自CentOS7）man 3 memmove：</p>
<p><img src="manbook.png" srcset="/img/loading.gif" lazyload></p>
<p>重点关注<strong>copies</strong>字样，从src(数据源)内存区域拷贝n个字节到dest(目标)内存区域。并且<strong>线程安全</strong>。</p>
<blockquote>
<p>小贴士：memmove() 是 memcpy() 的改良版本，解决memcpy()在src和dest存在重叠的内存空间时copy数据出现的问题；因为需要向下兼容所以改了个名字叫memmove，并不是真正意义上的”move”操作。有兴趣可以再研究下内部如何做到线程安全以及避免内存空间重叠。</p>
</blockquote>
<h4 id="4-1-3-string的传递效率"><a href="#4-1-3-string的传递效率" class="headerlink" title="4.1.3 string的传递效率"></a>4.1.3 string的传递效率</h4><p>我们再来看string传参的内存分布，可以看出string传参表面上是值传递，内部的 str 则是指针传递：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// StringHeader is the runtime representation of a string.</span><br><span class="hljs-comment">// It cannot be used safely or portably and its representation may</span><br><span class="hljs-comment">// change in a later release.</span><br><span class="hljs-comment">// Moreover, the Data field is not sufficient to guarantee the data</span><br><span class="hljs-comment">// it references will not be garbage collected, so programs must keep</span><br><span class="hljs-comment">// a separate, correctly typed pointer to the underlying data.</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>	Data <span class="hljs-type">uintptr</span><br>	Len  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>	str unsafe.Pointer  <span class="hljs-comment">// 指向内存地址起点的指针</span><br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>             <span class="hljs-comment">// 内容的长度(占内存的字节数)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestStringPassingParameters</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br>		<span class="hljs-comment">// 由于string底层的stringStruct是私有的不能直接访问，因此使用反射包通过runtime获取</span><br>		hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))   <span class="hljs-comment">// &lt;---查看指向的内存是否一致</span><br>		fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, hdr.Data)<br>	&#125;<br>	s1 := <span class="hljs-string">&quot;abd&quot;</span><br>	hdr1 := (*reflect.StringHeader)(unsafe.Pointer(&amp;s1))   <span class="hljs-comment">// &lt;---查看指向的内存是否一致</span><br>	fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, hdr1.Data)<br>	f(s1)<br>&#125;<br><br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// === RUN   TestStringPassingParameters</span><br><span class="hljs-comment">// 3f6d04</span><br><span class="hljs-comment">// 3f6d04</span><br><span class="hljs-comment">// --- PASS: TestStringPassingParameters (0.00s)</span><br></code></pre></td></tr></table></figure>

<p>当外部的s1被修改时，只修改内部str的指向，旧数据仍然被其他指针引用着，因此 f 方法外的 s1 对象被修改，也不会影响到 f 方法内部的s对象；当方法退出，没有指针再引用该旧数据时，GC会将其回收。</p>
<blockquote>
<p>小贴士：</p>
<p>在大量字符串拼接时，应该使用bytes.Buffer，极大提高性能！</p>
<p>拼接字符串性能：bytes.Buffer() &gt; +号 &gt; fmt.Sprintf()</p>
</blockquote>
<h3 id="4-3-指针偏移读写内存"><a href="#4-3-指针偏移读写内存" class="headerlink" title="4.3 指针偏移读写内存"></a>4.3 指针偏移读写内存</h3><h4 id="4-3-1-读写字符串内容"><a href="#4-3-1-读写字符串内容" class="headerlink" title="4.3.1 读写字符串内容"></a>4.3.1 读写字符串内容</h4><p>我们写一段代码看看如何通过指针偏移获取字符串中的各个字符</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>	<span class="hljs-string">&quot;fmt&quot;</span><br>	<span class="hljs-string">&quot;reflect&quot;</span><br>	<span class="hljs-string">&quot;time&quot;</span><br>	<span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>	a := <span class="hljs-string">&quot;1234567&quot;</span><br><br>	fmt.Println(a)<br>	fmt.Println(&amp;a)<br>	fmt.Println(unsafe.Pointer(&amp;a))<br><br>	p := (*reflect.StringHeader)(unsafe.Pointer(&amp;a)).Data  <span class="hljs-comment">// &lt;-- 拿出底层数组的头指针，这个指针指向真实存储string内存的内存地址</span><br>	fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, p)<br><br>	p1 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p))<br>	fmt.Println(*p1)  <span class="hljs-comment">// &lt;-- 打印一下是不是第一个字符的ASCII码</span><br><br>	p2 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p+<span class="hljs-number">1</span>))<br>	fmt.Println(*p2)  <span class="hljs-comment">// &lt;-- 向后偏移一个字节</span><br><br>	<span class="hljs-comment">//*p2 = 88   如果解开这个注释会panic，这里不能赋值，为什么呢？大家猜一猜~</span><br><br>	<span class="hljs-keyword">for</span> &#123;<br>		time.Sleep(time.Minute)<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-number">1234567</span><br><span class="hljs-number">0xc000010240</span>  <span class="hljs-comment">// &lt;-- a的地址</span><br><span class="hljs-number">0xc000010240</span>  <span class="hljs-comment">// &lt;-- a的地址</span><br><span class="hljs-number">495</span>b45        <span class="hljs-comment">// &lt;-- a.str 指向的地址：真正存储string内容的内存地址</span><br><span class="hljs-number">49</span>            <span class="hljs-comment">// &lt;-- 字符1的 ASCII 码</span><br><span class="hljs-number">50</span>            <span class="hljs-comment">// &lt;-- 字符2的 ASCII 码</span><br></code></pre></td></tr></table></figure>

<p>我们来看看内存分布：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@czy ~]# ps -ef | grep offset<br>root      18930  18429  0 20:16 pts/1    00:00:00 go run offset_1.go<br>root      18970  18930  0 20:16 pts/1    00:00:00 /tmp/go-build4270767253/b001/exe/offset_1<br>root      19036  18991  0 20:18 pts/2    00:00:00 grep --color=auto offset<br>[root@czy ~]# cd /proc/18970<br>[root@czy 18970]# cat maps<br>00400000-00480000 r-xp 00000000 fd:00 50573659                           /tmp/go-build4270767253/b001/exe/offset_1<br>00480000-0050f000 r--p 00080000 fd:00 50573659                           /tmp/go-build4270767253/b001/exe/offset_1<br>0050f000-00527000 rw-p 0010f000 fd:00 50573659                           /tmp/go-build4270767253/b001/exe/offset_1<br>00527000-0055c000 rw-p 00000000 00:00 0 <br>c000000000-c000400000 rw-p 00000000 00:00 0 <br>c000400000-c004000000 ---p 00000000 00:00 0 <br>7f27818eb000-7f2783c9c000 rw-p 00000000 00:00 0 <br>7f2783c9c000-7f2793e1c000 ---p 00000000 00:00 0 <br>7f2793e1c000-7f2793e1d000 rw-p 00000000 00:00 0 <br>7f2793e1d000-7f27a5ccc000 ---p 00000000 00:00 0 <br>7f27a5ccc000-7f27a5ccd000 rw-p 00000000 00:00 0 <br>7f27a5ccd000-7f27a80a2000 ---p 00000000 00:00 0 <br>7f27a80a2000-7f27a80a3000 rw-p 00000000 00:00 0 <br>7f27a80a3000-7f27a851c000 ---p 00000000 00:00 0 <br>7f27a851c000-7f27a851d000 rw-p 00000000 00:00 0 <br>7f27a851d000-7f27a859c000 ---p 00000000 00:00 0 <br>7f27a859c000-7f27a85fc000 rw-p 00000000 00:00 0 <br>7fff115fc000-7fff1161d000 rw-p 00000000 00:00 0                          [stack]<br>7fff1166e000-7fff11670000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br><br></code></pre></td></tr></table></figure>

<p>我们重点关注两行：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">c000000000-c000400000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>     <span class="hljs-comment">// &lt;--- a的地址: 0xc000010240</span><br><span class="hljs-number">00480000</span><span class="hljs-number">-0050</span>f000 r--p <span class="hljs-number">00080000</span> fd:<span class="hljs-number">00</span> <span class="hljs-number">50573659</span>  /tmp/<span class="hljs-keyword">go</span>-build4270767253/b001/exe/offset_1<br>	<span class="hljs-comment">// &lt;--- a.str的地址，权限是r--p，不可写。认真听课的小伙伴已经想到，该数据处于内存的Text Segment(代码段)，存储常量。</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>小贴士：权限：r-可读  w-可写  x-可执行  p-私有</p>
</blockquote>
<p>为了进一步验证指针的行为，我们再写一个非代码段的字符串来通过指针偏移读写内存：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestString_Case2</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<br>	a := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, rand.Uint32())  <span class="hljs-comment">// 构造一个随机字符串</span><br>	fmt.Println(a)<br><br>	p := (*reflect.StringHeader)(unsafe.Pointer(&amp;a)).Data  <span class="hljs-comment">// &lt;-- 拿出底层数组的头指针，这个指针指向真实存储string内存的内存地址</span><br><br>	p1 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p))<br>	fmt.Println(*p1)  <span class="hljs-comment">// &lt;-- 打印一下是不是第一个字符的ASCII码</span><br><br>	p2 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p+<span class="hljs-number">1</span>))<br>	fmt.Println(*p2)  <span class="hljs-comment">// &lt;-- 向后偏移一个字节</span><br><br>	*p2 = <span class="hljs-number">88</span>  <span class="hljs-comment">// &lt;-- 把a的第二个字符修改为&#x27;X&#x27;</span><br>	fmt.Println(a)<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-number">2596996162</span><br><span class="hljs-number">50</span>   &lt;-- 字符<span class="hljs-number">2</span>的ASCII码<br><span class="hljs-number">53</span>   &lt;-- 字符<span class="hljs-number">5</span>的ASCII码<br><span class="hljs-number">2</span>X96996162<br></code></pre></td></tr></table></figure>

<p>字符串a的值从 2596996162 变为  2X96996162，验证了string底层的实现，也验证了指针对内存的操作行为。</p>
<h4 id="4-3-2-读写结构体私有变量"><a href="#4-3-2-读写结构体私有变量" class="headerlink" title="4.3.2 读写结构体私有变量"></a>4.3.2 读写结构体私有变量</h4><p>share&#x2F;ptr&#x2F;ptr_offset&#x2F;ptr_offset.go 文件，构造一个私有变量c。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PtrOffsetTest <span class="hljs-keyword">struct</span> &#123;<br>	A <span class="hljs-type">string</span><br>	B <span class="hljs-type">int8</span><br>	c <span class="hljs-type">int64</span>  <span class="hljs-comment">// &lt;-- 注意这个c是小写的（私有变量）</span><br>	D <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">int8</span>, c <span class="hljs-type">int64</span>, d <span class="hljs-type">string</span>)</span></span> *PtrOffsetTest &#123;<br>	<span class="hljs-keyword">return</span> &amp;PtrOffsetTest&#123;<br>		A: a,<br>		B: b,<br>		c: c,<br>		D: d,<br>	&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>share&#x2F;ptr&#x2F;ptr_test.go 文件，利用指针偏移方式，修改私有变量c的值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrOffsetModifyMem</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>	testPtr := ptr_offset.New(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;678&quot;</span>)<br>	fmt.Println(testPtr)<br><br>	<span class="hljs-keyword">var</span> tmp <span class="hljs-type">uint32</span> = <span class="hljs-number">10000</span><br><br>	<span class="hljs-comment">// testPtr.c  // 正常情况下testPtr.c是ptr_offset包的私有变量，外部包不可访问</span><br>	unsafePtr := unsafe.Pointer(testPtr) <span class="hljs-comment">// 转为unsafe.Pointer，但unsafe.Pointer不能做运算，因此转为uintptr</span><br>	uintPtr := <span class="hljs-type">uintptr</span>(unsafePtr)<br><br>	<span class="hljs-comment">// 因为存在结构体字节对齐问题，因此我们已知结构体中最大系数应该是string类型，获取string类型系数</span><br>	x := unsafe.Alignof(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;&quot;</span>))<br>	fmt.Println(x)  <span class="hljs-comment">// 得到对齐系数是8，意味着结构体内size &lt; 8的变量都按8个字节对齐</span><br><br>	<span class="hljs-keyword">var</span> bSize = unsafe.Sizeof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>))<br>	<span class="hljs-keyword">if</span> x &gt; bSize &#123;<br>		bSize = x <span class="hljs-comment">// int8是1个字节，向8字节对齐</span><br>	&#125;<br><br>	p := (*<span class="hljs-type">uint32</span>)(unsafe.Pointer(uintPtr + unsafe.Sizeof(testPtr.A) + bSize)) <span class="hljs-comment">// 指针偏移到testPtr.c变量的起始地址</span><br>	*p = tmp<br><br>	fmt.Println(testPtr)<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5-reflect-Ptr"><a href="#5-reflect-Ptr" class="headerlink" title="5. reflect.Ptr"></a>5. reflect.Ptr</h2><p>反射包中，也有指针类型</p>
<p>举一个典型的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个mysql表model</span><br><span class="hljs-keyword">type</span> XXXXModel <span class="hljs-keyword">struct</span> &#123;<br>	.....<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetXX</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">uint</span>)</span></span> (*XXXXModel, <span class="hljs-type">error</span>) &#123;<br>	db := GetDB(YiShouERP)  <span class="hljs-comment">// 获取一个gorm.DB指针</span><br>	<span class="hljs-keyword">var</span> info *XXXXModel<br>    err := db.WithContext(ctx).First(&amp;info)  <span class="hljs-comment">// &lt;--传递info的地址给interface&#123;&#125;</span><br>	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>	&#125;<br>	<span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>为什么能正常？info变量不是nil吗？为啥不panic呢？</p>
<p>哦豁，有没有想起方法内可以通过二级指针改变一级指针的指向？</p>
<p>那必然是First()内部做了申请内存的工作~我们来看看</p>
<p>摘自 gorm.io\<a href="mailto:&#x67;&#111;&#x72;&#x6d;&#x40;&#x76;&#x31;&#46;&#50;&#49;&#x2e;&#56;">&#x67;&#111;&#x72;&#x6d;&#x40;&#x76;&#x31;&#46;&#50;&#49;&#x2e;&#56;</a>\callbacks.go：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *processor)</span></span> Execute(db *DB) &#123;<br>    ......<br>    ......<br>    <span class="hljs-comment">// assign stmt.ReflectValue</span><br>	<span class="hljs-keyword">if</span> stmt.Dest != <span class="hljs-literal">nil</span> &#123;<br>		stmt.ReflectValue = reflect.ValueOf(stmt.Dest)<br>		<span class="hljs-keyword">for</span> stmt.ReflectValue.Kind() == reflect.Ptr &#123;  <span class="hljs-comment">// 1</span><br>			<span class="hljs-keyword">if</span> stmt.ReflectValue.IsNil() &amp;&amp; stmt.ReflectValue.CanAddr() &#123;  <span class="hljs-comment">// 2</span><br>				stmt.ReflectValue.Set(reflect.New(stmt.ReflectValue.Type().Elem()))  <span class="hljs-comment">// 3</span><br>			&#125;<br><br>			stmt.ReflectValue = stmt.ReflectValue.Elem()<br>		&#125;<br>		<span class="hljs-keyword">if</span> !stmt.ReflectValue.IsValid() &#123;<br>			db.AddError(ErrInvalidValue)<br>		&#125;<br>	&#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们一步步来拆解：</p>
<ol>
<li><strong>.Kind()</strong> 取得变量的反射类型，并且识别类型是否为<strong>reflect.Ptr</strong></li>
<li><strong>.IsNil()</strong> 判断指针是否指向<strong>nil</strong>，并且通过**.CanAddr()**判断变量地址是否可访问<ol>
<li>这里有一个另外的知识点，私有变量(结构体中小写开头的变量)，变量地址不可访问</li>
<li>可访问地址的变量，才可以修改地址指向；</li>
</ol>
</li>
<li>通过**.Type().Elem()<strong>取得变量的元信息，传递到</strong>reflect.New()**，用于在内部申请对应数据类型的内存空间</li>
</ol>
<p>再继续看 <strong>reflect.New()</strong> 内部实现</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New returns a Value representing a pointer to a new zero value</span><br><span class="hljs-comment">// for the specified type. That is, the returned Value&#x27;s Type is PtrTo(typ).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(typ Type)</span></span> Value &#123;<br>    <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;reflect: New(nil)&quot;</span>)<br>    &#125;<br>    t := typ.(*rtype)<br>    ptr := unsafe_New(t)<br>    fl := flag(Ptr)<br>    <span class="hljs-keyword">return</span> Value&#123;t.ptrTo(), ptr, fl&#125;<br>&#125;<br><br><span class="hljs-comment">// implemented in package runtime</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unsafe_New</span><span class="hljs-params">(*rtype)</span></span> unsafe.Pointer<br></code></pre></td></tr></table></figure>

<p>通过 **.(<em>rtype)</em>* 获得了原始数据类型，使用 <strong>unsafe_New()</strong> 分配 (*rtype) 所需的内存空间。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a target="_blank" rel="noopener" href="https://www.golang-book.com/books/intro/8#section1">https://www.golang-book.com/books/intro/8#section1</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redis/redis">https://github.com/redis/redis</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/go-gorm/gorm">https://github.com/go-gorm/gorm</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection">https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/golang101/golang101">https://github.com/golang101/golang101</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/clover-toeic/p/3754433.html">https://www.cnblogs.com/clover-toeic/p/3754433.html</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/golang/" class="category-chain-item">golang</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/golang/">#golang</a>
      
        <a href="/tags/%E6%8C%87%E9%92%88/">#指针</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Golang-指针</div>
      <div>https://lamber92.github.io/2021/08/02/golang/pointer/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Lamber Chen</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年8月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/4.0/">
                  <span class="hint--top hint--rounded" aria-label="ND - 禁止演绎">
                    <i class="iconfont icon-nd"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/05/golang/project_ants/" title="开源项目-Ants-学习记录">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">开源项目-Ants-学习记录</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        pv: 
        <span id="leancloud-site-pv"></span>
         
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        uv: 
        <span id="leancloud-site-uv"></span>
        
      </span>
    
    

  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
