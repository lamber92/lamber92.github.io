<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Windows下Docker-Desktop使用笔记</title>
    <link href="/2024/01/30/docker/win_docker/"/>
    <url>/2024/01/30/docker/win_docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows下Docker-Desktop使用笔记"><a href="#Windows下Docker-Desktop使用笔记" class="headerlink" title="Windows下Docker-Desktop使用笔记"></a>Windows下Docker-Desktop使用笔记</h1><p align="right">Lamber</p><p align="right">2024-01-30</p><h2 id="1-vm-max-map-count"><a href="#1-vm-max-map-count" class="headerlink" title="1. vm.max_map_count"></a>1. vm.max_map_count</h2><ul><li><p>按运行sonarqube官方镜像时出现这个报错：</p><p><img src="vm_max_map_count.png"></p></li><li><p>字面意思是vm.max_map_count配置值过低，下面是修改步骤：</p><ul><li><p>查看docker-desktop目前依赖的虚拟机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl.exe -l --all<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">得到如下信息</span><br>适用于 Linux 的 Windows 子系统分发版:<br>docker-desktop<br></code></pre></td></tr></table></figure></li><li><p>进入到名为docker-desktop的虚拟机中修改vm配置(其他命令可以查 wls.exe –help)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">wsl -d docker-desktop<br></code></pre></td></tr></table></figure></li><li><p>修改配置值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sysctl -w vm.max_map_count=262144<br></code></pre></td></tr></table></figure></li><li><p>退出虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">exit<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker-desktop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源项目-GORM-使用记录</title>
    <link href="/2023/12/23/golang/project_gorm/"/>
    <url>/2023/12/23/golang/project_gorm/</url>
    
    <content type="html"><![CDATA[<h1 id="开源项目-GORM-使用记录"><a href="#开源项目-GORM-使用记录" class="headerlink" title="开源项目-GORM-使用记录"></a>开源项目-GORM-使用记录</h1><p align="right">Lamber</p><p align="right">2023-12-23</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要记录一些开发过程中遇到使用GORM操作MySQL的需求及其实现方案。</p><p>本篇使用v1.22.2版本gorm阐述。</p><p>dbresolver的原理浅析记录在第1小节，对后面小节功能实现的理解有帮助。</p><h2 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h2><ul><li><p><strong>需求背景：</strong></p><ul><li>MySQL主节点1个，从节点7个，需要在服务侧做读写分离，并随机到从节点读数据。</li></ul></li><li><p><strong>实现方案：</strong></p><ul><li>有现成的开源项目：<a href="https://github.com/go-gorm/dbresolver">https://github.com/go-gorm/dbresolver</a></li><li>这里使用的是v1.1.0的dbresolver</li></ul></li><li><p><strong>实现示例：</strong></p><ul><li><p>定义一个MySQL配置的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MysqlConf <span class="hljs-keyword">struct</span> &#123;<br>Source      <span class="hljs-type">string</span> <span class="hljs-comment">// 主节点DSN</span><br>Replicas    []<span class="hljs-type">string</span> <span class="hljs-comment">// 从节点DSN组</span><br>....<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置应用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterDBResolver</span><span class="hljs-params">(db *gorm.DB, conf *MysqlConf)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(conf.Replicas) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> (<br>sources  []gorm.Dialector<br>replicas []gorm.Dialector<br>)<br>sources = <span class="hljs-built_in">append</span>(sources, mysql.Open(conf.Source))<br>        <span class="hljs-keyword">for</span> _, dsn := <span class="hljs-keyword">range</span> conf.Replicas &#123;<br>            replicas = <span class="hljs-built_in">append</span>(replicas, mysql.Open(dsn))<br>        &#125;<br>resolver := dbresolver.Register(dbresolver.Config&#123;<br>Sources:  sources,<br>Replicas: replicas,<br><span class="hljs-comment">// 代理规则是随机</span><br>Policy: dbresolver.RandomPolicy&#123;&#125;,<br>&#125;)<br><span class="hljs-comment">// 注册读写分离解析器</span><br><span class="hljs-keyword">if</span> err := db.Use(resolver); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>实现原理：</strong></p><ul><li><p>整个包代码不多，逻辑很清晰，主要是基于GORM的插件扩展接口实现，以及GORM执行SQL前的丰富CallBack</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Plugin GORM plugin interface</span><br><span class="hljs-keyword">type</span> Plugin <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Initialize(*DB) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GORM提供的这套回调方法，可以让调用者精细地在每一种操作前后插入中间干预操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Create() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;create&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Query() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;query&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Update() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;update&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Delete() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;delete&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Row() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;row&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Raw() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;raw&quot;</span>]<br>&#125;<br>......<br></code></pre></td></tr></table></figure></li><li><p>在解析器的包实现里，可以看到有对应实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gorm:db_resolver&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> Initialize(db *gorm.DB) <span class="hljs-type">error</span> &#123;<br>dr.DB = db<br>dr.registerCallbacks(db)<br><span class="hljs-keyword">return</span> dr.compile()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里可以追踪到 gorm.Plugin.Initialize() 的两处触发调用位置：</p><ul><li><p>gorm.Open() &lt;– 适用于建立MySQL连接前确定插件列表；</p></li><li><p>gorm.DB.Use() &lt;– 上面例子是使用了这种方法，适用于在得到MySQL连接后，再追加加载插件。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db *DB)</span></span> Use(plugin Plugin) <span class="hljs-type">error</span> &#123;<br>name := plugin.Name()<br><span class="hljs-keyword">if</span> _, ok := db.Plugins[name]; ok &#123;<br><span class="hljs-keyword">return</span> ErrRegistered<br>&#125;<br><span class="hljs-keyword">if</span> err := plugin.Initialize(db); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>db.Plugins[name] = plugin<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后看dbresolver.DBResolver的registerCallbacks这个方法的处理方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 重点在于这个方法，将SQL操作区分出Write与Read，给Read操作区分DB.Connector做铺垫。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> registerCallbacks(db *gorm.DB) &#123;<br>dr.Callback().Create().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchSource)<br>dr.Callback().Query().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchReplica)<br>dr.Callback().Update().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchSource)<br>dr.Callback().Delete().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchSource)<br>dr.Callback().Row().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchReplica)<br>dr.Callback().Raw().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchGuess)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> switchSource(db *gorm.DB) &#123;<br>    <span class="hljs-comment">// 非事务操作才走解析器，下同，不赘述。</span><br><span class="hljs-keyword">if</span> !isTransaction(db.Statement.ConnPool) &#123;<br>        <span class="hljs-comment">// 通过解析器，选择SQL执行的连接池，下同，不赘述。</span><br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> switchReplica(db *gorm.DB) &#123;<br><span class="hljs-keyword">if</span> !isTransaction(db.Statement.ConnPool) &#123;<br><span class="hljs-keyword">if</span> rawSQL := db.Statement.SQL.String(); <span class="hljs-built_in">len</span>(rawSQL) &gt; <span class="hljs-number">0</span> &#123;<br>dr.switchGuess(db)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这个&quot;FOR&quot;是默认query事件默认携带的</span><br>_, locking := db.Statement.Clauses[<span class="hljs-string">&quot;FOR&quot;</span>]<br>            <span class="hljs-comment">// 这里区分除了Write和Read，从而解析出不同的DB连接。</span><br>            <span class="hljs-comment">// 这里注意这个&quot;writeName&quot;标识，这个&quot;标识&quot;使得可以在业务侧修改Clauses的值，让查询强制走主节点，使用场景请看下文；下同，不赘述。</span><br><span class="hljs-keyword">if</span> _, ok := db.Statement.Clauses[writeName]; ok || locking &#123;<br>                <span class="hljs-comment">// 这里走到dr.resolve()方法，这个方法给用户提供了更高的扩展性，下文详细分析。</span><br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Read)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> switchGuess(db *gorm.DB) &#123;<br><span class="hljs-keyword">if</span> !isTransaction(db.Statement.ConnPool) &#123;<br><span class="hljs-keyword">if</span> _, ok := db.Statement.Clauses[writeName]; ok &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> rawSQL := strings.TrimSpace(db.Statement.SQL.String()); <span class="hljs-built_in">len</span>(rawSQL) &gt; <span class="hljs-number">10</span> &amp;&amp; strings.EqualFold(rawSQL[:<span class="hljs-number">6</span>], <span class="hljs-string">&quot;select&quot;</span>) &amp;&amp; !strings.EqualFold(rawSQL[<span class="hljs-built_in">len</span>(rawSQL)<span class="hljs-number">-10</span>:], <span class="hljs-string">&quot;for update&quot;</span>) &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Read)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isTransaction</span><span class="hljs-params">(connPool gorm.ConnPool)</span></span> <span class="hljs-type">bool</span> &#123;<br>_, ok := connPool.(gorm.TxCommitter)<br><span class="hljs-keyword">return</span> ok<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再往里看，dbresolver.DBResolver 的 resolve() 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> resolve(stmt *gorm.Statement, op Operation) gorm.ConnPool &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dr.resolvers) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 这个特别注意usingName，这个标识是dbresolver的关键扩展项。</span><br><span class="hljs-keyword">if</span> u, ok := stmt.Clauses[usingName].Expression.(using); ok &amp;&amp; u.Use != <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// u.Use是usingName的动作，用于在解析器组中查找是否存在指定的解析器(标识这个特殊逻辑为[1])</span><br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[u.Use]; ok &#123;<br>                <span class="hljs-comment">// 无一例外都会走到resolve这个方法</span><br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> stmt.Table != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[stmt.Table]; ok &#123;<br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> stmt.Schema != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[stmt.Schema.Table]; ok &#123;<br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> rawSQL := stmt.SQL.String(); rawSQL != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[getTableFromRawSQL(rawSQL)]; ok &#123;<br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> dr.global != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> dr.global.resolve(stmt, op)<br>&#125;<br><br><span class="hljs-keyword">return</span> stmt.ConnPool<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后会走到 dbresolver.resolver.resolve() 方法，选择之前创建好的主从连接。至此，读写分离的主流程就走完了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *resolver)</span></span> resolve(stmt *gorm.Statement, op Operation) (connPool gorm.ConnPool) &#123;<br><span class="hljs-keyword">if</span> op == Read &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.replicas) == <span class="hljs-number">1</span> &#123;<br>connPool = r.replicas[<span class="hljs-number">0</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>connPool = r.policy.Resolve(r.replicas)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.sources) == <span class="hljs-number">1</span> &#123;<br>connPool = r.sources[<span class="hljs-number">0</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>connPool = r.policy.Resolve(r.sources)<br>&#125;<br><br><span class="hljs-keyword">if</span> stmt.DB.PrepareStmt &#123;<br><span class="hljs-keyword">if</span> preparedStmt, ok := r.dbResolver.prepareStmtStore[connPool]; ok &#123;<br><span class="hljs-keyword">return</span> &amp;gorm.PreparedStmtDB&#123;<br>ConnPool: connPool,<br>Mux:      preparedStmt.Mux,<br>Stmts:    preparedStmt.Stmts,<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>这里延伸出一个问题，如果要求实时性很高，要强制查主节点，使用dbresolver会影响吗？</strong></p><ul><li><p>dbresolver和gorm提供了强制查主节点的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Clauses(dbresolver.Write)<br></code></pre></td></tr></table></figure></li><li><p>看看这个Clauses()方法做了什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Clauses Add clauses</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db *DB)</span></span> Clauses(conds ...clause.Expression) (tx *DB) &#123;<br>tx = db.getInstance()<br><span class="hljs-keyword">var</span> whereConds []<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">for</span> _, cond := <span class="hljs-keyword">range</span> conds &#123;<br>        <span class="hljs-comment">// 这里看cond是否是clause.Interface的实现，如果是则调AddClause()</span><br><span class="hljs-keyword">if</span> c, ok := cond.(clause.Interface); ok &#123;<br>tx.Statement.AddClause(c)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> optimizer, ok := cond.(StatementModifier); ok &#123;<br>optimizer.ModifyStatement(tx.Statement)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>whereConds = <span class="hljs-built_in">append</span>(whereConds, cond)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(whereConds) &gt; <span class="hljs-number">0</span> &#123;<br>tx.Statement.AddClause(clause.Where&#123;Exprs: tx.Statement.BuildCondition(whereConds[<span class="hljs-number">0</span>], whereConds[<span class="hljs-number">1</span>:]...)&#125;)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>看gorm.AddClause()方法做了什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// AddClause add clause</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stmt *Statement)</span></span> AddClause(v clause.Interface) &#123;<br><span class="hljs-keyword">if</span> optimizer, ok := v.(StatementModifier); ok &#123;<br>optimizer.ModifyStatement(stmt)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 会调用Name()方法，得到一个标识，并存入stmt.Clauses。</span><br>        <span class="hljs-comment">// 这里很容易联系到上文中 db.Statement.Clauses[writeName] 走Write节点的逻辑。继续往下追查确实如此。</span><br>name := v.Name()<br>c := stmt.Clauses[name]<br>c.Name = name<br>v.MergeClause(&amp;c)<br>stmt.Clauses[name] = c<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来看dbresolver如何实现clause.Interface，证实了上文的猜想。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Write Operation = <span class="hljs-string">&quot;write&quot;</span><br>Read  Operation = <span class="hljs-string">&quot;read&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Operation <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> writeName = <span class="hljs-string">&quot;gorm:db_resolver:write&quot;</span><br><br><span class="hljs-comment">// 实现了clause.Interface.Name()，这样就把&quot;writeName&quot;设置进了db.Statement.Clauses，</span><br><span class="hljs-comment">// 也就让dbresolver在执行 switchReplica() 时走了Write的分支逻辑，即在主节点查询。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(op Operation)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> op == Write &#123;<br><span class="hljs-keyword">return</span> writeName<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gorm:db_resolver:read&quot;</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(op Operation)</span></span> Build(clause.Builder) &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(op Operation)</span></span> MergeClause(*clause.Clause) &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-指定使用某DB节点"><a href="#2-指定使用某DB节点" class="headerlink" title="2. 指定使用某DB节点"></a>2. 指定使用某DB节点</h2><ul><li><p><strong>需求背景：</strong></p><ul><li>在7个从节点中，有其中4个节点配置较高，另外3个节点配置较低；<ul><li>配置较高的节点提供APP访问用，配置较低的节点用于后台系统查询，因此后台业务需要指定使用这3个节点进行读取。</li><li>而我们的业务代码中，有部分Model层方法是后台与APP逻辑共用的；且在分布式系统中，部分gRPC接口是后台与APP逻辑共用的；因此需要考虑改动量最低的方案，并尽量让业务层无感知。</li></ul></li></ul></li><li><p><strong>实现方案：</strong></p><ul><li><p><strong>有两种方式，第一种是使用gorm.DB.AddClause()方法显式指定MySQL执行节点</strong></p></li><li><p>在上一小点记录了如何强制使用主节点，以及在dbresolver.DBResolver 的 <strong>resolve()</strong> 方法中，会优先判断 <strong>gorm.Statement.Clause</strong> 是否有<strong>usingName</strong>，从而继续查找指定的 <strong>dbresolver.resolver</strong> 可以利用这点来实现对MySQL节点的选择。</p></li><li><p>先在配置中添加一套指定的Source与Replicas，并注册到resolver：</p><ul><li>这里其实就是把需要独立访问的3个节点拆分出来，单独与主节点形成一套新的配置，并以specifyNodeName命名。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">resolver = resolver.Register(dbresolver.Config&#123;<br>    Sources:  sources,<br>    Replicas: spReplicas,<br>    Policy:   dbresolver.RandomPolicy&#123;&#125;,<br>&#125;, SpecifyNodeName) <span class="hljs-comment">// 注意，这里的变量值需要与下文调用DB.AddClause()显示切换节点的变量值一致。</span><br></code></pre></td></tr></table></figure><ul><li><p>有兴趣可以追查到这个<strong>SpecifyNodeName变量</strong>最终会记录到 <strong>dbresolver.DBResolver.resolvers</strong> 中，因此可以走到标识逻辑[i]中，从而找到对应的解析器(存有指定MySQL节点的连接池)</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> compileConfig(config Config) (err <span class="hljs-type">error</span>) &#123;<br>......<br><span class="hljs-comment">// 注意这一段代码</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(config.datas) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> _, data := <span class="hljs-keyword">range</span> config.datas &#123;<br><span class="hljs-keyword">if</span> t, ok := data.(<span class="hljs-type">string</span>); ok &#123;<br>dr.resolvers[t] = &amp;r<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stmt := &amp;gorm.Statement&#123;DB: dr.DB&#125;<br><span class="hljs-keyword">if</span> err := stmt.Parse(data); err == <span class="hljs-literal">nil</span> &#123;<br>dr.resolvers[stmt.Table] = &amp;r<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br>&#125; ......<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在业务逻辑中，只需要在gorm.DB的调用链中加入以下代码即可实现显式选择MySQL执行节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.AddClause(dbresolver.Use(SpecifyNodeName)<br></code></pre></td></tr></table></figure></li><li><p><strong>第二种方式，是作用于整条逻辑链路上的所有SQL语句</strong></p></li><li><p>这种方式，依赖于go语言编码过程中核心参数：Context；在具备良好编程风格的代码中，gorm.DB.WithContext()自然是必不可少的。</p></li><li><p>实现方式是基于第一种方式的原理上，把AddClause放到gorm的Callback()方法中处理，这样业务层就不需要做任何改动了。</p><ul><li>需要注意的是，Before(“*”)，因为节点的选择应该是优先级最高的；并且注册逻辑在gorm.DB.Use(resolver)前，即与dbresolver的原始注册逻辑同时加载到gorm的插件组中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterQuerySpecifyNode</span><span class="hljs-params">(db *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> db.Callback().Query().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:specify-node&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br>        node := db.Statement.Context.Value(<span class="hljs-string">&quot;specify_node_key&quot;</span>)<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            db.Statement.AddClause(dbresolver.Use(node.String()))<br>        &#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在链路的起始位置对ctx加入”specify_node_key”的kv，例如插入点在http接口请求中间件中，即可实现逻辑链路中对SQL执行读操作节点的控制。</p><ul><li>这里的ctx可以是二次封装的Context结构对象，这又是另一个话题，这里不详细说明了，只使用go方法提供的<strong>valueCtx</strong>对象举例。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx = context.WithValue(ctx, <span class="hljs-string">&quot;specify_node_key&quot;</span>, <span class="hljs-string">&quot;specify_node&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>这里可以延伸一下，在分布式gRPC调用链中，也可以通过Context控制下游服务指定MySQL节点，这种方式是go的基操，不多说。</p></li></ul></li></ul><h2 id="3-限制某些表不能执行Delete操作"><a href="#3-限制某些表不能执行Delete操作" class="headerlink" title="3. 限制某些表不能执行Delete操作"></a>3. 限制某些表不能执行Delete操作</h2><ul><li><p><strong>需求背景：</strong></p><ul><li>业务中需要大量的热数据表，而热数据表与原数据表命名类似，热数据表只保留某时间段内的数据，而原表则有全量数据且基本只有软删。为了防止误删数据，需要在代码层面先限制某些表不能执行Delete操作，将原数据表保护起来。</li><li>虽然在生产和UAT环境中，运维层面也对MySQL账号做了限制，但代码层面也做防范能更精细地做控制，也减少沟通成本。</li></ul></li><li><p><strong>实现方案：</strong></p><ul><li><p>利用gorm.DB.Callback中，Delete操作的前置操作做拦截。</p><ul><li>这里做一步优化，为了减少业务层面的改动，以及避免对现有逻辑的改动，使用接口类型判断实现比较合理。</li><li>先声明一个控制表可删除数据的接口”RestrictedTableDeleter”，再声明一个”CanDelete”方法，那么现有的表Model就可以通过实现这个接口方法让gorm在Callback中轻松判断是否该表的Delete操作被限制。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RestrictedTableDeleter 接口定义</span><br><span class="hljs-keyword">type</span> RestrictedTableDeleter <span class="hljs-keyword">interface</span> &#123;<br>CanDelete() <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// UserModel 用户表模型</span><br><span class="hljs-keyword">type</span> UserModel <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 实现 RestrictedTableDeleter 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserModel)</span></span> CanDelete() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 在这里实现逻辑，判断是否允许删除数据</span><br><span class="hljs-comment">// 这个例子中简单地返回 true，表示允许删除</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在gorm实例初始化后，注册Delete操作的前置行为，判断Model是否包含CanDelete方法与该方法的返回值，拦截误删操作。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注册 BeforeDelete 钩子，限制只有满足条件的数据可以删除</span><br>db.Callback().Delete().Before(<span class="hljs-string">&quot;gorm:before_delete&quot;</span>).Register(<span class="hljs-string">&quot;gorm:check-delete-allowed&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br>    <span class="hljs-comment">// 获取删除的模型</span><br>    model := db.Statement.Model<br>    <span class="hljs-comment">// 判断是否为实现了 RestrictedTableDeleter 接口的模型</span><br>    <span class="hljs-keyword">if</span> deleter, ok := model.(RestrictedTableDeleter); ok &#123;<br>        <span class="hljs-comment">// 调用 CanDelete 方法判断是否允许删除</span><br>        <span class="hljs-keyword">if</span> deleter.CanDelete() &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Delete operation is allowed for this data.&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Delete operation is not allowed for this data.&quot;</span>)<br>            db.AddError(fmt.Errorf(<span class="hljs-string">&quot;delete operation is not allowed for this data&quot;</span>))<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源项目-Agollo-学习与魔改记录</title>
    <link href="/2023/08/03/golang/project_agollo/"/>
    <url>/2023/08/03/golang/project_agollo/</url>
    
    <content type="html"><![CDATA[<h1 id="开源项目-Agollo-学习与魔改记录"><a href="#开源项目-Agollo-学习与魔改记录" class="headerlink" title="开源项目-Agollo-学习与魔改记录"></a>开源项目-Agollo-学习与魔改记录</h1><p align="right">Lamber</p><p align="right">2023-08-03</p><p>​    </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇原意是记录 <a href="https://github.com/apolloconfig/agollo">apolloconfig&#x2F;agollo</a> v4.3.1学习心得。</p><p>试用后感觉有些用得不太舒服的地方，决定魔改一下它~</p><p>魔改后项目路径：<a href="https://github.com/lamber92/agollo">lamber92&#x2F;agollo</a></p><p>改动点：</p><ul><li>首次连接Apollo服务时检查IP地址、App秘钥合法性，并同步返回连接失败原因；</li><li>修改Log接口定义，使之与其他开源库Log库更加贴合；</li><li>修复请求失败后，因为触发重试机制导致body没有释放而可能导致短暂内存泄露的问题；</li><li>支持动态新增指定namespace配置缓存，并自动监听对应namespace配置变动；<ul><li>改写 GetConfigAndInit() 方法</li><li>改写 notify 包逻辑</li></ul></li><li>优化针对请求 notifications&#x2F;v2&#x2F; 接口因为系统架构中存在中间网络组件导致返回http-status-code&#x3D;401时的处理方式（<a href="https://github.com/apolloconfig/apollo/issues/3652">#3652</a>）；</li><li>增加3个常用错误，方便业务层面处理；</li><li>修改部分变量名称及注释，使之更贴合实际意义；</li></ul><p>​    </p><h3 id="Agollo启动的大致流程"><a href="#Agollo启动的大致流程" class="headerlink" title="Agollo启动的大致流程"></a>Agollo启动的大致流程</h3><p><img src="start.png"></p><h2 id="1-检验Secret合法性"><a href="#1-检验Secret合法性" class="headerlink" title="1. 检验Secret合法性"></a>1. 检验Secret合法性</h2><h3 id="1-1-现象"><a href="#1-1-现象" class="headerlink" title="1.1. 现象"></a>1.1. 现象</h3><p>使用原版客户端，填写<strong>错误的secret</strong>，比如我使用README中的示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Apollo:</span><br>  <span class="hljs-attr">IP:</span> <span class="hljs-string">&quot;http://apollo-configservice-dev.example.com&quot;</span><br>  <span class="hljs-attr">AppID:</span> <span class="hljs-string">&quot;example-app-id&quot;</span><br>  <span class="hljs-attr">Cluster:</span> <span class="hljs-string">&quot;dev1&quot;</span><br>  <span class="hljs-attr">NamespaceName:</span> <span class="hljs-string">&quot;application&quot;</span><br>  <span class="hljs-attr">IsBackupConfig:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">Secret:</span> <span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br></code></pre></td></tr></table></figure><p>​    </p><p>日志的内容非常具有迷惑性，会输出 <strong>“agollo start finished ! “</strong> 日志，让我误以为配置一切正常；</p><p>当尝试使用 <strong>Load()</strong> 方法读取远程配置时，会因为获取配置缓存失败而报错；</p><p>如果在生产环境中填错了secret，是十分危险的，应该在初始化时就把配置异常暴露出来，避免执行业务逻辑时才感知异常；</p><p>​    </p><h3 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2. 分析"></a>1.2. 分析</h3><p>先说根本原因：</p><p>在调用 <strong>StartWithConfig()</strong> 方法时，<strong>AppConfig.MustStart</strong>参数没有置为<strong>True</strong>，最终没有校验secret的有效性~~！</p><p>​    </p><p>来看下原库v4.3.1代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartWithConfig</span><span class="hljs-params">(loadAppConfig <span class="hljs-keyword">func</span>()</span></span> (*config.AppConfig, <span class="hljs-type">error</span>)) (Client, <span class="hljs-type">error</span>) &#123;<br>......<br><br>serverlist.InitSyncServerIPList(c.getAppConfig) <span class="hljs-comment">// &lt;---初始化时需要请求Apollo服务的两处</span><br><br><span class="hljs-comment">//first sync</span><br>configs := syncApolloConfig.Sync(c.getAppConfig) <span class="hljs-comment">// &lt;---初始化时需要请求Apollo服务的两处</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(configs) == <span class="hljs-number">0</span> &amp;&amp; appConfig != <span class="hljs-literal">nil</span> &amp;&amp; appConfig.MustStart &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;start failed cause no config was read&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, apolloConfig := <span class="hljs-keyword">range</span> configs &#123;<br>c.cache.UpdateApolloConfig(apolloConfig, c.getAppConfig)<br>&#125;<br><br>log.Debug(<span class="hljs-string">&quot;init notifySyncConfigServices finished&quot;</span>)<br><br>......<br><br>log.Info(<span class="hljs-string">&quot;agollo start finished ! &quot;</span>)<br><br><span class="hljs-keyword">return</span> c, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这个方法内很少去处理内部错误，并将错误返回到调用方，而是直接将err<strong>吞掉</strong>了，导致业务侧无法获得apollo-client真正初始化成功的依据；</p><p>​    </p><p>从命名上看，下面两个方法似乎比较关键~</p><p><strong>serverlist.InitSyncServerIPList(c.getAppConfig)</strong> </p><p><strong>syncApolloConfig.Sync(c.getAppConfig)</strong></p><p>​    </p><p>先看 <strong>serverlist.InitSyncServerIPList(c.getAppConfig)</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//InitSyncServerIPList 初始化同步服务器信息列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitSyncServerIPList</span><span class="hljs-params">(appConfig <span class="hljs-keyword">func</span>()</span></span> config.AppConfig) &#123;<br><span class="hljs-keyword">go</span> component.StartRefreshConfig(&amp;SyncServerIPListComponent&#123;appConfig&#125;)<br>&#125;<br><br><span class="hljs-comment">//SyncServerIPListComponent set timer for update ip list</span><br><span class="hljs-comment">//interval : 20m</span><br><span class="hljs-keyword">type</span> SyncServerIPListComponent <span class="hljs-keyword">struct</span> &#123;<br>appConfig <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，这是一个异步任务，再往里看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> component<br><br><span class="hljs-comment">//AbsComponent 定时组件</span><br><span class="hljs-keyword">type</span> AbsComponent <span class="hljs-keyword">interface</span> &#123;<br>Start()<br>&#125;<br><br><span class="hljs-comment">//StartRefreshConfig 开始定时服务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartRefreshConfig</span><span class="hljs-params">(component AbsComponent)</span></span> &#123;<br>component.Start()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个定时组件接口，内部调用 <strong>Start()</strong> 方法，那么联系上下文，就是调用了 <strong>SyncServerIPListComponent</strong> 对象的 <strong>Start()</strong> 方法</p><p>继续看后面的逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Start 启动同步服务器列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SyncServerIPListComponent)</span></span> Start() &#123;<br>SyncServerIPList(s.appConfig)<br>log.Debug(<span class="hljs-string">&quot;syncServerIpList started&quot;</span>)<br><br>t2 := time.NewTimer(refreshIPListInterval)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t2.C:<br>SyncServerIPList(s.appConfig)<br>t2.Reset(refreshIPListInterval)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//SyncServerIPList sync ip list from server</span><br><span class="hljs-comment">//then</span><br><span class="hljs-comment">//1.update agcache</span><br><span class="hljs-comment">//2.store in disk</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SyncServerIPList</span><span class="hljs-params">(appConfigFunc <span class="hljs-keyword">func</span>()</span></span> config.AppConfig) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*config.ServerInfo, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> appConfigFunc == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;can not find apollo config!please confirm!&quot;</span>)<br>&#125;<br>......<br>    <br>serverMap, err := http.Request(appConfig.GetServicesConfigURL(), c, &amp;http.CallBack&#123;<br>SuccessCallBack: SyncServerIPListSuccessCallBack,<br>AppConfigFunc:   appConfigFunc,<br>&#125;)<br>    <br>......<br><br>m := serverMap.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*config.ServerInfo)<br>server.SetServers(appConfig.GetHost(), m)  <span class="hljs-comment">// &lt;--注意：将Apollo返回的Meta-Service信息保存</span><br><span class="hljs-keyword">return</span> m, err<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//GetServicesConfigURL 获取服务器列表url</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AppConfig)</span></span> GetServicesConfigURL() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%sservices/config?appId=%s&amp;ip=%s&quot;</span>,<br>a.GetHost(),<br>url.QueryEscape(a.AppID),<br>utils.GetInternal())<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <strong>services&#x2F;config</strong> 接口，获取Apollo服务IP列表；</p><p>结合 <a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_12-%e6%9e%b6%e6%9e%84%e6%a8%a1%e5%9d%97">Apollo架构模块</a>，这部分的逻辑其实是获取<strong>Apollo-Meta-Service</strong>地址，结合Eureka注册发现，实现负载均衡；</p><p>但是这里有一个坑<a href="#1270">#1270</a>，会一直触发<strong>ERROR</strong>级别日志，使得使用者会误以为底层连接出现问题，其实逻辑上并不会对配置产生影响；</p><p>​    </p><p>再看<strong>syncApolloConfig.Sync(c.getAppConfig)</strong></p><p>即调用了 <strong>(*syncApolloConfig).Sync()</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *syncApolloConfig)</span></span> Sync(ctx context.Context, appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig) []*config.ApolloConfig &#123;<br>appConfig := appConfigFunc()<br>configs := <span class="hljs-built_in">make</span>([]*config.ApolloConfig, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)<br>config.SplitNamespaces(appConfig.NamespaceName, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>)</span></span> &#123;<br>apolloConfig := a.SyncWithNamespace(ctx, namespace, appConfigFunc) <span class="hljs-comment">// &lt;--注意看这里</span><br><span class="hljs-keyword">if</span> apolloConfig != <span class="hljs-literal">nil</span> &#123;<br>configs = <span class="hljs-built_in">append</span>(configs, apolloConfig)<br><span class="hljs-keyword">return</span><br>&#125;<br>configs = <span class="hljs-built_in">append</span>(configs, loadBackupConfig(appConfig.NamespaceName, appConfig)...)<br>&#125;)<br><span class="hljs-keyword">return</span> configs<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <strong>SyncWithNamespace()</strong> 方法中会调用 <a href="https://www.apolloconfig.com/#/zh/usage/other-language-client-user-guide?id=_12-%e9%80%9a%e8%bf%87%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84http%e6%8e%a5%e5%8f%a3%e4%bb%8eapollo%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae"><strong>configfiles&#x2F;json</strong></a> 接口获取远程配置，然后更新本地缓存。</p><p>这里看到了<strong>判断是否成功地获取远程配置的关键逻辑</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//first sync</span><br>configs := syncApolloConfig.Sync(c.getAppConfig)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(configs) == <span class="hljs-number">0</span> &amp;&amp; appConfig != <span class="hljs-literal">nil</span> &amp;&amp; appConfig.MustStart &#123;  <span class="hljs-comment">// &lt;--MustStart 配置参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;start failed cause no config was read&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, apolloConfig := <span class="hljs-keyword">range</span> configs &#123;<br>    c.cache.UpdateApolloConfig(apolloConfig, c.getAppConfig)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果填错了Secret，必然读不到远程配置；</p><p>而 <strong>RequestRecovery()</strong> 内部默认有5次重试，每次间隔2秒；</p><p>因此<strong>堵塞10秒</strong>后，会到达 <strong>len(configs) &#x3D;&#x3D; 0 &amp;&amp; appConfig !&#x3D; nil &amp;&amp; appConfig.MustStart</strong> 的判断逻辑；</p><p>又因为 <strong>appConfig.MustStart</strong> 默认值是<strong>false</strong>，会继续往下执行后续逻辑，此时就忽略了Secret错误导致配置没有读取成功的错误。</p><p>​    </p><p>如果将 <strong>MustStart</strong> 配置项填<strong>true</strong>，满足检测Secret合法性的需求；</p><p>但是还是需要等待10s才能消耗完底层请求的默认重试次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//AppConfig 配置文件</span><br><span class="hljs-keyword">type</span> AppConfig <span class="hljs-keyword">struct</span> &#123;<br>AppID             <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;appId&quot;`</span><br>Cluster           <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;cluster&quot;`</span><br>NamespaceName     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;namespaceName&quot;`</span><br>IP                <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;ip&quot;`</span><br>IsBackupConfig    <span class="hljs-type">bool</span>   <span class="hljs-string">`default:&quot;true&quot; json:&quot;isBackupConfig&quot;`</span><br>BackupConfigPath  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;backupConfigPath&quot;`</span><br>Secret            <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;secret&quot;`</span><br>Label             <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;label&quot;`</span><br>SyncServerTimeout <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;syncServerTimeout&quot;`</span><br><span class="hljs-comment">// MustStart 可用于控制第一次同步必须成功</span><br>MustStart               <span class="hljs-type">bool</span> <span class="hljs-string">`default:&quot;false&quot;`</span> <span class="hljs-comment">// &lt;-- 强制校验远程配置是否获取成功的开关</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><h3 id="1-3-魔改"><a href="#1-3-魔改" class="headerlink" title="1.3. 魔改"></a>1.3. 魔改</h3><p>因为apollo客户端作为重要的配置加载组件，在服务启动时尤为关键，应该尽快暴露首次连接失败的原因，及时排查问题；</p><p>因此想办法加上首次连接失败后马上抛出错误的机制；</p><p>变动项：</p><ul><li><strong>SyncServerIPList()</strong>  先同步执行一次，确保能够正常获取Meta-Service信息，保证IP配置正确；</li><li>利用 <a href="https://www.apolloconfig.com/#/zh/usage/other-language-client-user-guide?id=_12-%e9%80%9a%e8%bf%87%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84http%e6%8e%a5%e5%8f%a3%e4%bb%8eapollo%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae"><strong>configfiles&#x2F;json</strong></a> 需要secret的特性，在 <strong>SyncServerIPList()</strong> 执行成功后，同步地请求获取一次远程配置，保证secret配置正确；</li><li>上面两个步骤执行完成后，再启动异步定时更新 IPList 的任务；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InitSyncServerIPList 初始化同步服务器信息列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitSyncServerIPList</span><span class="hljs-params">(ctx context.Context, appConfig <span class="hljs-keyword">func</span>()</span></span> config.AppConfig) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// sync ip list once at first</span><br><span class="hljs-keyword">if</span> _, err := SyncServerIPList(ctx, appConfig); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>    <span class="hljs-comment">// check if the secret is valid</span><br><span class="hljs-keyword">if</span> err := CheckSecretOK(ctx, appConfig); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>    <span class="hljs-comment">// start scheduled tasks to async update ip list</span><br><span class="hljs-keyword">go</span> component.StartRefreshConfig(&amp;SyncServerIPListComponent&#123;<br>appConfig: appConfig,<br>stopCh:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>&#125;)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>CheckSecretOK()</strong> 直接调用 Request()，并判断response-http-status-code是否是 <strong>401</strong> ，是则直接返回错误；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res *http.Response<br>res, err = client.Do(req)<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">defer</span> res.Body.Close()<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> || err != <span class="hljs-literal">nil</span> &#123;<br>    log.Warnf(<span class="hljs-string">&quot;request failed. url: %s, err: %s&quot;</span>, requestURL, err)<br>    <span class="hljs-comment">// if error then sleep</span><br>    time.Sleep(onErrorRetryInterval)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, continueErr<br>&#125;<br><br><span class="hljs-comment">// not modified break</span><br><span class="hljs-keyword">switch</span> res.StatusCode &#123;<br>    <span class="hljs-keyword">case</span> http.StatusOK:<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusNotModified:<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusUnauthorized:<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusUnauthorized:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perror.ErrUnauthorized<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusNotFound:<br>        ......<br>    <span class="hljs-keyword">default</span>:<br>    log.Debugf(<span class="hljs-string">&quot;response return err. url: %s, http-status-code: %d&quot;</span>, requestURL, res.StatusCode)<br>    <span class="hljs-comment">// if error then sleep</span><br>    time.Sleep(onErrorRetryInterval)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, continueErr<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RequestRecovery 可以恢复的请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RequestRecovery</span><span class="hljs-params">(ctx context.Context,</span></span><br><span class="hljs-params"><span class="hljs-function">appConfig config.AppConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">connectConfig *env.ConnectConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">callBack *CallBack)</span></span> (response <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-keyword">for</span> &#123;<br>host := loadBalance(appConfig)<br><span class="hljs-keyword">if</span> host == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>requestURL := fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, host, connectConfig.URI)<br>response, err = Request(ctx, requestURL, connectConfig, callBack)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> response, <span class="hljs-literal">nil</span><br>&#125;<br><br>server.SetDownNode(appConfig.GetHost(), host)<br><br><span class="hljs-keyword">if</span> errors.Is(err, perror.ErrUnauthorized) ||<br>errors.Is(err, perror.ErrOverMaxRetryTimes) ||<br>errors.Is(err, perror.ErrNotFound) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><h2 id="2-短暂内存泄露"><a href="#2-短暂内存泄露" class="headerlink" title="2. 短暂内存泄露"></a>2. 短暂内存泄露</h2><h3 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1. 分析"></a>2.1. 分析</h3><p>在Request()方法中，在for的代码块直接使用defer；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Request 建立网络请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Request</span><span class="hljs-params">(requestURL <span class="hljs-type">string</span>, connectionConfig *env.ConnectConfig, callBack *CallBack)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>client := &amp;http.Client&#123;&#125;<br>......<br><span class="hljs-keyword">for</span> &#123;<br><br>retry++<br><br><span class="hljs-keyword">if</span> retry &gt; retries &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">var</span> req *http.Request<br>req, err = http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, requestURL, <span class="hljs-literal">nil</span>)<br>......<br><br><span class="hljs-keyword">var</span> res *http.Response<br>res, err = client.Do(req)<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">defer</span> res.Body.Close()  <span class="hljs-comment">// &lt;--在for代码块中使用defer</span><br>&#125;<br><br>......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这处如果遇到反复重试的极端情况，在重试次数达到上限时，res.Body的资源才被释放，中间过程会出现资源堆积；</p><h3 id="2-3-魔改"><a href="#2-3-魔改" class="headerlink" title="2.3. 魔改"></a>2.3. 魔改</h3><p>将 <strong>res, err &#x3D; client.Do(req)</strong> 的后续逻辑移动到一个func块中，在func块中使用defer，使res.Body能及时被回收。</p><p>​    </p><h2 id="3-长轮询接口返回401"><a href="#3-长轮询接口返回401" class="headerlink" title="3. 长轮询接口返回401"></a>3. 长轮询接口返回401</h2><h3 id="3-1-现象"><a href="#3-1-现象" class="headerlink" title="3.1. 现象"></a>3.1. 现象</h3><p>长轮询接口~60秒返回，并没有返回304，而返回了401；打印大量error日志；</p><p>​    </p><h3 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2. 分析"></a>3.2. 分析</h3><p><a href="#3652">#3652</a> 这个issue中已经列举了很多种情况，我遇到的情况与klboke这位老哥相同</p><p><img src="klboke.png"></p><p>但ingress的配置不是说改运维就会改呀~ </p><p>毕竟还牵扯到其他业务，所以决定魔改代码来兼容一下这种情况~</p><p>​    </p><h3 id="3-3-魔改"><a href="#3-3-魔改" class="headerlink" title="3.3. 魔改"></a>3.3. 魔改</h3><p>在http-status-code &#x3D; 401，且是长轮询接口请求时，也走304的逻辑；</p><p>尽管这不是优雅的实现，但为了尽量不过多改动核心逻辑，先以满足需求优先。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> http.StatusNotModified:<br>log.Debugf(<span class="hljs-string">&quot;config not modified, err: %v&quot;</span>, err)<br><span class="hljs-keyword">if</span> callBack != <span class="hljs-literal">nil</span> &amp;&amp; callBack.NotModifyCallBack != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, callBack.NotModifyCallBack()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> http.StatusUnauthorized:<br><span class="hljs-comment">// https://github.com/apolloconfig/apollo/issues/3652</span><br><span class="hljs-comment">// During the long polling process, if the client is not directly connected to ApolloService</span><br><span class="hljs-comment">// and passes through a gateway in the middle, it is likely to return http-status-code: 401.</span><br><span class="hljs-comment">// Because the request timeout time set by the gateway is shorter than the suspension time</span><br><span class="hljs-comment">// of apollo Notifications-API, the request is disconnected on the gateway side and retried.</span><br><span class="hljs-comment">// At this time, the request time has been refreshed and does not match the signature of the</span><br><span class="hljs-comment">// original request, which eventually causes apolloService to return 401.</span><br><span class="hljs-comment">// Although this is not an elegant way, it is safest to handle it here for the time being.</span><br><span class="hljs-keyword">if</span> strings.Contains(requestURL, <span class="hljs-string">&quot;notifications/v2&quot;</span>) &#123;<br>log.Debugf(<span class="hljs-string">&quot;config not modified, err: %v&quot;</span>, err)<br><span class="hljs-keyword">if</span> callBack != <span class="hljs-literal">nil</span> &amp;&amp; callBack.NotModifyCallBack != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, callBack.NotModifyCallBack()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perror.ErrUnauthorized<br><span class="hljs-keyword">case</span> http.StatusNotFound:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perror.ErrNotFound<br></code></pre></td></tr></table></figure><p>​    </p><h2 id="4-动态增加指定namespace配置缓存及监听变动"><a href="#4-动态增加指定namespace配置缓存及监听变动" class="headerlink" title="4. 动态增加指定namespace配置缓存及监听变动"></a>4. 动态增加指定namespace配置缓存及监听变动</h2><p>由于业务上需要一个不停服动态增加指定namespace配置的能力，而原版的v4.3.1版本只能在启动时读取配置项中已预置的namespace组，于是考虑不需要运维介入的情况下实现这个功能。</p><p>当然最妥善的方式当然是在启动配置中预置所需的namespace组，待下一次读取配置时可以在初始化过程及时拉取对应配置。</p><p>​    </p><h3 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1. 分析"></a>4.1. 分析</h3><p>看原库v4.3.1代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//GetConfig 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *internalClient)</span></span> GetConfig(namespace <span class="hljs-type">string</span>) *storage.Config &#123;<br><span class="hljs-keyword">return</span> c.GetConfigAndInit(namespace)<br>&#125;<br><br><span class="hljs-comment">//GetConfigAndInit 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *internalClient)</span></span> GetConfigAndInit(namespace <span class="hljs-type">string</span>) *storage.Config &#123;<br><span class="hljs-keyword">if</span> namespace == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>config := c.cache.GetConfig(namespace)<br><br><span class="hljs-keyword">if</span> config == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// &lt;--注意看这个代码块的逻辑</span><br><span class="hljs-comment">//init cache</span><br>storage.CreateNamespaceConfig(namespace)<br><br><span class="hljs-comment">//sync config</span><br>syncApolloConfig.SyncWithNamespace(namespace, c.getAppConfig)<br>&#125;<br><br>config = c.cache.GetConfig(namespace)<br><br><span class="hljs-keyword">return</span> config<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>GetConfigAndInit()</strong> 中有涉及到貌似增量加载namespace缓存的逻辑</p><p>来看看 <strong>storage.CreateNamespaceConfig(namespace)</strong> 和 <strong>syncApolloConfig.SyncWithNamespace(namespace, c.getAppConfig)</strong> 中做了什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateNamespaceConfig 根据namespace初始化agollo内容配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateNamespaceConfig</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>)</span></span> *Cache &#123;<br><span class="hljs-comment">// config from apollo</span><br><span class="hljs-keyword">var</span> apolloConfigCache sync.Map<br>config.SplitNamespaces(namespace, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, ok := apolloConfigCache.Load(namespace); ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>c := initConfig(namespace, extension.GetCacheFactory())<br>apolloConfigCache.Store(namespace, c)<br>&#125;)<br><span class="hljs-keyword">return</span> &amp;Cache&#123;<br>apolloConfigCache: apolloConfigCache,<br>changeListeners:   list.New(),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initConfig</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>, factory agcache.CacheFactory)</span></span> *Config &#123;<br>c := &amp;Config&#123;<br>namespace: namespace,<br>cache:     factory.Create(),<br>&#125;<br>c.isInit.Store(<span class="hljs-literal">false</span>)<br>c.waitInit.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>看这里会为新的namespace创建一个专属的 <strong>Cache</strong> 对象，并返回到外部；</p><p>而 <strong>SyncWithNamespace()</strong> 在上文2.1中分析过，内部是请求了 <strong>configfiles&#x2F;json</strong> 接口获取该namespace下所有配置信息，并返回 *<strong>config.ApolloConfig</strong> 对象；</p><p>但奇怪的是外部的 <strong>GetConfigAndInit()</strong> 方法没有接收上述2个方法的返回对象，有点不可思议；</p><p>​    </p><p>从 GetConfigAndInit 来看配置存储于<strong>c.cache</strong> 这个变量中，那么 Cache 的数据结构支持存储多个namespace的映射关系吗？</p><p>来看 <strong>Cache</strong> 的数据结构，和如何 set&#x2F;get</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cache apollo 配置缓存</span><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>apolloConfigCache *sync.Map<br>changeListeners   *list.List<br>rw                sync.RWMutex <span class="hljs-comment">// listener locker</span><br>&#125;<br><br><span class="hljs-comment">// GetConfig 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> GetConfig(namespace <span class="hljs-type">string</span>) *Config &#123;<br><span class="hljs-keyword">if</span> namespace == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>config, ok := c.apolloConfigCache.Load(namespace)<br><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> config.(*Config)<br>&#125;<br><br><span class="hljs-comment">// UpdateApolloConfigCache 根据conf[ig server返回的内容更新内存</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> UpdateApolloConfigCache(configurations <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, expireTime <span class="hljs-type">int</span>, namespace <span class="hljs-type">string</span>) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*ConfigChange &#123;<br>config := c.GetConfig(namespace)<br><span class="hljs-keyword">if</span> config == <span class="hljs-literal">nil</span> &#123;<br>config = initConfig(namespace, extension.GetCacheFactory())<br>c.apolloConfigCache.Store(namespace, config)<br>&#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>看来 apolloConfigCache 可以存储多个namespace对应的配置树，而且找到了set方法的触发方式 <strong>UpdateApolloConfigCache()</strong> ；</p><p>​    </p><p>顺藤摸瓜，来到 <strong>UpdateApolloConfig()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UpdateApolloConfig 根据config server返回的内容更新内存</span><br><span class="hljs-comment">// 并判断是否需要写备份文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> UpdateApolloConfig(apolloConfig *config.ApolloConfig, appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig) &#123;<br><span class="hljs-keyword">if</span> apolloConfig == <span class="hljs-literal">nil</span> &#123;<br>log.Error(<span class="hljs-string">&quot;apolloConfig is null, can&#x27;t update!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>appConfig := appConfigFunc()<br><span class="hljs-comment">// update apollo connection config</span><br>appConfig.SetCurrentApolloConfig(&amp;apolloConfig.ApolloConnConfig)<br><br><span class="hljs-comment">// get change list</span><br>changeList := c.UpdateApolloConfigCache(apolloConfig.Configurations, configCacheExpireTime, apolloConfig.NamespaceName)<br><br>notify := appConfig.GetNotificationsMap().GetNotify(apolloConfig.NamespaceName)<br><br><span class="hljs-comment">// push all newest changes</span><br>c.pushNewestChanges(apolloConfig.NamespaceName, apolloConfig.Configurations, notify)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(changeList) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// create config change event base on change list</span><br>event := createConfigChangeEvent(changeList, apolloConfig.NamespaceName, notify)<br><br><span class="hljs-comment">// push change event to channel</span><br>c.pushChangeEvent(event)<br>&#125;<br><br><span class="hljs-keyword">if</span> appConfig.GetIsBackupConfig() &#123;<br><span class="hljs-comment">// write config file async</span><br>apolloConfig.AppID = appConfig.AppID<br><span class="hljs-keyword">go</span> extension.GetFileHandler().WriteConfigFile(apolloConfig, appConfig.GetBackupConfigPath())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段逻辑中已经把 <code>获取当前连接--&gt;更新配置缓存--&gt;异步通知配置变更--&gt;异步备份配置信息成本地文件</code> 这条链完整实现了，于是只需要调用这个方法即可将 <strong>SyncWithNamespace()</strong> 得到的新增配置set到 <strong>Cache</strong> 中；</p><p>​    </p><p>但还剩一个问题，监听Apollo配置更新需要依赖长轮询，即依赖这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Start 启动配置组件定时器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ConfigComponent)</span></span> Start() &#123;<br><span class="hljs-keyword">if</span> c.stopCh == <span class="hljs-literal">nil</span> &#123;<br>c.stopCh = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br><br>t2 := time.NewTimer(longPollInterval)<br>instance := remote.CreateAsyncApolloConfig()<br><span class="hljs-comment">//long poll for sync</span><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t2.C:<br>configs := instance.Sync(c.appConfigFunc)  <span class="hljs-comment">// 请求notifications/v2接口，挂起等待apollo应答</span><br><span class="hljs-keyword">for</span> _, apolloConfig := <span class="hljs-keyword">range</span> configs &#123;<br>c.cache.UpdateApolloConfig(apolloConfig, c.appConfigFunc)  <span class="hljs-comment">// 将新配置刷新到内存本地缓存中</span><br>&#125;<br>t2.Reset(longPollInterval)<br><span class="hljs-keyword">case</span> &lt;-c.stopCh:<br><span class="hljs-keyword">break</span> loop<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p>那么问题来了~</p><p><strong>【问题1】</strong>如何通知这个方法获取<strong>新增namespace</strong>的连接信息呢？</p><p><strong>【问题2】</strong>这个方法是堵塞式长轮询，如何<strong>重启</strong>长轮询来触发订阅新namespace的变动呢？</p><p>​    </p><p>我们先解决<strong>【问题1】</strong>，看 <strong>instance.Sync(c.appConfigFunc)</strong> 的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *asyncApolloConfig)</span></span> Sync(appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig) []*config.ApolloConfig &#123;<br>appConfig := appConfigFunc()<br>remoteConfigs, err := a.notifyRemoteConfig(appConfigFunc, utils.Empty)  <span class="hljs-comment">// 获取需要更新的远程配置</span><br><br><span class="hljs-keyword">var</span> apolloConfigs []*config.ApolloConfig<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>apolloConfigs = loadBackupConfig(appConfig.NamespaceName, appConfig)<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(remoteConfigs) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(apolloConfigs) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> apolloConfigs<br>&#125;<br><span class="hljs-comment">//只是拉去有变化的配置, 并更新拉取成功的namespace的notify ID</span><br><span class="hljs-keyword">for</span> _, notifyConfig := <span class="hljs-keyword">range</span> remoteConfigs &#123;<br>apolloConfig := a.SyncWithNamespace(notifyConfig.NamespaceName, appConfigFunc)<br><span class="hljs-keyword">if</span> apolloConfig != <span class="hljs-literal">nil</span> &#123;<br>appConfig.GetNotificationsMap().UpdateNotify(notifyConfig.NamespaceName, notifyConfig.NotificationID)<br>apolloConfigs = <span class="hljs-built_in">append</span>(apolloConfigs, apolloConfig)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> apolloConfigs<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *asyncApolloConfig)</span></span> notifyRemoteConfig(appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig, namespace <span class="hljs-type">string</span>) ([]*config.Notification, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> appConfigFunc == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;can not find apollo config!please confirm!&quot;</span>)<br>&#125;<br>appConfig := appConfigFunc()<br>notificationsMap := appConfig.GetNotificationsMap()  <span class="hljs-comment">// 获取所有需要长轮询的namespace配置</span><br>urlSuffix := a.GetNotifyURLSuffix(notificationsMap.GetNotifies(namespace), appConfig)<br><br>connectConfig := &amp;env.ConnectConfig&#123;<br>URI:    urlSuffix,<br>AppID:  appConfig.AppID,<br>Secret: appConfig.Secret,<br>&#125;<br>connectConfig.Timeout = notifyConnectTimeout<br>notifies, err := http.RequestRecovery(appConfig, connectConfig, &amp;http.CallBack&#123;<br>SuccessCallBack: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(responseBody []<span class="hljs-type">byte</span>, callback http.CallBack)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> toApolloConfig(responseBody)<br>&#125;,<br>NotModifyCallBack: touchApolloConfigCache,<br>Namespace:         namespace,<br>&#125;)<br><br><span class="hljs-keyword">if</span> notifies == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> notifies.([]*config.Notification), err<br>&#125;<br><br><span class="hljs-comment">// .....</span><br><span class="hljs-comment">// GetNotificationsMap 获取notificationsMap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AppConfig)</span></span> GetNotificationsMap() *notificationsMap &#123;<br><span class="hljs-keyword">return</span> a.notificationsMap<br>&#125;<br><br><span class="hljs-comment">// map[string]int64</span><br><span class="hljs-keyword">type</span> notificationsMap <span class="hljs-keyword">struct</span> &#123;<br>notifications sync.Map<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码可以知道，只需要将新增的 <strong>namespace</strong> set入notifications即可~</p><p>然后没找到现成的方法，但是可以加嘛~</p><p>​    </p><p><strong>【问题2】</strong>其实很好解决，比较粗暴就是中断当前的请求，且获取新的namespaceMaps后重新发起长轮询请求，可以通过<strong>context.Context</strong>实现，当然代码里面也没有传递上下文，但是可以加嘛~</p><p>​    </p><p>虽然但是，其实距离实现我的需求只剩 <strong>四步之遥</strong>：</p><p><strong>【步骤1】</strong>获取新增namespace的所有配置信息</p><p><strong>【步骤2】</strong>把新增namespace加入到notificationMap</p><p><strong>【步骤3】</strong>重启长轮询，使得能够监听新增namespace的配置变动</p><p><strong>【步骤4】</strong>将新增namespace的配置存储到本地缓存</p><p>​    </p><h3 id="4-2-魔改"><a href="#4-2-魔改" class="headerlink" title="4.2. 魔改"></a>4.2. 魔改</h3><p>综合上述四个步骤，<strong>GetConfigAndInit()</strong> 的改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GetConfigAndInit 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *internalClient)</span></span> GetConfigAndInit(namespace <span class="hljs-type">string</span>) *storage.Config &#123;<br><span class="hljs-keyword">if</span> namespace == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>conf := c.cache.GetConfig(namespace)<br><span class="hljs-keyword">if</span> conf == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// sync config</span><br>apolloConfig := syncApolloConfig.SyncWithNamespace(context.Background(), namespace, c.getAppConfig)<br><span class="hljs-keyword">if</span> apolloConfig != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// trigger restart long polling, used to monitor changes in new namespaces</span><br>c.appConfig.GetNotificationsMap().AddNamespace(apolloConfig.NamespaceName)<br>c.changeMonitor.Stop()<br><span class="hljs-keyword">go</span> c.changeMonitor.Start()<br><span class="hljs-comment">// refresh cache</span><br>c.cache.UpdateApolloConfig(apolloConfig, c.getAppConfig)<br><span class="hljs-comment">// fetch config from cache again</span><br>conf = c.cache.GetConfig(namespace)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> conf<br>&#125;<br></code></pre></td></tr></table></figure><p>具体方法的内部修改可以看 <a href="https://github.com/lamber92/agollo">lamber92&#x2F;agollo</a> v4.3.2版本代码~</p><p>​    </p><h2 id="相关Issues"><a href="#相关Issues" class="headerlink" title="相关Issues"></a>相关Issues</h2><h3 id="1270-配置地址变成了服务器的内网ip"><a href="#1270-配置地址变成了服务器的内网ip" class="headerlink" title="#1270 配置地址变成了服务器的内网ip"></a><a id="1270">#1270 配置地址变成了服务器的内网ip</a></h3><p><a href="https://github.com/apolloconfig/apollo/issues/1270">https://github.com/apolloconfig/apollo/issues/1270</a></p><p>先说现象：</p><p><strong>services&#x2F;config</strong> 接口返回的是<strong>内网域名(或IP地址)</strong></p><p>如果使用Agollo配置时IP填写了外网IP或者不是内网域名，会导致访问 Apollo-Meta-Service 失败，反复输出ERROR日志，具有一定的迷惑性；</p><p>​    </p><p>解析原因：</p><p>看原库v4.3.1代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//RequestRecovery 可以恢复的请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RequestRecovery</span><span class="hljs-params">(appConfig config.AppConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">connectConfig *env.ConnectConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">callBack *CallBack)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>format := <span class="hljs-string">&quot;%s%s&quot;</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">var</span> response <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>host := loadBalance(appConfig)<br><span class="hljs-keyword">if</span> host == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>requestURL := fmt.Sprintf(format, host, connectConfig.URI)<br>response, err = Request(requestURL, connectConfig, callBack)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> response, <span class="hljs-literal">nil</span><br>&#125;<br><br>server.SetDownNode(appConfig.GetHost(), host)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadBalance</span><span class="hljs-params">(appConfig config.AppConfig)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> !server.IsConnectDirectly(appConfig.GetHost()) &#123;<br><span class="hljs-keyword">return</span> appConfig.GetHost()<br>&#125;<br>serverInfo := extension.GetLoadBalance().Load(server.GetServers(appConfig.GetHost()))<br><span class="hljs-keyword">if</span> serverInfo == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> utils.Empty<br>&#125;<br><br><span class="hljs-keyword">return</span> serverInfo.HomepageURL<br>&#125;<br></code></pre></td></tr></table></figure><p>在<strong>loadBalance</strong>逻辑中，当直连请求失败时（使用配置中的IP作为Domain请求失败），在会<strong>server.SetDownNode()</strong> 中会设置一个再次尝试的周期(30秒)，使得下一次请求不再使用配置的IP，而用 <strong>serverInfo.HomepageURL（Apollo-Meta-Service-URL）</strong> 代替 <strong>IP</strong>；</p><p>这时候 HomepageURL 记录的是**内网域名(或IP)**，如果Client和Apollo-Meta-Service间没有打通网络，会导致进一步失败；</p><p>在 <strong>Request(requestURL, connectConfig, callBack)</strong> 方法内部，默认有5次重试，会一直输出ERROR日志，有一定的误导性；</p><p>最后走到 **server.SetDownNode(appConfig.GetHost(), host)**，摘除这个Apollo-Meta-Service节点URL；</p><p>如果最终没有可用的Apollo-Meta-Service-URL，将直接退出循环；</p><p>等30秒后，由componet_notify.go发起的长轮询会再次使用配置中的 Host 直连Apollo-Config-Service请求。</p><p>​    </p><h3 id="3652-长轮询报-Invalid-timestamp"><a href="#3652-长轮询报-Invalid-timestamp" class="headerlink" title="#3652 长轮询报 Invalid timestamp"></a><a id="3652">#3652 长轮询报 Invalid timestamp</a></h3><p><a href="https://github.com/apolloconfig/apollo/issues/3652">https://github.com/apolloconfig/apollo/issues/3652</a></p><p>结合通过长轮询接口实现 <a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_212-config-service%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">Config Service通知客户端的实现方式</a> 逻辑，得知ApolloConfig-Service接收到请求后会挂起，期间有配置变更则会立即响应客户端请求，否则超时后返回304错误码。</p><p>我的定位流程大致与这篇文章相似，只是我的Agollo与Apollo-Config-Service之间隔了一层k8s-ingress，过程的抓包结果比较敏感就不截取了，分析过程可以借鉴这位博主的文章：</p><p><a href="https://blog.csdn.net/li281037846/article/details/122421089">记一次诡异的Apollo Long polling failed 401问题</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>apollo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Hexo问题记录</title>
    <link href="/2023/04/05/hexo/hexo/"/>
    <url>/2023/04/05/hexo/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="解决Hexo问题记录"><a href="#解决Hexo问题记录" class="headerlink" title="解决Hexo问题记录"></a>解决Hexo问题记录</h1><p align="right">Lamber</p><p align="right">2023-04-05</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>hexo版本信息</p><blockquote><p>λ hexo -v<br>INFO  Validating config<br>hexo: 6.3.0<br>hexo-cli: 4.3.0<br>os: win32 10.0.19045<br>node: 18.14.2<br>v8: 10.2.154.26-node.22<br>uv: 1.44.2<br>zlib: 1.2.13<br>brotli: 1.0.9<br>ares: 1.18.1<br>modules: 108<br>nghttp2: 1.51.0<br>napi: 8<br>llhttp: 6.0.10<br>uvwasi: 0.0.14<br>acorn: 8.8.1<br>simdutf: 3.1.0<br>undici: 5.20.0<br>openssl: 3.0.8+quic<br>cldr: 42.0<br>icu: 72.1<br>tz: 2022g<br>unicode: 15.0<br>ngtcp2: 0.8.1<br>nghttp3: 0.7.0             </p></blockquote><h1 id="1-部署提示”Cannot-find-module-‘-x2F-db-json’”"><a href="#1-部署提示”Cannot-find-module-‘-x2F-db-json’”" class="headerlink" title="1. 部署提示”Cannot find module ‘.&#x2F;db.json’”"></a>1. 部署提示”Cannot find module ‘.&#x2F;db.json’”</h1><p>运行 <code>hexo g</code> 报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">INFO  Validating config<br>ERROR Plugin load failed: hexo-server<br>Error: Cannot find module &#x27;./db.json&#x27;<br>Require stack:<br>- F:\blog\hexo-blog\node_modules\mime-db\index.js<br>- F:\blog\hexo-blog\node_modules\mime-types\index.js<br>- F:\blog\hexo-blog\node_modules\accepts\index.js<br>- F:\blog\hexo-blog\node_modules\compression\index.js<br>- F:\blog\hexo-blog\node_modules\hexo-server\lib\middlewares\gzip.js<br>- F:\blog\hexo-blog\node_modules\hexo-server\index.js<br>    at Module._resolveFilename (node:internal/modules/cjs/loader:1075:15)<br>    at Module._load (node:internal/modules/cjs/loader:920:27)<br>    at Module.require (node:internal/modules/cjs/loader:1141:19)<br>    at require (node:internal/modules/cjs/helpers:110:18)<br>    at Object.&lt;anonymous&gt; (F:\blog\hexo-blog\node_modules\mime-db\index.js:12:18)<br>    at Module._compile (node:internal/modules/cjs/loader:1254:14)<br>    at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)<br>    at Module.load (node:internal/modules/cjs/loader:1117:32)<br>    at Module._load (node:internal/modules/cjs/loader:958:12)<br>    at Module.require (node:internal/modules/cjs/loader:1141:19)<br>    at require (node:internal/modules/cjs/helpers:110:18)<br>    at Object.&lt;anonymous&gt; (F:\blog\hexo-blog\node_modules\mime-types\index.js:15:10)<br>    at Module._compile (node:internal/modules/cjs/loader:1254:14)<br>    at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)<br>    at Module.load (node:internal/modules/cjs/loader:1117:32)<br>    at Module._load (node:internal/modules/cjs/loader:958:12)<br>    at Module.require (node:internal/modules/cjs/loader:1141:19)<br>    at require (node:internal/modules/cjs/helpers:110:18)<br>    at Object.&lt;anonymous&gt; (F:\blog\hexo-blog\node_modules\accepts\index.js:16:12)<br>    at Module._compile (node:internal/modules/cjs/loader:1254:14)<br>    at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)<br>    at Module.load (node:internal/modules/cjs/loader:1117:32)<br></code></pre></td></tr></table></figure><p>我的本地项目在 <code>F:\blog\hexo-blog\node_modules\</code> 路径下，解决步骤如下：</p><ol><li>删除这个路径下 <code>mime-db</code> 、 <code>hexo-server</code> 两个目录</li><li>重新下载这两个依赖包 <code>npm install</code></li><li>重新执行 <code>hexo g</code> 成功不报错</li></ol><h1 id="2-MD文件插入图片使用-“-”-方式，hexo生成HTML后路径不正确"><a href="#2-MD文件插入图片使用-“-”-方式，hexo生成HTML后路径不正确" class="headerlink" title="2. MD文件插入图片使用 “[]()” 方式，hexo生成HTML后路径不正确"></a>2. MD文件插入图片使用 “[]()” 方式，hexo生成HTML后路径不正确</h1><p>修改 <code>node_modules\hexo-renderer-marked\lib\renderer.js</code> 文件</p><p>在 <code>image(href, title, text)</code> 方法的中部加入如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Prepend root to image path</span><br><span class="hljs-title function_">image</span>(<span class="hljs-params">href, title, text</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; hexo, options &#125; = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> &#123; relative_link &#125; = hexo.<span class="hljs-property">config</span>;<br>    <span class="hljs-keyword">const</span> &#123; lazyload, prependRoot, postPath &#125; = options;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="hljs-title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;<br>        <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-title class_">PostAsset</span> = hexo.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;PostAsset&#x27;</span>);<br>            <span class="hljs-comment">// findById requires forward slash</span><br>            <span class="hljs-keyword">const</span> asset = <span class="hljs-title class_">PostAsset</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-title function_">join</span>(postPath, href.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)));<br>            <span class="hljs-comment">// asset.path is backward slash in Windows</span><br>            <span class="hljs-keyword">if</span> (asset) href = asset.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>        &#125;<br>        href = url_for.<span class="hljs-title function_">call</span>(hexo, href);<br>    &#125;<br><br>    <span class="hljs-comment">// 加入这段代码===========================================</span><br>    <span class="hljs-comment">// 如果第一个符号是&#x27;/&#x27;,切掉</span><br>    <span class="hljs-keyword">if</span> (href.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; href[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        href = href.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果字符串不包含子串&#x27;http&#x27;,且包含&#x27;/&#x27;字符,截取&#x27;/&#x27;字符后的子串</span><br>    <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;://&#x27;</span>) &amp;&amp; href.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> index = href.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        href = href.<span class="hljs-title function_">substring</span>(index + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 加入这段代码===========================================</span><br><br>    <span class="hljs-keyword">let</span> out = <span class="hljs-string">`&lt;img src=&quot;<span class="hljs-subst">$&#123;encodeURL(href)&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">if</span> (text) out += <span class="hljs-string">` alt=&quot;<span class="hljs-subst">$&#123;text&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">if</span> (title) out += <span class="hljs-string">` title=&quot;<span class="hljs-subst">$&#123;title&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">if</span> (lazyload) out += <span class="hljs-string">&#x27; loading=&quot;lazy&quot;&#x27;</span>;<br><br>    out += <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新执行 <code>hexo g</code> –&gt; <code>hexo s</code></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ使用记录</title>
    <link href="/2023/04/05/rabbitmq/rabbitmq/"/>
    <url>/2023/04/05/rabbitmq/rabbitmq/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ使用记录"><a href="#RabbitMQ使用记录" class="headerlink" title="RabbitMQ使用记录"></a>RabbitMQ使用记录</h1><p align="right">Lamber</p><p align="right">2023-04-05</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>1. RabbitMQ与AMQP的关系：</strong></p><ul><li><p>RabbitMQ 是实现了 AMQP 协议的一种消息队列软件。它作为 AMQP 协议的一个实现，提供了可靠的消息传递机制，用于在分布式系统中传递和处理消息。</p><ul><li>RabbitMQ 仅实现了 <a href="https://www.rabbitmq.com/specification.html">AMQP 0-9-1 版本</a>。</li><li><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 是与 RabbitMQ 兼容的协议版本，而不是 AMQP 规范的官方版本</a>。</li></ul></li><li><p>AMQP 定义了一种消息传递的标准协议，包括了消息的格式、交换机（Exchange）和队列（Queue）的操作规范，以及消息的确认机制、事务机制等。RabbitMQ 遵循了 AMQP 协议的规范，实现了这些功能。</p></li><li><p>RabbitMQ 提供了丰富的功能，如消息持久化、消息路由、消息过滤、消息优先级、发布&#x2F;订阅模式、RPC（Remote Procedure Call，远程过程调用）等，这些功能都是基于 AMQP 协议的规范实现的。</p></li></ul><p><strong>2. 选择好RabbitMQ的消息传递模式，是正确使用RabbitMQ解决实际问题的前提。</strong></p><ul><li><p><strong>Direct模式：</strong></p><p>生产者将消息发送到指定的队列，并且消费者只会从指定的队列接收消息。消息的路由键（routing key）与队列的绑定键（binding key）完全匹配时，消息才会被发送到对应的队列。这种模式适合于一对一的消息通信，例如系统间的点对点通信。常见的使用场景包括日志记录、任务分发等。</p></li><li><p><strong>Fanout模式：</strong></p><p>生产者将消息发送到一个交换机，而交换机会将消息广播给所有绑定到它上面的队列。消费者可以同时订阅多个队列，从而接收到相同的消息。Fanout模式适合于广播通信，例如系统内的通知、事件广播等。</p></li><li><p><strong>Topic模式：</strong></p><p>生产者将消息发送到一个交换机（exchange），而不是直接发送到队列。交换机会根据消息的路由键将消息发送到多个队列，而消费者可以根据队列的绑定键（binding key）来订阅消息。<strong>Topic模式支持通配符的匹配，可以根据路由键的模式匹配多个队列。</strong>这种模式适合于发布和订阅模型，允许生产者发送广播消息，同时允许消费者选择订阅自己感兴趣的消息。常见的使用场景包括新闻订阅、社交网络等。</p></li></ul><p><strong>3. 下文中的RabbitMQ-Go代码示例均使用”<a href="https://github.com/rabbitmq/amqp091-go%22%E5%8C%85">https://github.com/rabbitmq/amqp091-go&quot;包</a></strong></p><h2 id="场景-amp-方案"><a href="#场景-amp-方案" class="headerlink" title="场景&amp;方案"></a>场景&amp;方案</h2><h3 id="1-保证消息顺序消费，且保证数据最终一致性"><a href="#1-保证消息顺序消费，且保证数据最终一致性" class="headerlink" title="1. 保证消息顺序消费，且保证数据最终一致性"></a>1. 保证消息顺序消费，且保证数据最终一致性</h3><p>这种场景的典型例子是不同数据库间表数据的增量同步。</p><h4 id="1-1-功能配置"><a href="#1-1-功能配置" class="headerlink" title="1.1. 功能配置"></a><strong>1.1. 功能配置</strong></h4><ul><li>交换机模式：Direct</li><li>生产者：<ul><li>消息持久化</li><li>消息推送成功确认</li></ul></li><li>消费者：<ul><li>保证每个队列只有一个消费者（保证顺序）<ul><li>如果条件允许，或者消息量巨大，可以在生产者侧根据业务属性对消息分散投递到不同队列，每个队列对应一个消费者，并行消费。</li><li>比如10个队列同步user表数据，只要确保相同user_id的消息投递到同一队列，就能保证这个user_id的数据按顺序消费。将user_id对10取模，投递到对应序号的队列即可。</li></ul></li><li>设置Qos.PrefetchCount &#x3D; 1，保证消息每次从队列重新获取，避免消费失败后，获取的消息是预获取缓冲区内消息，导致乱序<ul><li>如果消费者侧可以保证消息消费幂等性，或有消息消费顺序保护策略，可加大PrefetchCount值。</li></ul></li><li>消费成功时手动 Ack</li><li>消费失败时手动 Nack，并且requeue&#x3D;true，使得消息能重回队首重新消费，否则消息将进入死信队列</li></ul></li></ul><h4 id="1-2-代码示例"><a href="#1-2-代码示例" class="headerlink" title="1.2. 代码示例"></a><strong>1.2. 代码示例</strong></h4><ul><li><strong>消费者</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go/amqp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RabbitMQ 服务器</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法连接到 RabbitMQ 服务器：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 创建一个通道</span><br>ch, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法创建 RabbitMQ 通道：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 声明一个 Direct 类型的交换机</span><br>err = ch.ExchangeDeclare(<br><span class="hljs-string">&quot;direct_exchange&quot;</span>, <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-string">&quot;direct&quot;</span>,           <span class="hljs-comment">// 交换机类型</span><br><span class="hljs-literal">true</span>,               <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否自动删除</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否内部交换机</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否等待服务器响应</span><br><span class="hljs-literal">nil</span>,                <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法声明 Direct 交换机：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 声明一个队列</span><br>q, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;direct_queue&quot;</span>, <span class="hljs-comment">// 队列名称</span><br><span class="hljs-literal">true</span>,           <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// 是否自动删除</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// 是否排他队列</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// 是否阻塞等待服务器响应</span><br><span class="hljs-literal">nil</span>,            <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法声明队列：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 将队列绑定到交换机，使用 &quot;direct_routing_key&quot; 作为路由键</span><br>err = ch.QueueBind(<br>q.Name,             <span class="hljs-comment">// 队列名称</span><br><span class="hljs-string">&quot;direct_routing_key&quot;</span>, <span class="hljs-comment">// 路由键</span><br><span class="hljs-string">&quot;direct_exchange&quot;</span>,   <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-literal">false</span>,               <span class="hljs-comment">// 是否等待服务器响应</span><br><span class="hljs-literal">nil</span>,                 <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法绑定队列到 Direct 交换机：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 消费消息</span><br>msgs, err := ch.Consume(<br>q.Name, <span class="hljs-comment">// 队列名称</span><br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// 消费者标签，为空则由服务器自动生成</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否自动确认消息</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否排他消费者</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否阻塞等待服务器响应</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否不等待服务器确认消费者创建完成</span><br><span class="hljs-literal">nil</span>,    <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法注册消费者：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 接收并处理消息</span><br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;接收到消息：%s\n&quot;</span>, msg.Body)<br><span class="hljs-comment">// 手动确认消息已被消费</span><br>msg.Ack(<span class="hljs-literal">false</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>生产者</strong></li></ul><p>需要注意的是，需要推送消息成功确认，确保消息不丢失。</p><p>在这种模式下，如果不接受并处理已”确认回调信息”，那么推送消息的channel将会堵塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br><br><span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go/amqp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RabbitMQ 服务器</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法连接到 RabbitMQ 服务器：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 创建一个通道</span><br>ch, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法创建 RabbitMQ 通道：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 启用消息推送确认模式</span><br><span class="hljs-keyword">if</span> err = ch.Confirm(<span class="hljs-literal">false</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法启用消息推送确认模式：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 注册消息推送确认回调函数</span><br>confirms := ch.NotifyPublish(<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> amqp.Confirmation, <span class="hljs-number">1</span>))<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> confirmed := &lt;-confirms; !confirmed.Ack &#123;<br>log.Println(<span class="hljs-string">&quot;消息发送失败&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Println(<span class="hljs-string">&quot;消息发送成功&quot;</span>)<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 声明一个 Direct 类型的交换机</span><br>err = ch.ExchangeDeclare(<br><span class="hljs-string">&quot;direct_exchange&quot;</span>, <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-string">&quot;direct&quot;</span>,           <span class="hljs-comment">// 交换机类型</span><br><span class="hljs-literal">true</span>,               <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否自动删除</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否内部交换机</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否等待服务器响应</span><br><span class="hljs-literal">nil</span>,                <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法声明 Direct 交换机：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 发布消息到 Direct 交换机</span><br>err = ch.Publish(<br><span class="hljs-string">&quot;direct_exchange&quot;</span>,   <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-string">&quot;direct_routing_key&quot;</span>, <span class="hljs-comment">// 路由键</span><br><span class="hljs-literal">true</span>,                <span class="hljs-comment">// 是否强制发送（消息发送失败时会触发确认回调函数）</span><br><span class="hljs-literal">false</span>,               <span class="hljs-comment">// 是否立即发送</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, RabbitMQ!&quot;</span>),<br>&#125;, <span class="hljs-comment">// 消息内容</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法发布消息：%v&quot;</span>, err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;消息已成功发送&quot;</span>)<br><br><span class="hljs-comment">// 等待程序退出</span><br>waitForExit()<br>&#125;<br><br><span class="hljs-comment">// 等待程序退出的辅助函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitForExit</span><span class="hljs-params">()</span></span> &#123;<br>sigCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)<br>&lt;-sigCh<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-不需要保证消费顺序，消息量巨大，允许部分消息消费失败"><a href="#2-不需要保证消费顺序，消息量巨大，允许部分消息消费失败" class="headerlink" title="2. 不需要保证消费顺序，消息量巨大，允许部分消息消费失败"></a>2. 不需要保证消费顺序，消息量巨大，允许部分消息消费失败</h3><p>这种场景的典型例子是热点数据异步更新到搜索引擎。比如电商商品促销活动，不定量的商品数据属性高频变动，导致在短时间内产生海量数据。</p><h4 id="2-1-功能配置"><a href="#2-1-功能配置" class="headerlink" title="2.1. 功能配置"></a><strong>2.1. 功能配置</strong></h4><ul><li>交换机模式：Direct<ul><li>如果需要多渠道通知，选择 Fanout</li><li>如果需要根据不同属性多渠道动态通知，选择 Topic</li></ul></li><li>生产者：<ul><li>消息持久化</li><li>消息推送不需要确认</li></ul></li><li>消费者：<ul><li>保证每个队列有多个消费者<ul><li>一个connect，创建多个channel，每个channel对应一个消费者<ul><li>如果使用 AutoAck 模式，可以一个channel创建多个consumer</li><li>每个consumer_tag尽量不同，方便cancel</li></ul></li></ul></li><li>设置Qos.PrefetchCount &#x3D; 100，尽可能多预取缓存，批量处理消息，增加消息消费速度</li><li>消费成功时手动 Ack，并且 multiple&#x3D;true，批量消费确认delivery_tag，delivery_tag是针对所属的channel的，对其他channel无影响<ul><li>条件更宽松时可以使用 AutoAck</li></ul></li><li>消费失败时手动 Nack，并且requeue&#x3D;false，使得消息能重回队首重新消费，否则消息将进入死信队列<ul><li>条件更宽松时可以消费失败也是用 Ack</li></ul></li></ul></li></ul><h4 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2. 代码示例"></a><strong>2.2. 代码示例</strong></h4><ul><li><strong>消费者</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RabbitMQ 服务器</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to connect to RabbitMQ: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 创建 channel</span><br>ch1, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open channel: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch1.Close()<br><br>ch2, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open channel: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch2.Close()<br><br><span class="hljs-comment">// 声明 exchange</span><br>err = ch1.ExchangeDeclare(<br><span class="hljs-string">&quot;test_exchange&quot;</span>, <span class="hljs-comment">// 名称</span><br><span class="hljs-string">&quot;direct&quot;</span>,        <span class="hljs-comment">// 类型</span><br><span class="hljs-literal">true</span>,            <span class="hljs-comment">// 持久化</span><br><span class="hljs-literal">false</span>,           <span class="hljs-comment">// 不自动删除</span><br><span class="hljs-literal">false</span>,           <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">false</span>,           <span class="hljs-comment">// 不等待 server 确认</span><br><span class="hljs-literal">nil</span>,             <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to declare exchange: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 声明队列</span><br>q, err := ch1.QueueDeclare(<br><span class="hljs-string">&quot;test_queue&quot;</span>,<br><span class="hljs-literal">true</span>,  <span class="hljs-comment">// 持久化</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 自动删除</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 独占</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">nil</span>,   <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to declare queue: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 绑定队列到 exchange 上</span><br><span class="hljs-keyword">if</span> err := ch1.QueueBind(q.Name, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;test_exchange&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to bind queue: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 绑定队列到两个 channel 上</span><br><span class="hljs-keyword">if</span> err := ch1.QueueBind(q.Name, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to bind queue: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := ch2.QueueBind(q.Name, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to bind queue: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 创建两个 consumer</span><br>consumer1, err := ch1.Consume(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不自动应答</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 独占</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待 server 确认</span><br><span class="hljs-literal">nil</span>,   <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to register consumer: %v&quot;</span>, err)<br>&#125;<br><br>consumer2, err := ch2.Consume(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不自动应答</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 独占</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待 server 确认</span><br><span class="hljs-literal">nil</span>,   <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to register consumer: %v&quot;</span>, err)<br>    &#125;<br>    <br><span class="hljs-comment">// 每次取出 10 条消息，进行批量确认</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> msg, ok := &lt;-consumer1:<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Printf(<span class="hljs-string">&quot;channel closed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 处理消息</span><br>fmt.Printf(<span class="hljs-string">&quot;received message: %s\n&quot;</span>, msg.Body)<br><br><span class="hljs-comment">// 批量确认消息</span><br><span class="hljs-keyword">if</span> msg.DeliveryTag%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 这里也可以直接调用 msg.Ack(true) 代替，下同</span><br>err = ch1.Ack(msg.DeliveryTag, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;failed to ack message: %v&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">case</span> msg, ok := &lt;-consumer2:<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Printf(<span class="hljs-string">&quot;channel closed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 处理消息</span><br>fmt.Printf(<span class="hljs-string">&quot;received message: %s\n&quot;</span>, msg.Body)<br><br><span class="hljs-comment">// 批量确认消息</span><br><span class="hljs-keyword">if</span> msg.DeliveryTag%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &#123;<br>err = ch2.Ack(msg.DeliveryTag, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;failed to ack message: %v&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>生产者</strong></p><p>同1.2生产者，省略。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.rabbitmq.com/specification.html">https://www.rabbitmq.com/specification.html</a> [RabbitMQ 兼容性和一致性]</li><li><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a> [AMQP 0-9-1 模型解释]</li><li><a href="https://github.com/rabbitmq/amqp091-go">https://github.com/rabbitmq/amqp091-go</a> [由 RabbitMQ 团队维护的 AMQP 0-9-1 Go 客户端]</li></ul>]]></content>
    
    
    <categories>
      
      <category>rabbitmq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-浅析net库http请求处理流程</title>
    <link href="/2023/03/07/golang/http_request/"/>
    <url>/2023/03/07/golang/http_request/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-浅析net库http请求处理流程"><a href="#Golang-浅析net库http请求处理流程" class="headerlink" title="Golang-浅析net库http请求处理流程"></a>Golang-浅析net库http请求处理流程</h1><p>主要记录HTTP请求在net包中经历的关键节点，基于go1.19.1</p><p>学习net包中使用 预分配内存、sync.Pool 提升性能技巧，以及其他优秀的设计思想。</p><h2 id="1-管理TCP连接"><a href="#1-管理TCP连接" class="headerlink" title="1. 管理TCP连接"></a>1. 管理TCP连接</h2><p>什么epoll、三次握手这些八股文不提了，这里从 <code>Serve()</code> 开始记录；</p><p>在 <strong>net&#x2F;http&#x2F;server.go</strong> 的 <code>func (srv *Server) Serve(l net.Listener) error</code> 方法中，关注以下流程：</p><p><img src="conn.jpg"></p><ul><li><code>l.Accept()</code> 得到一个 <code>*net.TCPConn</code> 类型的指针 <strong>rw</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    .......<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, err := l.Accept()<br>        ......<br>        c := srv.newConn(rw)<br>        c.setState(c.rwc, StateNew, runHooks) <span class="hljs-comment">// before Serve can return</span><br>        <span class="hljs-keyword">go</span> c.serve(connCtx)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这个*net.TCPConn是个什么东西？可以稍稍看看里面</p><ul><li>net&#x2F;tcpsock.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TCPConn is an implementation of the Conn interface for TCP network</span><br><span class="hljs-comment">// connections.</span><br><span class="hljs-keyword">type</span> TCPConn <span class="hljs-keyword">struct</span> &#123;<br>conn<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部嵌套conn，net&#x2F;net.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> conn <span class="hljs-keyword">struct</span> &#123;<br>fd *netFD <span class="hljs-comment">// &lt;--找到这个命名就知道对了</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>net&#x2F;fd_posix.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Network file descriptor.</span><br><span class="hljs-keyword">type</span> netFD <span class="hljs-keyword">struct</span> &#123;<br>pfd poll.FD <span class="hljs-comment">// &lt;--找到稍微根源的东西了，这里先不深入了</span><br><br><span class="hljs-comment">// immutable until Close</span><br>family      <span class="hljs-type">int</span><br>sotype      <span class="hljs-type">int</span><br>isConnected <span class="hljs-type">bool</span> <span class="hljs-comment">// handshake completed or use of association with peer</span><br>net         <span class="hljs-type">string</span><br>laddr       Addr<br>raddr       Addr<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>srv.newConn(rw)</code> 中包装并返回 <code>server.conn</code> 对象指针（下面简称 <strong>conn</strong>），其中 server.conn.<strong>rwc</strong> 指向这个 <strong>rw</strong></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create new connection from rwc.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> newConn(rwc net.Conn) *conn &#123;<br>c := &amp;conn&#123;<br>server: srv, <span class="hljs-comment">// 保存Server的指针，这种设计很多见，这里用于处理连接状态变更后统一使用server.ConnState进行回调等等动作</span><br>        rwc:    rwc, <span class="hljs-comment">// Accept()得到的*net.TCPConn</span><br>&#125;<br><span class="hljs-keyword">if</span> debugServerConnections &#123;<br>c.rwc = newLoggingConn(<span class="hljs-string">&quot;server&quot;</span>, c.rwc)<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>经过 <code>c.setState()</code> 会将 <strong>rw</strong> 记录在 <code>server.activeConn</code> 中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> trackConn(c *conn, add <span class="hljs-type">bool</span>) &#123;<br>s.mu.Lock()<br><span class="hljs-keyword">defer</span> s.mu.Unlock()<br><span class="hljs-keyword">if</span> s.activeConn == <span class="hljs-literal">nil</span> &#123;<br>s.activeConn = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*conn]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br><span class="hljs-keyword">if</span> add &#123;<br>        <span class="hljs-comment">// 对于新增conn首次设置状态走这里，将conn指针保存到server的活跃集合中。</span><br>        <span class="hljs-comment">// 此处实现了Server实例对conn后续管理的前提。</span><br>s.activeConn[c] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">delete</span>(s.activeConn, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>并且 <strong>conn</strong> 会更新当前状态，这个状态使用一个 <strong>原子变量</strong> 存储保证一致性</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> setState(nc net.Conn, state ConnState, runHook <span class="hljs-type">bool</span>) &#123;<br>srv := c.server<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-keyword">case</span> StateNew:<br>srv.trackConn(c, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 见上文</span><br><span class="hljs-keyword">case</span> StateHijacked, StateClosed:<br>srv.trackConn(c, <span class="hljs-literal">false</span>)<br>&#125;<br><span class="hljs-keyword">if</span> state &gt; <span class="hljs-number">0xff</span> || state &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;internal error&quot;</span>)<br>&#125;<br>packedState := <span class="hljs-type">uint64</span>(time.Now().Unix()&lt;&lt;<span class="hljs-number">8</span>) | <span class="hljs-type">uint64</span>(state) <span class="hljs-comment">// 低8位保存当前状态，8位前保存变更时间戳</span><br>atomic.StoreUint64(&amp;c.curState.atomic, packedState) <span class="hljs-comment">// 更新当前状态</span><br><span class="hljs-keyword">if</span> !runHook &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> hook := srv.ConnState; hook != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这里会用到srv，如果Server有外置的钩子，conn每一次状态变更，都会在这里回调通知</span><br>hook(nc, state)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>最后这个 <strong>conn</strong> 带着一个”有故事的”上下文，在全新的goroutine中执行；</p><ul><li>这个上下文的前置处理有点东西，有很强的扩展性，简单记录一下</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    ......<br>    origListener := l<br>    ......<br>    baseCtx := context.Background() <span class="hljs-comment">// 先获取一个平平无奇的上下文</span><br>    <span class="hljs-keyword">if</span> srv.BaseContext != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 这里可以利用srv指定的基础上下文获取方法替代原始baseCtx，是指Server层级的Context处理过程。</span><br>        <span class="hljs-comment">// 这里的l可以有很多种实例，这里是tcp，也可以是udp、uds等。</span><br>        baseCtx = srv.BaseContext(origListener)<br>        <span class="hljs-keyword">if</span> baseCtx == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;BaseContext returned a nil context&quot;</span>)<br>        &#125;<br>    &#125;<br>    ......<br>    <span class="hljs-comment">// 这里使用一个*valueCtx将baseCtx包裹在内，并使用ServerContextKey与srv的指针存储kv，方便在任何带有该上下文的方法中得到srv，可以说非常灵活。</span><br>    ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br>    <span class="hljs-keyword">for</span> &#123;<br>        connCtx := ctx<br>        <span class="hljs-comment">// 这里利用srv指定Connect层级的Context处理过程，与上文的BaseContext相互照应，这种分离层级策略使得ctx的特殊处理更为细致与明确。</span><br>        <span class="hljs-comment">// 方便针对各种http框架的context在此处进行特殊业务处理。</span><br>        <span class="hljs-keyword">if</span> cc := srv.ConnContext; cc != <span class="hljs-literal">nil</span> &#123;<br>            connCtx = cc(connCtx, rw)<br>            <span class="hljs-keyword">if</span> connCtx == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;ConnContext returned nil&quot;</span>)<br>            &#125;<br>        &#125;<br>        ......<br>        c := srv.newConn(rw)<br>        ......<br>        <span class="hljs-keyword">go</span> c.serve(connCtx) <span class="hljs-comment">// 最终ctx被带人到下一步的请求处理中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-读取请求内容"><a href="#2-读取请求内容" class="headerlink" title="2. 读取请求内容"></a>2. 读取请求内容</h2><h3 id="2-1-主流程"><a href="#2-1-主流程" class="headerlink" title="2.1. 主流程"></a>2.1. 主流程</h3><ul><li>从 <code>func (c *conn) serve(ctx context.Context)</code> 进去主要关注以下流程：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve(ctx context.Context) &#123;<br>    ......<br>    <span class="hljs-comment">// 连接退出善后处理流程</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 先来一个recover，防止本goroutine发送panic导致主goroutine退出</span><br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;<br>            <span class="hljs-comment">// 这里是打印一些panic的堆栈信息</span><br><span class="hljs-keyword">const</span> size = <span class="hljs-number">64</span> &lt;&lt; <span class="hljs-number">10</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>buf = buf[:runtime.Stack(buf, <span class="hljs-literal">false</span>)]<br>c.server.logf(<span class="hljs-string">&quot;http: panic serving %v: %v\n%s&quot;</span>, c.remoteAddr, err, buf)<br>&#125;<br>        <span class="hljs-comment">// 如果没有在外部调用劫持请求，将调用close方法释放资源，并更细连接状态为 Close(结束)</span><br>        <span class="hljs-comment">// 到这里可能疑惑：</span><br>        <span class="hljs-comment">//     如果劫持了，那么资源怎么释放？答案是劫持方法会返回*conn，需要在劫持处理完成后手工调用conn.Close()方法释放资源，否则出现资源泄露！</span><br><span class="hljs-keyword">if</span> !c.hijacked() &#123;<br>c.<span class="hljs-built_in">close</span>()<br>c.setState(c.rwc, StateClosed, runHooks)<br>&#125;<br>&#125;()<br>    ......<br>    c.r = &amp;connReader&#123;conn: c&#125;<br>    <span class="hljs-comment">// 申请内存空间，用于存储请求body数据</span><br>c.bufr = newBufioReader(c.r)<br>    ......<br>    ......<br>    <span class="hljs-comment">// 真正的核心流程开始，分6个主要流程</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 1.解析请求内容，并构造、填充req与resp信息对象</span><br>        w, err := c.readRequest(ctx)<br>        ......<br>        <span class="hljs-comment">// 2.通过回调的方式经过如洋葱一般的各层http框架的中间件再到达真实业务逻辑层，最终又原路返回</span><br>        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)<br>        ......<br>        <span class="hljs-comment">// 3.请求处理完成，重置各种请求状态、释放各种临时资源</span><br>        w.finishRequest()<br>        <span class="hljs-comment">// 4.判断连接是否可重用，不可重用则直接返回释放连接</span><br>        <span class="hljs-keyword">if</span> !w.shouldReuseConnection() &#123;<br>            <span class="hljs-keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;<br>                <span class="hljs-comment">// 发送FIN报文，主动关闭连接，并等待一定时间(这里是500ms)，等待客户端将未处理的数据处理完</span><br>        c.closeWriteAndWait()<br>            &#125;<br>        <span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 5.更新连接状态为 Idle (已完成)</span><br>c.setState(c.rwc, StateIdle, runHooks)<br>        <span class="hljs-comment">// 6.如果请求没有设置 keep_alive 选项，则直接结束连接</span><br>        <span class="hljs-comment">// 反之保持连接，等待下一次请求</span><br>        <span class="hljs-keyword">if</span> !w.conn.server.doKeepAlives() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-请求数据解析-x2F-存储流程"><a href="#2-2-请求数据解析-x2F-存储流程" class="headerlink" title="2.2. 请求数据解析&#x2F;存储流程"></a>2.2. 请求数据解析&#x2F;存储流程</h3><ul><li><p>申请存储数据的内存缓冲区</p><ul><li>net&#x2F;http&#x2F;server.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newBufioReader</span><span class="hljs-params">(r io.Reader)</span></span> *bufio.Reader &#123;<br>    <span class="hljs-comment">// 这里可以明白，这个内存首先尝试在一个sync.Pool中获取，说明后面逻辑中有将资源置入缓冲池里复用，避免频繁GC</span><br>    <span class="hljs-comment">// 在conn.close()和conn.closeWriteAndWait()都会将首次申请的缓冲区内存Put到池中，等待下一次连接重用</span><br><span class="hljs-keyword">if</span> v := bufioReaderPool.Get(); v != <span class="hljs-literal">nil</span> &#123;<br>br := v.(*bufio.Reader)<br>br.Reset(r)<br><span class="hljs-keyword">return</span> br<br>&#125;<br><span class="hljs-keyword">return</span> bufio.NewReader(r) <span class="hljs-comment">// &lt;--首次处理一个连接的请求时没有缓冲池，会真正申请一块连续内存</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>bufio&#x2F;bufio.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>defaultBufSize = <span class="hljs-number">4096</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(rd io.Reader)</span></span> *Reader &#123;<br><span class="hljs-keyword">return</span> NewReaderSize(rd, defaultBufSize) <span class="hljs-comment">// &lt;--这里会预分配一块4KB大小的内存</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReaderSize</span><span class="hljs-params">(rd io.Reader, size <span class="hljs-type">int</span>)</span></span> *Reader &#123;<br>......<br>r := <span class="hljs-built_in">new</span>(Reader)<br>r.reset(<span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size), rd)<br><span class="hljs-keyword">return</span> r<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> reset(buf []<span class="hljs-type">byte</span>, r io.Reader) &#123;<br>*b = Reader&#123; <span class="hljs-comment">// &lt;--最终创建一个*bufio.Reader保存预分配的内存</span><br>buf:          buf,  <span class="hljs-comment">// 4KB空白内存</span><br>rd:           r,    <span class="hljs-comment">// *connReader</span><br>lastByte:     <span class="hljs-number">-1</span>,<br>lastRuneSize: <span class="hljs-number">-1</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读取http-body数据到缓存区</p><ul><li>从连接中读取请求数据，以及初始化响应</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> readRequest(ctx context.Context) (w *response, err <span class="hljs-type">error</span>) &#123;<br>    ......<br>    <span class="hljs-comment">// 真正处理读取连接内容的方法</span><br>    req, err := readRequest(c.bufr, keepHostHeader)<br>    <span class="hljs-comment">// 构造resp</span><br>    w = &amp;response&#123;<br>        conn:          c,<br>        cancelCtx:     cancelCtx,<br>        req:           req,<br>        reqBody:       req.Body,<br>        ......<br>    &#125;<br>    ......<br>    <span class="hljs-keyword">return</span> w, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>解析请求，并构request对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readRequest</span><span class="hljs-params">(b *bufio.Reader, deleteHostHeader <span class="hljs-type">bool</span>)</span></span> (req *Request, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 创建或从缓冲池中获取一个text格式协议的Reader，此时tp中携带了*bufio.Reade--&gt;b，在后续读取数据时将直接对b预申请的4KB缓冲区进行写操作</span><br>    <span class="hljs-comment">// 其内部会初始化所有的公共Header(单例模式)，用于后续读取公共Header时知道需要获取哪些Header-Value</span><br>tp := newTextprotoReader(b)<br>req = <span class="hljs-built_in">new</span>(Request)<br><br><span class="hljs-comment">// First line: GET /index.html HTTP/1.0</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>    <span class="hljs-comment">// 利用TextprotoReader读取conn信息，并填充b的4KB缓冲区</span><br><span class="hljs-keyword">if</span> s, err = tp.ReadLine(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>    <span class="hljs-comment">// TextprotoReader的善后处理</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>putTextprotoReader(tp) <span class="hljs-comment">// 将资源Put到缓冲池中等待下一个报文复用</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br>err = io.ErrUnexpectedEOF<br>&#125;<br>&#125;()<br>    <br>    ......<br>    <span class="hljs-comment">// 这里主要是解析URL上的请求参数，没啥好说的，比较简单，参数存储在req.URL.RawQuery中</span><br>rawurl := req.RequestURI<br><span class="hljs-keyword">if</span> req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, badStringError(<span class="hljs-string">&quot;malformed HTTP version&quot;</span>, req.Proto)<br>&#125;<br><span class="hljs-keyword">if</span> req.URL, err = url.ParseRequestURI(rawurl); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>    ......<br>    <br>    <span class="hljs-comment">// 这里获取newTextprotoReader()中初始化的所有Header-Key对用的Header-Value，返回KV接口的Header信息</span><br>mimeHeader, err := tp.ReadMIMEHeader()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>req.Header = Header(mimeHeader)<br>    <br>    ......<br>    <span class="hljs-comment">// 对于Body.len &gt; 0的请求，将b中4BK缓冲区的数据交给req.Body，这里交付的是指针对象，不存在深拷贝</span><br>    <span class="hljs-comment">// 并且尽可能通过读取Header: Content-Length得知真实Body内容大小，对b进行二次封装--&gt;io.LimitReader，记录有效内容字节数</span><br>    <span class="hljs-comment">// 后续可以通过字节数直接获取有效内容</span><br>    <span class="hljs-comment">// 对于Body.len == 0的请求，直接赋值 NoBody: struct&#123;&#125; 给到req.Body</span><br>    err = readTransfer(req, b)<br>    <br>    ......<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APISIX-2.13.3-CentOS_7-单节点部署</title>
    <link href="/2022/09/02/apisix/APISIX-2.13.3-CentOS_7-SingleNode/"/>
    <url>/2022/09/02/apisix/APISIX-2.13.3-CentOS_7-SingleNode/</url>
    
    <content type="html"><![CDATA[<h1 id="APISIX-2-13-3-CentOS-7-单节点部署"><a href="#APISIX-2-13-3-CentOS-7-单节点部署" class="headerlink" title="APISIX-2.13.3-CentOS_7-单节点部署"></a>APISIX-2.13.3-CentOS_7-单节点部署</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul><li>APISIX服务、ETCD、Grafana使用docker容器部署</li><li>APISIX-Dashboard使用yum方式安装</li><li>ETCD版本：<a href="https://hub.docker.com/layers/bitnami/etcd/3.4.20/images/sha256-4ac42c73de723d764158e04b8c876806a992846c3320e80c24a73b5611fd1211?context=explore">3.4.20</a></li><li>APISIX版本：<a href="https://hub.docker.com/layers/apache/apisix/2.13.3-centos/images/sha256-f0555b53112bde34cfb40e411bd0660676adebd6451740787c2b7c9bf151a5ea?context=explore">2.13.3-centos</a></li><li>Grafana版本：<a href="https://hub.docker.com/layers/grafana/grafana/9.1.4/images/sha256-f776b98f6bc3115d04f76f9b52b8172ac0cd81a8a78933d7e48bf2b76ce13d95?context=explore">9.1.4</a></li><li>Prometheus版本：<a href="https://hub.docker.com/layers/prom/prometheus/v2.37.1/images/sha256-3e1ee1732b4a3d08d971ee05950f30ce54dd405d7f0255bcab2303827a01312e?context=explore">2.37.1</a></li><li>APISIX-Dashboard版本：2.13.3-centos</li><li>APISIX官方部署教程：<ul><li><a href="https://apisix.apache.org/zh/docs/apisix/installation-guide/">APISIX</a></li><li><a href="https://apisix.apache.org/zh/docs/dashboard/install/">APISIX-Dashboard</a></li></ul></li><li>单节点部署方式仅用于功能体验，不适用于真实生产环境；本样例使用较为快捷的方式安装，意于测试apisix的基础能力</li></ul><h2 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h2><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y docker<br></code></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure><h2 id="2-安装APISIX服务"><a href="#2-安装APISIX服务" class="headerlink" title="2. 安装APISIX服务"></a>2. 安装APISIX服务</h2><ul><li>安装ETCD</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>   --name etcd \<br>   --net host \<br>   -e ALLOW_NONE_AUTHENTICATION=yes \<br>   -e ETCD_ADVERTISE_CLIENT_URLS=http://127.0.0.1:2379 \<br>   bitnami/etcd:3.4.20<br></code></pre></td></tr></table></figure><ul><li>安装APISIX</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --name apache-apisix \<br>    --net host \<br>    -p 9091:9091 \<br>    apache/apisix:2.13.3-centos<br></code></pre></td></tr></table></figure><ul><li>安装好后默认账号与密码</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apisix:</span><br>  <span class="hljs-attr">admin_key:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">key:</span> <span class="hljs-string">edd1c9f034335f136f87ad84b625c8f1</span>  <span class="hljs-comment"># using fixed API token has security risk, please update it when you deploy to production environment</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><h2 id="3-安装APISIX-Dashboard服务"><a href="#3-安装APISIX-Dashboard服务" class="headerlink" title="3. 安装APISIX-Dashboard服务"></a>3. 安装APISIX-Dashboard服务</h2><ul><li>下载rpm安装包并安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y https://github.com/apache/apisix-dashboard/releases/download/v2.13/apisix-dashboard-2.13-0.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><ul><li>修改配置文件，使其能运行所有机器访问</li></ul><p>编辑文件：&#x2F;usr&#x2F;local&#x2F;apisix&#x2F;dashboard&#x2F;conf&#x2F;conf.yaml</p><p>注释掉 allow_list下面的IP地址默认配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">33   allow_list:</span>             <span class="hljs-comment"># If we don&#x27;t set any IP list, then any IP access is allowed by default.</span><br><span class="hljs-number">34</span>   <span class="hljs-comment">#  - 0.0.0.0            # The rules are checked in sequence until the first match is found.</span><br><span class="hljs-number">35</span>   <span class="hljs-comment">#  - ::1                # In this example, access is allowed only for IPv4 network 127.0.0.1, and for IPv6 network ::1.</span><br><span class="hljs-number">36</span>                           <span class="hljs-comment"># It also support CIDR like 192.168.1.0/24 and 2001:0db8::/32</span><br></code></pre></td></tr></table></figure><ul><li>启动Dashboard服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start apisix-dashboard.service<br></code></pre></td></tr></table></figure><h2 id="4-安装Prometheus"><a href="#4-安装Prometheus" class="headerlink" title="4. 安装Prometheus"></a>4. 安装Prometheus</h2><h3 id="4-1-下载-amp-安装-amp-运行"><a href="#4-1-下载-amp-安装-amp-运行" class="headerlink" title="4.1 下载&amp;安装&amp;运行"></a>4.1 下载&amp;安装&amp;运行</h3><ul><li>拉取prometheus镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull prom/prometheus:v2.37.1<br></code></pre></td></tr></table></figure><ul><li>尝试运行容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=prometheus -p 9090:9090 prom/prometheus:v2.37.1<br></code></pre></td></tr></table></figure><p>执行后会报错9090端口已经被占用，查了一下使用情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost data]# netstat -anp | grep 9090<br>tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN      121999/nginx: maste<br><br>[root@localhost data]# netstat -anp | grep 121999<br>tcp        0      0 0.0.0.0:9080            0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp        0      0 0.0.0.0:9443            0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp        0      0 127.0.0.1:9091          0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp6       0      0 :::9080                 :::*                    LISTEN      121999/nginx: maste <br>tcp6       0      0 :::9443                 :::*                    LISTEN      121999/nginx: maste <br>unix  3      [ ]         STREAM     CONNECTED     568778   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568773   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568775   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568779   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568774   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568772   121999/nginx: maste<br></code></pre></td></tr></table></figure><p>是apisix主服务占用了9090端口，因此需要修改prometheus的web服务监听端口为19090；</p><p>注意：执行前删除刚刚创建失败的prometheus容器，上面一步也可以使用 <code>docker pull</code> 拉取镜像不创建容器；</p><ul><li>在宿主机创建prometheus配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/prometheus/data<br>cd /usr/local/prometheus/data<br>vim prometheus.yaml<br></code></pre></td></tr></table></figure><ul><li>修建如下配置项</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">60s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">60s</span><br>    <br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;127.0.0.1:19090&quot;</span>]<br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br></code></pre></td></tr></table></figure><p>注意：上面的 <code>job_name:&quot;prometheus&quot;</code> 配置只是一个采集目标端口，用于自检，并不是prom-web的开放端口配置。后续可以在 <code>http://&lt;ip&gt;:&lt;port&gt;/targets?search=</code> 中看到该配置的效果；</p><ul><li>运行prometheus容器<ul><li>–net&#x3D;host：与宿主机共享同一个网络</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --name=prometheus \<br>    --net=host \<br>    -v /usr/local/prometheus/data:/data \<br>    prom/prometheus:v2.37.1 \<br>    --config.file=/data/prometheus.yaml \<br>    --web.listen-address=:19090<br></code></pre></td></tr></table></figure><ul><li>web访问地址：http:&#x2F;&#x2F;&lt;ip&gt;:19090<ul><li>如果不能访问看【设置防火墙】一节，放通19090端口给外网访问</li></ul></li></ul><h3 id="4-2-APISIX接入Prometheus"><a href="#4-2-APISIX接入Prometheus" class="headerlink" title="4.2 APISIX接入Prometheus"></a>4.2 APISIX接入Prometheus</h3><ul><li><p>查看APISIX配置，找到提供给prom采集数据的接口及路径</p><ul><li>配置文件：conf&#x2F;config-default.yaml</li><li>开放端口：9091</li><li>开放路径：&#x2F;apisix&#x2F;prometheus&#x2F;metrics</li></ul></li><li><p>修改prometheus.yaml，添加APISIX监控端口</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-string">......</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;apisix&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/apisix/prometheus/metrics</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9091&quot;</span>]<br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;apisix&quot;</span><br></code></pre></td></tr></table></figure><ul><li>重启prometheus，可以在 <a href="http://192.168.142.129:19090/targets?search=">http://192.168.142.129:19090/targets?search=</a> 路径查看是否添加成功</li></ul><p><img src="screenshot-20220913-203233.png"></p><h2 id="5-安装Grafana"><a href="#5-安装Grafana" class="headerlink" title="5. 安装Grafana"></a>5. 安装Grafana</h2><h3 id="5-1-下载-amp-安装-amp-运行"><a href="#5-1-下载-amp-安装-amp-运行" class="headerlink" title="5.1 下载&amp;安装&amp;运行"></a>5.1 下载&amp;安装&amp;运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=grafana -p 3000:3000 grafana/grafana:9.1.4<br></code></pre></td></tr></table></figure><ul><li>重启docker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li><p>找到grafana的容器重新运行</p></li><li><p>web访问地址：http:&#x2F;&#x2F;&lt;ip&gt;:3000</p></li><li><p>初始账号密码：admin&#x2F;admin</p></li></ul><h3 id="5-2-Grafana接入Prometheus"><a href="#5-2-Grafana接入Prometheus" class="headerlink" title="5.2 Grafana接入Prometheus"></a>5.2 Grafana接入Prometheus</h3><ul><li><p>配置apisix监控样式：</p><ul><li>下载json：<a href="https://github.com/apache/apisix/tree/2.13.3/docs/assets/other/json">https://github.com/apache/apisix/tree/2.13.3/docs/assets/other/json</a></li><li>配置promtheus数据源</li></ul><p><img src="screenshot-20220913-182222.png"></p><ul><li>填写prometheus访问地址</li></ul><p><img src="screenshot-20220913-182339.png"></p><ul><li>导入apisix-dashboard样式json文件</li></ul><p><img src="screenshot-20220913-182509.png"></p><ul><li>数据源选择刚刚添加好的prometheus</li></ul><p><img src="screenshot-20220913-182528.png"></p><ul><li>保存得到最终效果如下：</li></ul><p><img src="screenshot-20220913-203722.png"></p></li></ul><h3 id="5-3-Grafana嵌入APISIX"><a href="#5-3-Grafana嵌入APISIX" class="headerlink" title="5.3 Grafana嵌入APISIX"></a>5.3 Grafana嵌入APISIX</h3><ul><li>进入容器，修改grafana配置，使之运行匿名登录及嵌入浏览</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it --user root &lt;容器id&gt; /bin/bash<br></code></pre></td></tr></table></figure><ul><li>编辑 defaults.ini 文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /conf/defaults.ini<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 允许嵌入浏览</span><br><span class="hljs-attr">allow_embedding</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 允许匿名登录</span><br><span class="hljs-section">[auth.anonymous]</span><br><span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="6-设置防火墙"><a href="#6-设置防火墙" class="headerlink" title="6. 设置防火墙"></a>6. 设置防火墙</h2><ul><li>如果之前disable过防火墙，需要加上这步，否则不需要</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shel">systemctl unmask firewalld.service<br>systemctl start firewalld.service<br></code></pre></td></tr></table></figure><ul><li>放通9000、9080端口<ul><li>9000端口用于访问APISIX-Dashboard</li><li>9080端口用于访问APISIX网关入口</li><li>19090端口用于访问Prometheus-WEB后台</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=9000/tcp --permanent<br>firewall-cmd --zone=public --add-port=9080/tcp --permanent<br>firewall-cmd --zone=public --add-port=19090/tcp --permanent<br></code></pre></td></tr></table></figure><ul><li>防火墙重新加载配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul><li><a href="https://blog.csdn.net/ichen820/article/details/117930543">如何更改prometheus监控系统启动的默认端口号</a></li><li><a href="https://blog.csdn.net/qq_42883074/article/details/114499518">prometheus使用 (二) 监控主机节点</a></li><li><a href="https://juejin.cn/post/7076829002224107551">APISIX+grafana网关安装全记录</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>apisix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apisix</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APISIX-2.13.3-路由与插件</title>
    <link href="/2022/09/02/apisix/APISIX-2.13.3-Function/"/>
    <url>/2022/09/02/apisix/APISIX-2.13.3-Function/</url>
    
    <content type="html"><![CDATA[<h1 id="APISIX-2-13-3-路由与插件"><a href="#APISIX-2-13-3-路由与插件" class="headerlink" title="APISIX-2.13.3-路由与插件"></a>APISIX-2.13.3-路由与插件</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>本文是基于官方使用说明，结合实践的过程记录。</p><ul><li>官方使用说明：<a href="https://apisix.apache.org/zh/docs/apisix/2.13/architecture-design/apisix/">https://apisix.apache.org/zh/docs/apisix/2.13/architecture-design/apisix/</a></li></ul></li><li><p>客户端实验平台：windows10</p></li><li><p>http压力测试工具：Apache Bench VS16</p></li></ul><h2 id="1-路由基础"><a href="#1-路由基础" class="headerlink" title="1. 路由基础"></a>1. 路由基础</h2><h3 id="1-1-前提准备"><a href="#1-1-前提准备" class="headerlink" title="1.1. 前提准备"></a>1.1. 前提准备</h3><ul><li><p>简单的http测试服务，使用go快速编写，提供&#x2F;ping1<del>&#x2F;ping3、&#x2F;test1</del>test3接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>port, flag := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>]<br><br>http.HandleFunc(<span class="hljs-string">&quot;/ping1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ping1_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/ping2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ping2_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/ping3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ping3_&quot;</span> + flag))<br>&#125;)<br><br>http.HandleFunc(<span class="hljs-string">&quot;/test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test1_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test2_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/test3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test3_&quot;</span> + flag))<br>&#125;)<br><br>http.ListenAndServe(<span class="hljs-string">&quot;:&quot;</span>+port, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build main.go<br>.\main.exe 9101 A &amp;<br>.\main.exe 9102 B &amp;<br>.\main.exe 9103 C &amp;<br></code></pre></td></tr></table></figure></li><li><p>测试过程中加入prometheus监控插件</p></li></ul><h3 id="1-2-路径路由"><a href="#1-2-路径路由" class="headerlink" title="1.2. 路径路由"></a>1.2. 路径路由</h3><ul><li><p>添加2组 <strong>上游</strong> 配置，配置如下：（这里只摘抄json格式配置，也可以在APISIX Dashboard中添加）</p></li><li><p>使用三个相同的服务节点，提供相同的<code>http-GET</code>接口组，绑定2组 <strong>上游</strong> 配置</p><ul><li><strong>ping接口组</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 三组节点，分流权重都是1</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 服务所在IP地址</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9102</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 均衡负载算法：带权轮询</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping接口组&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 上游组名称</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-comment">// 连接池配置，默认值</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test接口组</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9102</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>最终得到结果：</li></ul><p><img src="image-20220915140858565.png"></p></li><li><p>添加2组 <strong>路由</strong> 配置，配置如下：（这里只摘抄json格式配置，也可以在APISIX Dashboard中添加）</p><ul><li><strong>ping接口组路由</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/ping*&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 匹配路由</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping接口组路由&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 插件组：添加prometheus</span><br>        <span class="hljs-attr">&quot;prometheus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425504991357175601&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 绑定ping接口组</span><br>    <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;API_VERSION&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>  <span class="hljs-comment">// 发布状态</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test接口组路由</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/test*&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 匹配路由</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组路由&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;prometheus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 绑定test接口组</span><br>    <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;API_VERSION&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>  <span class="hljs-comment">// 未发布状态</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>最终得到结果：</li></ul><p><img src="screenshot-20220915-141401.png"></p></li><li><p>请求测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_A<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_B<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_C<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_A<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/test1<br>&#123;&quot;error_msg&quot;:&quot;404 Route Not Found&quot;&#125;<br>&#x27;404&#x27;<br></code></pre></td></tr></table></figure><ul><li><strong>ping接口组路由</strong> 成功过滤了未匹配路径的请求；后续发布 <strong>test接口组路由</strong> 可以看到 &#x2F;test1 可以请求成功；</li><li><strong>ping接口组</strong> 上游配置均衡负载算法生效；</li></ul></li></ul><h3 id="1-3-域名路由"><a href="#1-3-域名路由" class="headerlink" title="1.3. 域名路由"></a>1.3. 域名路由</h3><ul><li><p>添加并发布2组 <strong>路由</strong> 配置，并下架1.2中配置的路径路由组，配置如下</p><p><img src="image-20220915162132387.png"></p></li><li><p>在请求端上添加 <a href="http://www.ping_service.com/">www.ping_service.com</a> 与 <a href="http://www.test_service.com/">www.test_service.com</a> 的域名解析</p></li><li><p>请求测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl.exe -I http://www.ping_service.com:9080/test1<br>HTTP/1.1 404 Not Found<br>Date: Thu, 15 Sep 2022 08:27:23 GMT<br>Content-Type: text/plain; charset=utf-8<br>Connection: keep-alive<br>Server: APISIX/2.13.3<br><br>curl.exe http://www.ping_service.com:9080/ping1<br>ping1_A<br><br>curl.exe http://www.ping_service.com:9080/ping1<br>ping1_B<br><br>curl.exe http://www.ping_service.com:9080/ping1<br>ping1_C<br><br>curl.exe http://www.test_service.com:9080/test1<br>test1_B<br></code></pre></td></tr></table></figure><ul><li><p><strong>ping接口组路由2</strong> 成功过滤了未匹配域名+路径的请求；后续尝试的 <strong>test接口组路由2</strong> 可以看到 &#x2F;test1 可以请求成功；</p></li><li><p><strong>ping接口组</strong> 上游配置均衡负载算法生效；</p></li></ul></li></ul><h3 id="1-4-异常场景"><a href="#1-4-异常场景" class="headerlink" title="1.4. 异常场景"></a>1.4. 异常场景</h3><h4 id="1-4-1-目标节点失活"><a href="#1-4-1-目标节点失活" class="headerlink" title="1.4.1. 目标节点失活"></a>1.4.1. 目标节点失活</h4><ul><li><p>复用1.3的配置，将端口是9103的服务关停，此时<strong>ping接口组</strong>中目标节点只有9101与9102存活</p></li><li><p>修改<strong>ping接口组-连接超时</strong>配置为<strong>6</strong>s</p></li><li><p>使用curl不断请求 <a href="http://www.ping_service.com:9080/ping1">http://www.ping_service.com:9080/ping1</a> 接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; --connect-timeout 10 -m 20 http://www.ping_service.com:9080/ping1<br>ping1_A<br>===================================================<br>   time_namelookup: 0.005903s<br>      time_connect: 0.006257s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.006287s<br>time_starttransfer: 2.015412s<br>    speed_download: 3byte/s<br>---------------------------------------------------<br>        time_total: 2.015588s<br>===================================================<br><br><br>curl -w &quot;@curl_format.txt&quot; --connect-timeout 10 -m 20 http://www.ping_service.com:9080/ping1<br>ping1_B<br>===================================================<br>   time_namelookup: 0.005980s<br>      time_connect: 0.006373s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.006407s<br>time_starttransfer: 0.019240s<br>    speed_download: 359byte/s<br>---------------------------------------------------<br>        time_total: 0.019460s<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>可见<strong>连接超时配置不起效果</strong>，但不排除是curl的–connect-timeout设置问题，但是用chrome请求浏览器依然复现此问题；</li><li>有1个节点失效后会轮询到下一节点尝试，间隔时间2s，但不会自动摘除；</li></ul></li><li><p>对这个异常场景，官方是有解决方案的，这时添加节点<strong>健康检查</strong>配置</p><ul><li><p>先来看<a href="https://apisix.apache.org/zh/docs/apisix/2.13/health-check/#upstream-%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5">官方说明</a>的描述</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">Apache APISIX 的健康检查使用 lua-resty-healthcheck 实现。<br><br>注意:<br>- 只有在 upstream 被请求时才会开始健康检查，如果 upstream 被配置但没有被请求，不会触发启动健康检查。<br>- 如果没有健康的节点，那么请求会继续发送给上游。<br>- 如果 upstream 中只有一个节点时不会触发启动健康检查，该唯一节点无论是否健康，请求都将转发给上游。<br>- 主动健康检查是必须的，这样不健康的节点才会恢复。<br></code></pre></td></tr></table></figure></li><li><p><strong>首先这里有个疑问？为什么节点组只能配一个节点的监控检查？</strong></p><ul><li>查阅<a href="https://apisix.apache.org/zh/docs/apisix/2.13/health-check/#%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B">官方文档</a>示例后，解除疑惑，原来端口不是必填项，所以这个场景只需要填写域名即可；如果包含多ip的情况，host填写域名即可；</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;active&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;concurrency&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;healthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">302</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;successes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;http_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/check&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;unhealthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">429</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">404</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">501</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">502</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">503</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">504</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">505</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tcp_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;timeouts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ......<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>在9103服务的代码中添加&#x2F;check接口</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">http.HandleFunc(<span class="hljs-string">&quot;/check&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>    log.Println(time.Now().Format(time.RFC3339Nano))<br>    _, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ok&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>请求关停服务的&#x2F;check接口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; 192.168.4.72:9103/check<br>ok<br>===================================================<br>   time_namelookup: 0.000054s<br>      time_connect: 0.000686s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.000729s<br>time_starttransfer: 0.001069s<br>    speed_download: 1657byte/s<br>---------------------------------------------------<br>        time_total: 0.001207s<br>         http_code: 500<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>持续请求网关的&#x2F;ping1接口<ul><li>观察到的现象是首次请求到9103时会等待超时，且触发监控检查，如官方描述：<strong>监控检查需要有请求时才触发</strong>，验证<strong>健康检查-异常节点摘除</strong>功能正常；</li><li>15秒后请求不再打到9103节点，请求响应时间恢复正常；</li><li>重启9103节点服务，会收到2次&#x2F;check请求，然后恢复接收&#x2F;ping1请求，验证<strong>健康检查-异常节点恢复</strong>功能正常；</li></ul></li></ul><h4 id="1-4-2-HTTP响应超时"><a href="#1-4-2-HTTP响应超时" class="headerlink" title="1.4.2. HTTP响应超时"></a>1.4.2. HTTP响应超时</h4><ul><li>写一个简单的超时接口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/time_out&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">20</span>)  <span class="hljs-comment">// 20秒返回</span><br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;time_out&quot;</span>))<br>&#125;)<br>http.ListenAndServe(<span class="hljs-string">&quot;:9120&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先直接请求到超时服务查看结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; 127.0.0.1:9120/time_out<br>time_out<br>===================================================<br>   time_namelookup: 0.000055s<br>      time_connect: 0.000654s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.000696s<br>time_starttransfer: 20.003177s<br>    speed_download: 0byte/s<br>---------------------------------------------------<br>        time_total: 20.003387s<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>在APISIX配置一组上游节点+路由配置，提供超时测试</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/*&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;time_out路由&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425650610830837553&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9120</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;time_out接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求APISIX接口路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; http://192.168.142.129:9080/time_out<br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;504 Gateway Time-out&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;504 Gateway Time-out&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br>===================================================<br>   time_namelookup: 0.000056s<br>      time_connect: 0.000833s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.000876s<br>time_starttransfer: 10.147496s<br>    speed_download: 16byte/s<br>---------------------------------------------------<br>        time_total: 10.149126s<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>验证配置响应超时时间有效</li></ul><h2 id="2-插件基础"><a href="#2-插件基础" class="headerlink" title="2. 插件基础"></a>2. 插件基础</h2><h3 id="2-1-插件作用域"><a href="#2-1-插件作用域" class="headerlink" title="2.1. 插件作用域"></a>2.1. 插件作用域</h3><h4 id="2-1-1-全局插件"><a href="#2-1-1-全局插件" class="headerlink" title="2.1.1. 全局插件"></a>2.1.1. 全局插件</h4><ul><li><p>顾名思义该插件组全局生效，前提是已经搭建好prometheus+grafana与apisix的监控环境</p></li><li><p>复用1.3中的既有配置</p></li><li><p>添加prometheus全局插件</p></li><li><p>连续请求 <a href="http://www.test_service.com:9080/test1">http://www.test_service.com:9080/test1</a> 接口观察请求数涨幅</p><p><img src="screenshot-20220915-165429.png"></p></li></ul><h4 id="2-1-2-局部插件"><a href="#2-1-2-局部插件" class="headerlink" title="2.1.2. 局部插件"></a>2.1.2. 局部插件</h4><ul><li>顾名思义该插件只在绑定的局部链路下生效</li><li>局部插件可以在 <strong>路由&#x2F;服务&#x2F;消费者</strong> 中绑定<ul><li>多个<strong>路由</strong>可以绑定同一个<strong>服务</strong>，避免相同的插件组需要在多个路由中重复配置</li><li><strong>消费者</strong>控制权限类插件的能力，<strong>路由</strong>控制权限类插件是否在本路由生效，因此<strong>消费者</strong>与<strong>路由</strong>无直接绑定关系</li></ul></li></ul><h3 id="2-2-插件类型"><a href="#2-2-插件类型" class="headerlink" title="2.2. 插件类型"></a>2.2. 插件类型</h3><h4 id="2-2-1-路由流控"><a href="#2-2-1-路由流控" class="headerlink" title="2.2.1. 路由流控"></a>2.2.1. 路由流控</h4><ul><li><strong>窗口时间请求数限制</strong></li><li>复用1.3中的既有路由配置，绑定**<a href="https://apisix.apache.org/zh/docs/apisix/2.13/plugins/limit-count/">limit-count</a>**插件，窗口时间为1s，限制请求数2，设置如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;limit-count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;allow_degradation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 窗口期内最大请求数</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;key_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;var&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 可以设置针对header中的某个key(如remote_addr)来实现针对单个ip的流控</span><br>        <span class="hljs-attr">&quot;policy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 计数器被以内存方式保存在节点本地，默认选项;这个插件支持使用Redis集群，从而可以跨节点共享结果，通常用它来完成全局限速</span><br>        <span class="hljs-attr">&quot;rejected_code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">503</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 超量后返回http-status-code</span><br>        <span class="hljs-attr">&quot;show_limit_quota_header&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// http-header是否携带流控信息</span><br>        <span class="hljs-attr">&quot;time_window&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>  <span class="hljs-comment">// 窗口时间(s)</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>快速连续请求 <a href="http://www.ping_service.com:9080/ping1">http://www.ping_service.com:9080/ping1</a> 接口得到如下结果：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -I http://www.ping_service.com:9080/ping1  <br>HTTP/1.1 200 OK                                   <br>Content-Type: text/plain; charset=utf-8           <br>Content-Length: 7                                 <br>Connection: keep-alive                            <br>X-RateLimit-Limit: 2      # 限制2个请求<br>X-RateLimit-Remaining: 1  # 剩余放通请求数<br>Date: Fri, 16 Sep 2022 10:01:07 GMT               <br>Server: APISIX/2.13.3                             <br><br>curl -I http://www.ping_service.com:9080/ping1  <br>HTTP/1.1 200 OK                                   <br>Content-Type: text/plain; charset=utf-8           <br>Content-Length: 7                                 <br>Connection: keep-alive                            <br>X-RateLimit-Limit: 2      # 限制2个请求<br>X-RateLimit-Remaining: 0  # 剩余放通请求数<br>Date: Fri, 16 Sep 2022 10:01:07 GMT               <br>Server: APISIX/2.13.3<br><br>curl -I http://www.ping_service.com:9080/ping1  <br>HTTP/1.1 503 Service Temporarily Unavailable  # 超量返回预设错误码<br>Date: Fri, 16 Sep 2022 10:01:07 GMT<br>Content-Type: text/html; charset=utf-8            <br>Content-Length: 194                               <br>Connection: keep-alive<br>Server: APISIX/2.13.3<br></code></pre></td></tr></table></figure><h4 id="2-2-2-黑白名单"><a href="#2-2-2-黑白名单" class="headerlink" title="2.2.2. 黑白名单"></a>2.2.2. 黑白名单</h4><ul><li><p>包含多个插件，当前以最常用的 ip黑名单 测试</p></li><li><p>复用1.3中的既有路由配置，绑定**<a href="https://apisix.apache.org/zh/docs/apisix/plugins/ip-restriction/">ip-restriction</a>**插件，设置如下：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;ip-restriction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Do you want to do something bad?&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义返回信息</span><br>    <span class="hljs-attr">&quot;whitelist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;192.168.4.72&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求接口结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -I http://www.ping_service.com:9080/ping1<br>HTTP/1.1 403 Forbidden<br>Date: Mon, 19 Sep 2022 09:08:44 GMT<br>Content-Type: text/plain; charset=utf-8<br>Connection: keep-alive<br>Server: APISIX/2.15.0<br><br>curl http://www.ping_service.com:9080/ping1<br>&#123;&quot;message&quot;:&quot;Do you want to do something bad?&quot;&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-登录鉴权"><a href="#2-2-3-登录鉴权" class="headerlink" title="2.2.3. 登录鉴权"></a>2.2.3. 登录鉴权</h4><ul><li><p>包含多种登录态校验插件，当前以最常用的 jwt 测试</p></li><li><p>配置消费者，配置**<a href="https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/">jwt</a>**插件</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jwt_test&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;jwt-auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">86400</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;data&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;secret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>复用1.3中的既有路由配置，绑定**<a href="https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/">jwt</a>**插件，设置如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;jwt-auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><ul><li>尝试不携带 jwt-token 信息请求</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; http://www.ping_service.com:9080/ping1<br>&#123;&quot;message&quot;:&quot;Missing JWT token in request&quot;&#125;<br><br>===================================================<br>   time_namelookup: 0.006392s<br>      time_connect: 0.006845s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.006875s<br>time_starttransfer: 0.007312s<br>    speed_download: 5687byte/s<br>---------------------------------------------------<br>        time_total: 0.007560s<br>         http_code: 401<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>尝试携带 jwt-token 信息（使用url参数携带）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://www.ping_service.com:9080/ping1?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRh IjpbXSwiaWF0IjoxNjYzNTgxMTExLCJleHAiOjE2NjM1ODQ1OTksImF1ZCI6IiIsImlzcyI6IiIsInN1YiI6IiJ9.nMskTlYVx2PbHDcELnchdDBgespNT_bX3ikTWoQ6X6U<br>ping1_A<br></code></pre></td></tr></table></figure><h4 id="2-2-4-镜像请求"><a href="#2-2-4-镜像请求" class="headerlink" title="2.2.4. 镜像请求"></a>2.2.4. 镜像请求</h4><ul><li>代理镜像插件，该插件提供了镜像客户端请求的能力。</li><li>修改 &#x2F;test 的路由插件配置：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;proxy-mirror&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://192.168.4.72:9104&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sample_ratio&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.01</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>修改 &#x2F;test 的上游只保留一个节点：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>在 9104 节点可以获取到**1%**的请求量</li></ul><h2 id="3-进阶能力"><a href="#3-进阶能力" class="headerlink" title="3. 进阶能力"></a>3. 进阶能力</h2><h3 id="3-1-金丝雀-灰度-发布"><a href="#3-1-金丝雀-灰度-发布" class="headerlink" title="3.1. 金丝雀(灰度)发布"></a>3.1. 金丝雀(灰度)发布</h3><h4 id="3-1-1-编写简单的批量发送测试客户端"><a href="#3-1-1-编写简单的批量发送测试客户端" class="headerlink" title="3.1.1. 编写简单的批量发送测试客户端"></a>3.1.1. 编写简单的批量发送测试客户端</h4><ul><li>利用http-header中的uid进行流量划分，实现恢复发布</li><li>uid范围[0-19]，方便观察</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">splitReqs</span><span class="hljs-params">(src []*http.Request, size <span class="hljs-type">int</span>)</span></span> [][]*http.Request &#123;<br><span class="hljs-keyword">if</span> src == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> [][]*http.Request&#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> (<br>j      <span class="hljs-type">int</span><br>length = <span class="hljs-built_in">len</span>(src)<br>res    = <span class="hljs-built_in">make</span>([][]*http.Request, <span class="hljs-number">0</span>)<br>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i += size &#123;<br>j += size<br><span class="hljs-keyword">if</span> j &gt; length &#123;<br>j = length<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, src[i:j])<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClient</span><span class="hljs-params">()</span></span> *http.Client &#123;<br><span class="hljs-keyword">return</span> &amp;http.Client&#123;<br>Transport: &amp;http.Transport&#123;<br>DialContext: (&amp;net.Dialer&#123;<br>Timeout:   <span class="hljs-number">30</span> * time.Second,<br>KeepAlive: <span class="hljs-number">30</span> * time.Second,<br>&#125;).DialContext,<br>MaxIdleConns:          <span class="hljs-number">100</span>,<br>IdleConnTimeout:       <span class="hljs-number">90</span> * time.Second,<br>TLSHandshakeTimeout:   <span class="hljs-number">10</span> * time.Second,<br>ExpectContinueTimeout: <span class="hljs-number">1</span> * time.Second,<br>&#125;,<br>Timeout: <span class="hljs-number">30</span> * time.Second,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>url, tmpCount := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>]<br>count, err := strconv.ParseInt(tmpCount, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>client := newClient()<br>reqs := <span class="hljs-built_in">make</span>([]*http.Request, <span class="hljs-number">0</span>, count)<br>userCount := <span class="hljs-number">20</span><br><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-type">int</span>(count); j++ &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; userCount; i++ &#123;<br>req, err := http.NewRequest(http.MethodGet, url, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>header := http.Header&#123;&#125;<br>header.Add(<span class="hljs-string">&quot;uid&quot;</span>, strconv.Itoa(i))<br>req.Header = header<br><br>reqs = <span class="hljs-built_in">append</span>(reqs, req)<br>&#125;<br>&#125;<br><br>reqsGroup := splitReqs(reqs, userCount)<br><span class="hljs-keyword">for</span> _, subReqs := <span class="hljs-keyword">range</span> reqsGroup &#123;<br>w := sync.WaitGroup&#123;&#125;<br>w.Add(<span class="hljs-built_in">len</span>(subReqs))<br><br><span class="hljs-keyword">for</span> _, req := <span class="hljs-keyword">range</span> subReqs &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *http.Request)</span></span> &#123;<br>_, err := client.Do(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>w.Done()<br>&#125;(req)<br>&#125;<br>w.Wait()<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-1-2-方案一"><a href="#3-1-2-方案一" class="headerlink" title="3.1.2. 方案一"></a>3.1.2. 方案一</h4><ul><li><p><strong>一致性哈希均衡负载+权重</strong></p></li><li><p>修改 &#x2F;test1 的上游配置，使用一致性哈希均衡负载</p><ul><li>9101~9103节点权重设置：3</li><li>9104节点权重设置：1（灰度节点）</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9102</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9104</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;chash&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hash_on&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;header&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uid&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ......</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="screenshot-20220920-114408.png"></p><ul><li><p>请求 &#x2F;test1 接口，查看各服务日志</p><ul><li>9101节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br></code></pre></td></tr></table></figure><ul><li>9102节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 17<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 2 <br>2022/09/20 11:40:41 test1_B | uid: 19<br>2022/09/20 11:40:41 test1_B | uid: 19<br>2022/09/20 11:40:41 test1_B | uid: 2 <br>2022/09/20 11:40:41 test1_B | uid: 17<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 2 <br>2022/09/20 11:40:41 test1_B | uid: 19<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 17<br></code></pre></td></tr></table></figure><ul><li>9103节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs she">......<br>2022/09/20 11:40:41 test1_C | uid: 18<br>2022/09/20 11:40:41 test1_C | uid: 10<br>2022/09/20 11:40:41 test1_C | uid: 11<br>2022/09/20 11:40:41 test1_C | uid: 18<br>2022/09/20 11:40:41 test1_C | uid: 1<br>2022/09/20 11:40:41 test1_C | uid: 7<br>2022/09/20 11:40:41 test1_C | uid: 9<br>2022/09/20 11:40:41 test1_C | uid: 10<br>2022/09/20 11:40:41 test1_C | uid: 4<br>2022/09/20 11:40:41 test1_C | uid: 3<br>2022/09/20 11:40:41 test1_C | uid: 11<br>2022/09/20 11:40:41 test1_C | uid: 6<br>2022/09/20 11:40:41 test1_C | uid: 15<br>2022/09/20 11:40:41 test1_C | uid: 14<br></code></pre></td></tr></table></figure><ul><li>9104节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 8<br></code></pre></td></tr></table></figure></li><li><p>接下来把配置摘到2个节点：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9104</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ......</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>得到了正常的流量分配，9104节点的请求信息如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 13:38:32 test1_D | uid: 16<br>2022/09/20 13:38:32 test1_D | uid: 8<br>2022/09/20 13:38:32 test1_D | uid: 16<br>2022/09/20 13:38:32 test1_D | uid: 16<br>2022/09/20 13:38:32 test1_D | uid: 8<br>2022/09/20 13:38:32 test1_D | uid: 8<br>2022/09/20 13:38:32 test1_D | uid: 16<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong><ul><li><p>使用一致性哈希均衡负载进行灰度发布，<strong>权重不生效</strong>；</p></li><li><p>如果开启健康检查，触发节点摘除的场景，因为节点数量变化，流量有可能会被分到非灰度节点，<strong>流量不稳定</strong>；</p></li><li><p>如果结合k8s对上游节点进行均衡负载，即上游节点其实为k8s均衡负载服务，则<strong>可以规避上述问题</strong>，但会增加一层转发损耗；</p></li><li><p>在测试过程中，添加&#x2F;删除&#x2F;修改路由节点，对请求的响应率没有可见性的影响；</p></li></ul></li></ul><h4 id="3-1-3-方案二-推荐"><a href="#3-1-3-方案二-推荐" class="headerlink" title="3.1.3. 方案二(推荐)"></a>3.1.3. 方案二(推荐)</h4><ul><li><p><strong>traffic-split插件</strong></p></li><li><p>修改 <strong>test接口组</strong> 上游配置中的节点数量为2个：9101、9102</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;active&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;concurrency&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;healthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">302</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;successes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;http_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/check&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;unhealthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">429</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">404</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">501</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">502</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">503</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">504</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">505</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tcp_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;timeouts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>新增 <strong>test接口组（灰度）</strong> 上游配置中的节点数量为2个：9103、9104</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9104</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;active&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;concurrency&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;healthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">302</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;successes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;http_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/check&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;unhealthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">429</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">404</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">501</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">502</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">503</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">504</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">505</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tcp_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;timeouts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组（灰度）&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="screenshot-20220920-154757.png"></p><ul><li>在 &#x2F;test 路由组配置traffic-split插件，上游425605109443987249与上游426356608394594097的流量比例为9:1</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/test*&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口路由组2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;www.test_service.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;traffic-split&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;weighted_upstreams&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9</span><br>                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;426356608394594097&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;API_VERSION&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>使用3.1.1的批量发送工具发送100个请求测试流量分布</p><ul><li>9101和9102节点各接收到45个请求</li><li>9103和9104节点个接收到5个请求</li><li><strong>符合分流权重配置要求</strong></li><li>因为没有配置匹配规则，因此<strong>流量是随机划分</strong>的</li></ul></li><li><p>加入匹配规则控制灰度用户流量精准投递到灰度节点</p><ul><li>匹配规则插件文档：<a href="https://github.com/api7/lua-resty-expr#operator-list">lua-resty-expr</a></li></ul><table><thead><tr><th>operator</th><th>description</th><th>example</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>equal</td><td>{“arg_name”, “&#x3D;&#x3D;”, “json”}</td></tr><tr><td>~&#x3D;</td><td>not equal</td><td>{“arg_name”, “~&#x3D;”, “json”}</td></tr><tr><td>&gt;</td><td>greater than</td><td>{“arg_age”, “&gt;”, 24}</td></tr><tr><td>&lt;</td><td>less than</td><td>{“arg_age”, “&lt;”, 24}</td></tr><tr><td>~~</td><td>Regular match</td><td>{“arg_name”, “~~”, “[a-z]+”}</td></tr><tr><td>~*</td><td>Case insensitive regular match</td><td>{“arg_name”, “~*”, “[a-z]+”}</td></tr><tr><td>in</td><td>find in array</td><td>{“arg_name”, “in”, {“1”,”2”}}</td></tr><tr><td>has</td><td>left value array has value in the right</td><td>{“graphql_root_fields”, “has”, “repo”}</td></tr><tr><td>!</td><td>reverse the result</td><td>{“arg_name”, “!”, “~~”, “[a-z]+”}</td></tr><tr><td>ipmatch</td><td>ip address match</td><td>{“remote_addr”, “ipmatch”, {“127.0.0.1”, “192.168.0.0&#x2F;16”}}</td></tr></tbody></table><ul><li>修改 &#x2F;test 路由配置，使用正则表达式过滤出uid尾号为0的请求分配到灰度上游</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;traffic-split&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;vars&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                                <span class="hljs-punctuation">[</span><br>                                    <span class="hljs-string">&quot;http_uid&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;~~&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;[0$]&quot;</span><br>                                <span class="hljs-punctuation">]</span><br>                            <span class="hljs-punctuation">]</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;weighted_upstreams&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;426356608394594097&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>使用3.1.1的批量发送工具发送100个请求测试流量分布</p><ul><li>尾号为0的uid全部分流到9103、9104节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:28 test1_C | uid: 10<br>2022/09/20 16:56:28 test1_C | uid: 0<br>2022/09/20 16:56:28 test1_C | uid: 10<br></code></pre></td></tr></table></figure></li><li><p><strong>结论：</strong></p><ul><li>使用<strong>traffic-split插件</strong>进行灰度发布符合业务要求</li><li>插件对上游配置无侵入性修改，修改、删除灰度分流只需要改动路由插件配置或关停插件</li></ul></li></ul><h3 id="3-2-插件开发"><a href="#3-2-插件开发" class="headerlink" title="3.2. 插件开发"></a>3.2. 插件开发</h3><ul><li><p>开发自定义插件分<strong>lua插件</strong>与<strong>外部插件</strong>，<strong>新增、修改、删除插件均不支持热加载</strong></p></li><li><p>lua插件调用方式为内部调用；</p><ul><li>lua插件开发思路参考：**<a href="https://apisix.apache.org/zh/docs/apisix/plugin-develop/">插件开发</a>**</li></ul></li><li><p>扩展插件调用方式为RPC调用；</p><ul><li>外部插件按执行时序分三类，见：**<a href="https://apisix.apache.org/zh/docs/apisix/external-plugin/">External Plugin</a>**</li><li><strong>插件稳定性需要进一步测试，不建议立即使用</strong></li><li>RPC通信配置需要提前协商配置，避免后续需要重启APISIX</li></ul></li></ul><h4 id="3-2-1-外部插件-Go"><a href="#3-2-1-外部插件-Go" class="headerlink" title="3.2.1. 外部插件-Go"></a>3.2.1. 外部插件-Go</h4><ul><li><p>Go插件：<a href="https://github.com/apache/apisix-go-plugin-runner"><strong>apisix-go-plugin-runner</strong></a></p></li><li><p>下载插件源码release-0.4版本–&gt;编译–&gt;复制到APISIX的docker容器中</p></li><li><p>修改APISIX配置文件：config.yaml，在末尾追加以下内容</p><ul><li>另一种外部插件加载方式，在下一小节使用</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ext-plugin:</span><br>  <span class="hljs-attr">cmd:</span> [<span class="hljs-string">&quot;/usr/local/apisix/plugins/go-runner&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>重启APISIX容器，查看APISIX启动日志，已显示有加载Go插件的日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022-09-21T05:56:42.968ZINFOplugin/plugin.go:73register plugin limit-req<br>2022-09-21T05:56:42.968ZINFOplugin/plugin.go:73register plugin response-rewrite<br>2022-09-21T05:56:42.968ZINFOplugin/plugin.go:73register plugin say<br>2022-09-21T05:56:42.968ZWARNserver/server.go:185conf cache ttl is 1h12m0s<br>2022-09-21T05:56:42.968ZWARNserver/server.go:193listening to /usr/local/apisix/conf/apisix-46.sock<br></code></pre></td></tr></table></figure><ul><li>复用1.3中的路由配置，将插件配置为 say 插件<ul><li><strong>注意：外部插件无法像内部插件一样生成插件图标显示在Dashboard的列表中</strong></li><li><strong>顺带一提：使用服务配置外部插件，绑定到上游，不生效</strong></li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ext-plugin-post-req&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;conf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;say&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;\&quot;body\&quot;:\&quot;hello\&quot;&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求 &#x2F;ping1 接口</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">curl.exe http<span class="hljs-punctuation">:</span><span class="hljs-comment">//www.ping_service.com:9080/ping1</span><br>hello<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong><ul><li>外部插件<strong>不支持冷加载</strong></li><li>外部插件只能通过修改json格式配置项方式控制</li><li>外部插件在服务配置中不生效</li></ul></li></ul><h4 id="3-2-2-自定义外部插件-Go"><a href="#3-2-2-自定义外部插件-Go" class="headerlink" title="3.2.2. 自定义外部插件-Go"></a>3.2.2. 自定义外部插件-Go</h4><ul><li>修改Go插件：<a href="https://github.com/apache/apisix-go-plugin-runner"><strong>apisix-go-plugin-runner</strong></a></li><li>添加以下文件：cmd&#x2F;go-runner&#x2F;plugins&#x2F;header_rewrite.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> plugins<br><br><span class="hljs-keyword">import</span> (<br>pkgHTTP <span class="hljs-string">&quot;github.com/apache/apisix-go-plugin-runner/pkg/http&quot;</span><br><span class="hljs-string">&quot;github.com/apache/apisix-go-plugin-runner/pkg/log&quot;</span><br><span class="hljs-string">&quot;github.com/apache/apisix-go-plugin-runner/pkg/plugin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>err := plugin.RegisterPlugin(&amp;HeaderRewrite&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to register plugin header_rewrite: %s&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// HeaderRewrite 意于重写http请求头</span><br><span class="hljs-keyword">type</span> HeaderRewrite <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Embed the default plugin here,</span><br><span class="hljs-comment">// so that we don&#x27;t need to reimplement all the methods.</span><br>plugin.DefaultPlugin<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HeaderRewrite)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;header_rewrite&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HeaderRewrite)</span></span> ParseConf(in []<span class="hljs-type">byte</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HeaderRewrite)</span></span> RequestFilter(conf <span class="hljs-keyword">interface</span>&#123;&#125;, w http.ResponseWriter, r pkgHTTP.Request) &#123;<br>r.Header().Set(<span class="hljs-string">&quot;X-GO-PLUGIN-TEST&quot;</span>, <span class="hljs-string">&quot;OK&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make build<br></code></pre></td></tr></table></figure><ul><li>修改APISIX配置config.yaml</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">ext-plugin<span class="hljs-punctuation">:</span><br>  path_for_test<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/tmp/x.sock&quot;</span><br></code></pre></td></tr></table></figure><ul><li>重启APISIX</li><li>添加环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export APISIX_LISTEN_ADDRESS=unix:/tmp/x.sock<br></code></pre></td></tr></table></figure><ul><li>运行go-runner</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">./go-runner run &amp;<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin fault-injection<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin header_rewrite<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin limit-req<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin response-rewrite<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin say<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZWARNserver/server.go<span class="hljs-punctuation">:</span><span class="hljs-number">185</span>conf cache ttl is <span class="hljs-number">1</span>h12m0s<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZWARNserver/server.go<span class="hljs-punctuation">:</span><span class="hljs-number">193</span>listening to /tmp/x.sock<br></code></pre></td></tr></table></figure><ul><li>复用1.3中的路由配置，将插件配置为 header_rewrite 插件<ul><li><strong>注意：外部插件无法像内部插件一样生成插件图标显示在Dashboard的列表中</strong></li><li><strong>顺带一提：使用服务配置外部插件，绑定到上游，不生效</strong></li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ext-plugin-post-req&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;conf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;header_rewrite&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求 &#x2F;ping2 接口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl.exe http://www.ping_service.com:9080/ping2<br></code></pre></td></tr></table></figure><ul><li>在 9101 中得到req-header，包含X-Go-Plugin-Test:[OK]</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/09/21 17:10:43 ping2_A | header: map[Accept:[*/*] User-Agent:[curl/7.83.1] X-Forwarded-For:[192.168.142.1] X-Forwarded-Host:[www.ping_service.com] X-Forwarded-Port:[9080] X-Forwarded-Proto:[http] X-Go-Plugin-Test:[OK] X-Real-Ip:[192.168.142.1]]<br></code></pre></td></tr></table></figure><ul><li>插件日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022-09-21T09:08:02.491ZINFOserver/server.go:108Client connected (unix)<br>2022-09-21T09:08:02.491ZINFOserver/server.go:124receive rpc type: 2 data length: 228<br>2022-09-21T09:08:02.491ZINFOplugin/plugin.go:120run plugin header_rewrite<br></code></pre></td></tr></table></figure><ul><li>模拟插件异常，杀死go-runner进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022-09-21T09:14:50.430ZWARNserver/server.go:245server receive terminated and exit<br></code></pre></td></tr></table></figure><ul><li>再次请求 &#x2F;ping2 接口，返回503。查看APISIX日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/09/21 09:15:28 [warn] 47#47: *38406 [lua] plugin.lua:901: run_plugin(): ext-plugin-post-req exits with http status code 503, client: 192.168.142.1, server: _, request: &quot;GET /ping2 HTTP/1.1&quot;, host: &quot;www.ping_service.com:9080&quot;<br>2022/09/21 09:15:28 [crit] 47#47: *38424 connect() to unix:/tmp/x.sock failed (2: No such file or directory), client: 192.168.142.1, server: _, request: &quot;GET /ping2 HTTP/1.1&quot;, host: &quot;www.ping_service.com:9080&quot;<br>2022/09/21 09:15:28 [error] 47#47: *38424 [lua] init.lua:841: phase_func(): failed to connect to the unix socket unix:/tmp/x.sock: no such file or directory, client: 192.168.142.1, server: _, request: &quot;GET /ping2 HTTP/1.1&quot;, host: &quot;www.ping_service.com:9080&quot;<br></code></pre></td></tr></table></figure><ul><li>重启go-runner，请求成功</li><li><strong>结论：</strong><ul><li>第一次配置外部插件时不支持热加载</li><li>go-runner进程必须有验活机制</li><li>在服务配置中不生效</li></ul></li></ul><h3 id="3-3-数据监控"><a href="#3-3-数据监控" class="headerlink" title="3.3. 数据监控"></a>3.3. 数据监控</h3><h4 id="3-3-1-采集-amp-观测"><a href="#3-3-1-采集-amp-观测" class="headerlink" title="3.3.1. 采集&amp;观测"></a>3.3.1. 采集&amp;观测</h4><ul><li>使用 Prometheus + Grafana 组合</li></ul><h4 id="3-3-2-指标"><a href="#3-3-2-指标" class="headerlink" title="3.3.2. 指标"></a>3.3.2. 指标</h4><p><img src="screenshot-20220923-182911.png"></p><h4 id="3-3-3-模拟测试"><a href="#3-3-3-模拟测试" class="headerlink" title="3.3.3. 模拟测试"></a>3.3.3. 模拟测试</h4><ul><li><strong>前提条件</strong><ul><li>1000RPS</li><li>请求到上文中<strong>test接口路由组2</strong>-ID：<strong>425637854408869681</strong></li></ul></li><li><strong>Nginx数据视窗</strong><ul><li>从请求速率一项可以看到RPS为1000</li></ul></li></ul><p><img src="screenshot-20220923-175134.png"></p><ul><li><strong>带宽视窗</strong><ul><li>从route一项可以看到 ID：425637854408869681 的带宽情况</li></ul></li></ul><p><img src="screenshot-20220923-175530.png"></p><ul><li><strong>HTTP视窗</strong><ul><li>可以看到开始请求的一瞬间延迟是最大</li><li>P90指标与P95指标很直观表现出链路延迟值</li></ul></li></ul><p><img src="image-20220923175909631.png"></p><ul><li><strong>Misc视窗</strong><ul><li>可以看到Etcd等组件的活跃情况</li></ul></li></ul><p><img src="screenshot-20220923-180357.png"></p><h4 id="3-3-4-告警"><a href="#3-3-4-告警" class="headerlink" title="3.3.4. 告警"></a>3.3.4. 告警</h4><ul><li>可以利用 Prometheus - AlertManager 的能力进行触发，此处不演示</li></ul>]]></content>
    
    
    <categories>
      
      <category>apisix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apisix</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-Error处理</title>
    <link href="/2022/05/23/golang/error/"/>
    <url>/2022/05/23/golang/error/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-Error处理"><a href="#Golang-Error处理" class="headerlink" title="Golang-Error处理"></a>Golang-Error处理</h1><p align="right">Lamber</p><p align="right">2022-05-23</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇基于GO 1.17版本代码进行阐释。</p><p>写过C&#x2F;C++的伙伴应该印象深刻，C&#x2F;C++的”错误”是围绕”错误码”定义的，比如C语言使用errno(一个整型)来表示错误及传达错误信息，常见的以-1表示。</p><p>这种设计导致了这个问题：</p><ul><li>当触发的错误所处的代码层级较深，且错误码又与其他类型错误相同时：编码者为了避免错误码被混淆，会在底层进行大量的错误码映射，直到将错误信息精妙地传递到展示层；或者直接将错误吞没不处理，打印错误日志；又或直接中断程序。</li></ul><p>体会到C语言处理错误的复杂性和不可控问题，GO号称提供了拓展性极强的错误处理方式，将错误处理的方式：</p><ul><li>抛给设计程序者自己去决策与处理<del>（可以说是摆烂吗？）</del>。</li></ul><p>GO面对致命性异常也不再像C程序一样需要分析core dump文件，而使用panic输出尽可能多的信息帮助开发者定位问题，本篇不涉及panic的内容。</p><p>那么GO的”error”关键字到底是什么？它为什么具备拓展性？又带来了什么问题？又是如何利用GO的error设计思想去解决问题的？</p><h2 id="1-关键字”error”"><a href="#1-关键字”error”" class="headerlink" title="1.  关键字”error”"></a>1.  关键字”error”</h2><h3 id="1-1-error是什么？"><a href="#1-1-error是什么？" class="headerlink" title="1.1. error是什么？"></a>1.1. error是什么？</h3><ul><li><strong>error 关键字是一个接口类型</strong></li></ul><blockquote><p>摘自 Go&#x2F;src&#x2F;builtin&#x2F;builtin.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The error built-in interface type is the conventional interface for</span><br><span class="hljs-comment">// representing an error condition, with the nil value representing no error.</span><br><span class="hljs-comment">// 内置接口类型是表示错误情况的常规接口，nil 值表示没有错误。</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从接口方法 <code>Error() string</code> 可以看出，它仅仅表示用一个字符串就能诠释的错误，它能满足基本编码的需要吗？</p><p>我们带着疑问往下探索GO官方提供的两种error实现：<code>errorString</code> 与 <code>wrapError</code>。</p><h3 id="1-2-errorString"><a href="#1-2-errorString" class="headerlink" title="1.2. errorString"></a>1.2. errorString</h3><p>乍一看，可能会有些陌生。</p><p>其实，它正是errors包对error接口的实现，想起各种教程中提及的 <code>errors.New()</code> 了吗？</p><ul><li><strong>errorString 是error接口的一种实现</strong> (也是官方提供的最基础的实现)</li></ul><blockquote><p>摘自 Go&#x2F;src&#x2F;errors&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>errorString 本身极其简单，仅仅实现了 error接口 的基础能力：保存一个错误描述字符串，并能将其输出，没有然后。</p><p>这种设计仅仅能满足与简单的业务场景，或简短的demo；如果在中型项目中使用errorString，可以想象到每次使用字符串作错误判断依据的痛苦吧？</p><p>但存在即是合理，它有它的优势：足够轻量级（吧？）。</p><h3 id="1-3-Wrap"><a href="#1-3-Wrap" class="headerlink" title="1.3. Wrap()"></a>1.3. Wrap()</h3><p>顾名思义，包裹error，即把目标error包裹到新error内部。</p><p>官方的 <code>fmt.Errorf()</code> 支持这种能力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Errorf 根据格式说明符进行格式化，并将字符串作为满足错误的值返回。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>p := newPrinter()<br>p.wrapErrs = <span class="hljs-literal">true</span><br>p.doPrintf(format, a)  <span class="hljs-comment">// &lt;--这一步会判断format中是否包含%w占位符，如果有就将入参err赋值给wrappedErr，且%w占位符只能存在一个。</span><br>s := <span class="hljs-type">string</span>(p.buf)<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> &#123;<br>err = errors.New(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = &amp;wrapError&#123;s, p.wrappedErr&#125;  <span class="hljs-comment">// 包裹error并返回新error</span><br>&#125;<br>p.free()<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> &#123;<br>msg <span class="hljs-type">string</span><br>err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> e.err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以看以下示例：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorWrap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err1 := errors.New(<span class="hljs-string">&quot;error-1&quot;</span>)<br>err2 := fmt.Errorf(<span class="hljs-string">&quot;error-2. %w&quot;</span>, err1)<br>err3 := fmt.Errorf(<span class="hljs-string">&quot;error-3. %w&quot;</span>, err2)<br><br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err1)<br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err2)<br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err3)<br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorWrap</span><br><span class="hljs-comment">//     emoji_test.go:70: &amp;errors.errorString&#123;s:&quot;error-1&quot;&#125;</span><br><span class="hljs-comment">//     emoji_test.go:71: &amp;fmt.wrapError&#123;msg:&quot;error-2. error-1&quot;, err:(*errors.errorString)(0xc000088fc0)&#125;</span><br><span class="hljs-comment">//     emoji_test.go:72: &amp;fmt.wrapError&#123;msg:&quot;error-3. error-2. error-1&quot;, err:(*fmt.wrapError)(0xc0001cf540)&#125;</span><br><span class="hljs-comment">// --- PASS: TestErrorWrap (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><ul><li><p>fmt包的作者依然为多次嵌套error提供了反解能力：</p><ul><li><p>使用 <strong>%w占位符</strong> 表达err时，会将传入的error保存到 wrapError 内部的err变量中；</p></li><li><p>实现了 <strong>Unwrap()</strong> 方法，使得通过 fmt.Errorf() 方法包裹的原始err可以在外部进行比对及反解（Unwrap下一小节记录）。</p></li></ul></li><li><p>但需要注意几点：</p><ul><li><p>必须使用%w占位符才生效，否则fmt.Errorf内部将创建一个新的errors.errorString保存错误信息；</p></li><li><p>当%w个数&gt;1时，多出的占位符对应的err不会生效；</p></li><li><p>传入的err没有实现Unwrap()方法不生效；</p></li></ul></li></ul><h3 id="1-4-Unwrap"><a href="#1-4-Unwrap" class="headerlink" title="1.4. Unwrap()"></a>1.4. Unwrap()</h3><p>除了吐槽官方偷懒之外，errors包的另一个文件wrap.go，被许多开源库借鉴，主要是提供多个解决error多重嵌产物的方法。</p><ul><li><strong>Unwrap() 反解嵌套error</strong> ，即取出本error中包裹的error。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 判断这个error的实现类是否实现了Unwrap()方法</span><br>u, ok := err.(<span class="hljs-keyword">interface</span> &#123;<br>Unwrap() <span class="hljs-type">error</span><br>&#125;)<br>    <span class="hljs-comment">// 没有实现直接返回nil</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>    <span class="hljs-comment">// 有实现就调用实现类的Unwrap方法</span><br><span class="hljs-keyword">return</span> u.Unwrap()<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是： <strong>Unwrap()</strong> 方法不属于 Error-Interface 的抽象方法，即error的”实现类”不一定要实现这个方法。</p><ul><li>要满足反解error嵌套的能力，error的”实现类” 必须实现 <strong>Unwrap(error) error</strong>  方法，如上一节提到的<code>wrapError</code>。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorUnwrap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err1 := errors.New(<span class="hljs-string">&quot;error-1&quot;</span>)<br>err2 := fmt.Errorf(<span class="hljs-string">&quot;error-2. %w&quot;</span>, err1)<br>err3 := fmt.Errorf(<span class="hljs-string">&quot;error-3. %w&quot;</span>, err2)<br><br>t.Log(err3)<br><span class="hljs-keyword">for</span> e := err3; e != <span class="hljs-literal">nil</span>; &#123;<br>e = errors.Unwrap(e)<br>t.Log(e)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorUnwrap</span><br><span class="hljs-comment">//     emoji_test.go:80: error-3. error-2. error-1</span><br><span class="hljs-comment">//     emoji_test.go:83: error-2. error-1</span><br><span class="hljs-comment">//     emoji_test.go:83: error-1</span><br><span class="hljs-comment">//     emoji_test.go:83: &lt;nil&gt;</span><br><span class="hljs-comment">// --- PASS: TestErrorUnwrap (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Is-x2F-As"><a href="#1-5-Is-x2F-As" class="headerlink" title="1.5. Is()&#x2F;As()"></a>1.5. Is()&#x2F;As()</h3><p>作者想到开发者可能会将error多层嵌套，即形成error链，如err1–&gt;err2–&gt;err3逐层包裹，于是官方提供了下面2个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>......<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err, target <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Is()</strong> 可以判断在error嵌套链中是否存在目标error的实例，即error实例的&#x3D;&#x3D;运算：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> derrors <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorIs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>err1 = errors.New(<span class="hljs-string">&quot;xx&quot;</span>)<br>err2 = errors.New(<span class="hljs-string">&quot;xx&quot;</span>)<br>)<br>    err := derrors.Wrap(err1, <span class="hljs-string">&quot;yy&quot;</span>)<br>err = fmt.Errorf(<span class="hljs-string">&quot;%w&quot;</span>, err)  <span class="hljs-comment">// 这里error包裹链：wrapError--&gt;wrapMessage--&gt;proto.RedisError</span><br>    t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err3)<br><br><span class="hljs-keyword">var</span> err2 = errors.New(<span class="hljs-string">&quot;xx&quot;</span>) <span class="hljs-comment">// 新建一个stringError实例</span><br><br>t.Log(errors.Is(err, err1))<br>    t.Log(errors.Is(err, err2)) <span class="hljs-comment">// 即使err2与err1内容一致，但输出结果为false，证实Is()对比的是实例本身</span><br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorIs</span><br><span class="hljs-comment">//     version_test.go:67: &amp;fmt.wrapError&#123;msg:&quot;yy: xx&quot;, err:(*errors.withStack)(0xc00009cb88)&#125;</span><br><span class="hljs-comment">//     version_test.go:71: true</span><br><span class="hljs-comment">//     version_test.go:72: false</span><br><span class="hljs-comment">// --- PASS: TestErrorIs (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><ul><li><strong>As()</strong> 可以判断目标error的实例类型是否存在与error嵌套链中：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> derrors <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorAs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err1 := errors.New(<span class="hljs-string">&quot;xx&quot;</span>)<br>err2 := derrors.Wrap(err1, <span class="hljs-string">&quot;yy&quot;</span>)<br>err3 := fmt.Errorf(<span class="hljs-string">&quot;%w&quot;</span>, err2)<br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err3)<br><br><span class="hljs-keyword">var</span> (<br>a = errors.New(<span class="hljs-string">&quot;xyz&quot;</span>)<br>b = derrors.New(<span class="hljs-string">&quot;123&quot;</span>)<br>)<br>t.Log(errors.As(err3, &amp;a)) <span class="hljs-comment">// 纵使a与b内容与err3嵌套链中不一致，但实例类型一致，因此可以检查出err3嵌套链中是否包含目标类型的error</span><br>t.Log(errors.As(err3, &amp;b))<br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorAs</span><br><span class="hljs-comment">//     version_test.go:79: &amp;fmt.wrapError&#123;msg:&quot;yy: xx&quot;, err:(*errors.withStack)(0xc00009cb88)&#125;</span><br><span class="hljs-comment">//     version_test.go:85: true</span><br><span class="hljs-comment">//     version_test.go:86: true</span><br><span class="hljs-comment">// --- PASS: TestErrorAs (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><ul><li>当然，这两个方法的实现内部都需要调用 <strong>Unwrap()</strong> 。</li></ul><h3 id="1-6-error接口有什么问题？"><a href="#1-6-error接口有什么问题？" class="headerlink" title="1.6. error接口有什么问题？"></a>1.6. error接口有什么问题？</h3><p>综合 1.1 ~ 1.3 小节，可以总结出官方提供的 <code>errorString</code> 存在的问题：</p><ul><li><p>只保存了简单的字符串信息，无法追溯错误发生的源头；</p></li><li><p>或需要煞费苦心地对比错误的字符串内容是否为自己所需的，才能进行下一步业务操作；</p></li><li><p>为了代码的健壮性考虑，函数返回的每一个错误，都不能忽略；</p><ul><li>因为按GO的编码习惯，当返回参数包含err非nil时，很可能返回一个nil的对象；此时如果不对err进行判断，很可能会引发panic；这就使得代码中error出现的频率非常高，显得非常冗长。</li></ul><p>下面是常见的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := doSomething1(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理error</span><br>&#125;<br><span class="hljs-keyword">if</span> err := doSomething2(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理error</span><br>&#125;<br><span class="hljs-keyword">if</span> err := doSomething3(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种处理方式像极了C语言中的处理，显得非常冗长。</p><p>于是就有人会抱怨起来，为什么GO不使用高级语言中的try..catch..finally机制去处理错误？</p><p>在官方的FAQ中已经有解释：<a href="https://golang.google.cn/doc/faq">https://golang.google.cn/doc/faq</a></p><blockquote><p><strong>Why does Go not have exceptions?</strong></p><p>We believe that coupling exceptions to a control structure, as in the <code>try-catch-finally</code> idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.</p><p>Go takes a different approach. For plain error handling, Go’s multi-value returns make it easy to report an error without overloading the return value. <a href="https://golang.google.cn/doc/articles/error_handling.html">A canonical error type, coupled with Go’s other features</a>, makes error handling pleasant but quite different from that in other languages.</p><p>Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function’s state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in clean error-handling code.</p><p>See the <a href="https://golang.google.cn/doc/articles/defer_panic_recover.html">Defer, Panic, and Recover</a> article for details. Also, the <a href="https://blog.golang.org/errors-are-values">Errors are values</a> blog post describes one approach to handling errors cleanly in Go by demonstrating that, since errors are just values, the full power of Go can be deployed in error handling.</p></blockquote><blockquote><p><strong>为什么 Go 没有异常？</strong></p><p>我们相信将异常耦合到控制结构中，就像在<code>try-catch-finally</code>成语中一样，会导致代码复杂。它还倾向于鼓励程序员将太多的普通错误（例如无法打开文件）标记为异常。</p><p>Go 采用了不同的方法。对于简单的错误处理，Go 的多值返回可以很容易地报告错误而不会重载返回值。 <a href="https://golang.google.cn/doc/articles/error_handling.html">规范的错误类型，加上 Go 的其他特性</a>，使得错误处理令人愉快，但与其他语言中的错误处理完全不同。</p><p>Go 还有一些内置函数可以发出信号并从真正的异常情况中恢复。恢复机制仅作为函数状态的一部分在错误后被拆除，这足以处理灾难但不需要额外的控制结构，并且如果使用得当，可以产生干净的错误处理代码。</p><p>有关详细信息，请参阅<a href="https://golang.google.cn/doc/articles/defer_panic_recover.html">延迟、恐慌和恢复</a>文章。此外，<a href="https://blog.golang.org/errors-are-values">Errors are values</a>博客文章描述了一种在 Go 中干净地处理错误的方法，通过演示，由于错误只是值，因此可以在错误处理中部署 Go 的全部功能。</p></blockquote><p>​</p><p>GO设计者之一 Russ Cox 也解释过同样的问题：<a href="https://studygolang.com/articles/1674">https://studygolang.com/articles/1674</a></p><blockquote><p>Go是为编写大型软件而设计的。我们喜欢让程序保持简洁，而不是为大量程序员编写的大型程序不断投入维护成本。基于异常的错误处理的一个诱惑是，对于小的程序它工作得很好。但是在一个庞大的代码库里，对于每一行代码，每一个普通的操作，都需要考虑它们是否会触发一个需要处理的异常。这对于生产效率和工程时间是个很大的拖累。我自己在编写大型Python程序时就遇到这样的问题。必须承认，Go语言里函数返回错误对于调用者来说并不方便，但它们很明白地表明了程序和类型系统里发生错误的可能性。当遇到函数返回错误时，小程序可能只想打印出错误然后退出程序；但是更精心设计的程序通常会根据不同的错误来源作出不同的处理。在这种情况，try和catch的处理方式会比显式的错误返回值处理更冗长。虽然Python语言的10行代码用Go语言来实现确实可能会更冗长，但是，Go语言的首要目标不是编写10行代码的程序。</p></blockquote><p>从客观的角度来讲，GO在error处理的设计上有弊有利；从我主观的角度来讲，对于弊，只是大多参与到GO项目的编写者因为保留了第一语言的习惯，使用GO有所不适罢了。比较认同上文的一句话：</p><blockquote><p>虽然Python语言的10行代码用Go语言来实现确实可能会更冗长，但是，Go语言的首要目标不是编写10行代码的程序。</p></blockquote></li></ul><p>综上，也只是阐述了官方提供的error包的两种实现，得益于error接口本身的设计，具备良好的拓展性，可以灵活地实现所需。</p><p>然而灵活性也带来了多样性，从而给处理众多实现各异三方库中的error时带来了相当的复杂性。</p><p>再往下探究，官方如何引导GO使用者学习error的设计思想，又如何优雅地处理error。</p><h2 id="2-处理error"><a href="#2-处理error" class="headerlink" title="2. 处理error"></a>2. 处理error</h2><blockquote><p><strong>Don’t just check errors, handle them gracefully</strong>  </p><p>– Dave Cheney</p><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p></blockquote><p>不要只检查错误，要优雅地处理它们。</p><h3 id="2-1-Errors-are-just-values"><a href="#2-1-Errors-are-just-values" class="headerlink" title="2.1. Errors are just values"></a>2.1. Errors are just values</h3><p>错误只是值，或者这样理解——把错误视为值。</p><p>这本身有很多故事，这里只做部分举例与阐明结论，想知道详细故事请自行查看相关的GoCon。</p><p>Rob Pike 在 2015.1.12 发了一篇博客，回应 2014 年秋季在东京举行的 GoCon 中提及error处理的问题；</p><p>标题为Errors are values：<a href="https://go.dev/blog/errors-are-values%E3%80%82">https://go.dev/blog/errors-are-values。</a></p><p>文末总结：</p><blockquote><p>然而，关键的教训是错误是值，Go 编程语言的有足够能力去处理它们。</p><p>使用本语言来简化您的错误处理。</p><p>但请记住：无论您做什么，都要检查您的错误！</p></blockquote><p>Dave Cheney 为 2016.4.23 在日本举行的 GoCon 针对error的论述做了记录：</p><blockquote><p>我花了很多时间思考在 Go 程序中处理错误的最佳方法。我真的希望有一种单一的方法来进行错误处理，我们可以死记硬背地教所有 Go 程序员，就像我们可以教数学或字母表一样。 </p><p>但是，我得出的结论是，没有单一的方法可以处理错误。相反，我认为 Go 的错误处理可以分为三个核心策略。</p></blockquote><p>我们往下逐一分析这三种核心策略：</p><ul><li><p><strong>Sentinel errors</strong> —— 哨兵错误</p></li><li><p><strong>Error types</strong> —— 错误类型化</p></li><li><p><strong>Opaque errors</strong> —— 不透明的错误（”黑盒”错误）</p></li></ul><h4 id="2-1-1-Sentinel-errors"><a href="#2-1-1-Sentinel-errors" class="headerlink" title="2.1.1. Sentinel errors"></a>2.1.1. Sentinel errors</h4><blockquote><p>哨兵错误，应该理解为：哨兵值，无论是否有错误，基本上都是特殊的、预定义的值，您认为这些值可能是特定上下文中特定进程的结果。</p><p>使用哨兵值是最不灵活的错误处理策略，因为调用者必须使用相等运算符将结果与预先声明的值进行比较。当您想提供更多上下文时，这会出现问题，因为返回不同的错误会破坏相等性检查。</p><p>甚至像使用<code>fmt.Errorf</code>为错误添加一些上下文一样有意义的东西也会破坏调用者的相等性测试。相反，调用者将被迫查看 <code>error.Error()</code> 方法的输出以查看它是否与特定字符串匹配。</p></blockquote><p>Dave Cheney总结了 <strong>Sentinel errors</strong> 的三项关键特征：</p><ul><li><strong>永远不要检查 error.Error() 的输出</strong></li><li><strong>哨兵错误成为公共 API 的一部分</strong></li><li><strong>哨兵错误在两个包之间创建依赖关系</strong></li></ul><p>原文的措辞与例子可能比较抽象，我就用更接地气的示例，由上到下逐一分析这些特征并展开这些特征带来的问题。</p><ul><li><strong>永远不要检查 error.Error() 的输出</strong></li></ul><blockquote><p>对于这句话，我的理解是：永远不要通过校验 error.Error() 的输出作为错误判断的预期依据</p></blockquote><p>为什么如此绝对？我们可以反过来想，什么情况下才要检查error.Error()的输出（文本信息）？</p><p>在下面例子中有直观感受</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...... <span class="hljs-comment">// 执行了步骤1</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤1执行异常&quot;</span>)<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤2</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤2执行异常&quot;</span>)<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤3</span><br>    ...... <span class="hljs-comment">// 以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在需要新增一个逻辑，doSomething() ；当步骤1执行异常后，执行逻辑A，当步骤2执行异常后，执行逻辑B….；你只能按如下相似的代码判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span> &#123;<br>    err := doSomething()<br>    <span class="hljs-keyword">switch</span> err.Error() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;步骤1执行异常&quot;</span>:<br>        doPlanA()<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;步骤2执行异常&quot;</span>:<br>        doPlanB()<br>    <span class="hljs-keyword">case</span> .....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，代码执行起来没问题，但是对于后面维护的人来说真是日了狗了，有下面两种场景：</p><ul><li><p>如果需要使用 doSomething() 这个方法，就需要去准确判断该方法返回的所有错误；</p></li><li><p>如果这个 doSomething() 被多处代码引用，后面的维护人不能轻易修改错误描述，否则外部判断需要同时准确修正；</p></li></ul><p>当人有人会提出使用常量去定义错误描述，那又可以看看下面这种情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...... <span class="hljs-comment">// 执行了步骤1</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤1执行异常&quot;</span>)<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤2</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤2执行异常&quot;</span>)<br>    <br>    x := getRandom()<br>    ...... <span class="hljs-comment">// 执行了步骤3</span><br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;步骤3执行异常. 随机值: %s&quot;</span>, x)<br>    <br>    <span class="hljs-comment">// 以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请问步骤3异常的情况怎么判断呢？还能用常量吗？然后又会有人提出，可以截取前半段字符串匹配啊。这就只会在错误的路上越走越远，然后暗暗骂一句，GO处理错误的方式真垃圾！</p><p>好了，看到这里相信你已经可以理解为什么 <strong>永远不要校验 error.Error() 的输出</strong>。</p><p>在官方的源码中，可以发现有不少局部使用 errors.New() 定义的error并作为返参，但这些error不是逻辑错误，大多为系统级别触发的error。</p><p>也就是说在绝大多数场景下，开发者并不需要判断错误的文本内容，而是需要根据错误信息来获知服务之外的，如MySQL表数据写入失败、第三方接口异常等不可预知的问题。</p><p>在这种前提下，局部地返回纯文本error是可以被理解的，如下面这个示例：</p><blockquote><p> 摘自Go&#x2F;src&#x2F;log&#x2F;syslog&#x2F;syslog_unix.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// unixSyslog opens a connection to the syslog daemon running on the</span><br><span class="hljs-comment">// local machine using a Unix domain socket.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unixSyslog</span><span class="hljs-params">()</span></span> (conn serverConn, err <span class="hljs-type">error</span>) &#123;<br>logTypes := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;unixgram&quot;</span>, <span class="hljs-string">&quot;unix&quot;</span>&#125;<br>logPaths := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;/dev/log&quot;</span>, <span class="hljs-string">&quot;/var/run/syslog&quot;</span>, <span class="hljs-string">&quot;/var/run/log&quot;</span>&#125;<br><span class="hljs-keyword">for</span> _, network := <span class="hljs-keyword">range</span> logTypes &#123;<br><span class="hljs-keyword">for</span> _, path := <span class="hljs-keyword">range</span> logPaths &#123;<br>conn, err := net.Dial(network, path)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> &amp;netConn&#123;conn: conn, local: <span class="hljs-literal">true</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;Unix syslog delivery error&quot;</span>)  <span class="hljs-comment">// &lt;-- 如果出错，只需要知道这个func内部发生错误，并知道错误信息即可，并不需要根据错误信息来进行逻辑分支处理。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那如果前同事写了类似上文 <strong>doSomething()</strong> 的代码，怎么解困呢？</p><p>我们来看下GO官方包内部是怎么处理这种问题的：</p><blockquote><p>摘自Go&#x2F;src&#x2F;io&#x2F;io.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>摘自Go&#x2F;src&#x2F;fmt&#x2F;scan.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *stringReader)</span></span> Read(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>n = <span class="hljs-built_in">copy</span>(b, *r)<br>*r = (*r)[n:]<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>err = io.EOF  <span class="hljs-comment">// 注意这里，返回了一个io.EOF错误，该使用了标记值错误</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>摘自Go&#x2F;src&#x2F;io&#x2F;io.go，当我们判断这个EOF时，需要判断这个error是否为 io.EOF</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadAll</span><span class="hljs-params">(r Reader)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>......<br><span class="hljs-keyword">for</span> &#123;<br>......<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == EOF &#123;  <span class="hljs-comment">// 这里直接使用==运算符对比error是否为io.EOF</span><br>err = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> b, err<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里如释重负，我们可以把整个错误提取出来作为全局变量提供外部包使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">Step1Err := errors.New(<span class="hljs-string">&quot;步骤1执行异常&quot;</span>)<br>Step2Err := errors.New(<span class="hljs-string">&quot;步骤2执行异常&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...... <span class="hljs-comment">// 执行了步骤1</span><br>    <span class="hljs-keyword">return</span> Step1Err<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤2</span><br>    <span class="hljs-keyword">return</span> Step2Err<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤3</span><br>    ...... <span class="hljs-comment">// 以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但这种全局化的做法同时带来了另外一些问题：</p><ul><li><strong>一种错误描述对应一个全局变量，并定义在包头，增加了包的”厚度”，显得代码比较冗余；</strong></li><li><strong>其他包想使用该包内的方法时，需要绑定使用该包的错误，如果该错误的传递层次较多，那么最外部文件中还需要import该包；</strong><ul><li><strong>如果一个逻辑包含了多个使用sentinel errors的包，那么需要把它们都import一遍进行判断，这会使得需要import的包非常多；</strong></li></ul></li></ul><p>以上两点一一对应了Dave Cheney总结 <strong>Sentinel errors</strong> 的后两种特征：</p><ul><li><p><strong>哨兵错误成为公共 API 的一部分</strong></p><ul><li>这个特征还有另外一个原因：使用了非实现error接口的值作为错误，这种做法很奇葩，违反error接口的根本设计理念，忽略</li></ul></li><li><p><strong>哨兵错误在两个包之间创建依赖关系</strong></p></li></ul><p>最终Dave Cheney也有自己对 <strong>Sentinel errors</strong> 的使用结论：</p><blockquote><p><strong>Conclusion: avoid sentinel errors</strong></p><p>So, my advice is to avoid using sentinel error values in the code you write. There are a few cases where they are used in the standard library, but this is not a pattern that you should emulate.</p><p>If someone asks you to export an error value from your package, you should politely decline and instead suggest an alternative method, such as the ones I will discuss next.</p></blockquote><blockquote><p>结论：避免哨兵错误 </p><p>因此，我的建议是避免在您编写的代码中使用哨兵错误。在标准库中使用它们的情况很少，但这不是您应该效仿的模式。 </p><p>如果有人要求你从你的包中导出一个错误值，你应该礼貌地拒绝，而是建议一种替代方法，比如我将在下面讨论的方法。</p></blockquote><p>认真阅读本文的小可爱一定还记得上文  <strong>doSomething()</strong> 示例中还存在 带变参 的错误没有得到解决，这种错误是没办法通过全局变量的方式替换的。需要使用Dave Cheney提到的第二种核心策略：<strong>Error types</strong>。</p><h4 id="2-1-2-Error-types"><a href="#2-1-2-Error-types" class="headerlink" title="2.1.2. Error types"></a>2.1.2. Error types</h4><blockquote><p>错误类型是指实现错误接口的类型。</p></blockquote><p>它的一个重要的好处是，类型中除了异常文本描述之外，还可以附带其他字段，从而提供额外的信息。</p><p>我们以官方包的<strong>PathError</strong>举例：</p><blockquote><p>摘自Go&#x2F;src&#x2F;io&#x2F;fs&#x2F;fs.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PathError records an error and the operation and file path that caused it.</span><br><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>Op   <span class="hljs-type">string</span><br>Path <span class="hljs-type">string</span><br>Err  <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error() &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> e.Err &#125;<br><br><span class="hljs-comment">// Timeout reports whether this error represents a timeout.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Timeout() <span class="hljs-type">bool</span> &#123;<br>t, ok := e.Err.(<span class="hljs-keyword">interface</span>&#123; Timeout() <span class="hljs-type">bool</span> &#125;)<br><span class="hljs-keyword">return</span> ok &amp;&amp; t.Timeout()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PathError</strong> 能够记录出错时的文件路径与操作类型。外层业务逻辑可以使用类型断言来判断错误：</p><blockquote><p>摘自Go&#x2F;src&#x2F;cmd&#x2F;go&#x2F;internal&#x2F;lockedfile&#x2F;internal&#x2F;filelock&#x2F;filelock.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// underlyingError returns the underlying error for known os error types.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">underlyingError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *fs.PathError:<br><span class="hljs-keyword">return</span> err.Err<br><span class="hljs-keyword">case</span> *os.LinkError:<br><span class="hljs-keyword">return</span> err.Err<br><span class="hljs-keyword">case</span> *os.SyscallError:<br><span class="hljs-keyword">return</span> err.Err<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>但这种也存在以下问题：</p><ul><li><strong>该接口的所有实现者都需要依赖于定义错误类型的包。</strong></li><li><strong>创建与调用时都是与类型强耦合，降低了API的灵活性。</strong>（这句话可能描述得有点抽象，大白话是：如<strong>PathError</strong>一样的结构虽然实现了error接口，但其创建时仍然是直接返回指针对象，而不是一个error接口，还是对开发者有心智负担）</li></ul><p>最终Dave Cheney也有自己对 <strong>Error types</strong> 的使用结论：</p><blockquote><p><strong>Conclusion: avoid error types</strong></p><p>While error types are better than sentinel error values, because they can capture more context about what went wrong, error types share many of the problems of error values.</p><p>So again my advice is to avoid error types, or at least, avoid making them part of your public API.</p><p>结论：避免错误类型</p><p>虽然错误类型比哨兵错误更好，因为它们可以捕获更多关于出错的上下文，但错误类型仍然携带着需要导包等问题。</p><p>所以我的建议是避免错误类型，或者至少避免将它们作为公共 API 的一部分。</p></blockquote><p>最后Dave Cheney提出了一种终极方案：<strong>Opaque errors</strong>，下面我们来分析一下<strong>Opaque errors</strong>到底有多神。</p><h4 id="2-1-3-Opaque-errors"><a href="#2-1-3-Opaque-errors" class="headerlink" title="2.1.3. Opaque errors"></a>2.1.3. Opaque errors</h4><blockquote><p>现在我们来到第三类错误处理。在我看来，这是最灵活的错误处理策略，因为它需要您的代码和调用者之间的耦合最少。</p><p>我将这种风格称为不透明错误处理，因为当您知道发生了错误时，您无法查看错误内部。作为调用者，您所知道的关于操作结果的所有信息都是它有效，或者它没有。</p><p>这就是不透明错误处理的全部内容——只需返回错误而不假设其内容。如果您采用这种立场，那么错误处理作为调试辅助工具会变得更加有用。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> “github.com/quux/bar”<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        x, err := bar.Foo()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-comment">// use x</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是 <strong>Opaque errors</strong> 的策略，作为调用方，只需要知道 Foo 是否正常执行，一旦err不为空，直接返回错误；</p><p>但在真实场景中，调用的三方库会非常多，复杂的业务中难免会遇到根据err来走不同逻辑分支的情形。这时候，光有Foo已经不够用，需要一种方法获知错误是否具备某种行为，而不需要判断错误类型是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>        Temporary() <span class="hljs-type">bool</span><br>&#125;<br> <br><span class="hljs-comment">// IsTemporary returns true if err is temporary.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        te, ok := err.(temporary)<br>        <span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()<br>&#125;<br></code></pre></td></tr></table></figure><p>这么做的好处是：</p><ul><li><strong>业务层不需要import具体类型的包；</strong></li><li><strong>业务层不需要知道error的内部类型，再进行具体错误原因的对比；而是直接判断接口是否具备某种行为；</strong></li></ul><p>这种设计方式，也被称为<strong>面向接口编程</strong>。</p><h3 id="2-2-Don’t-just-check-errors-handle-them-gracefully"><a href="#2-2-Don’t-just-check-errors-handle-them-gracefully" class="headerlink" title="2.2. Don’t just check errors, handle them gracefully"></a>2.2. Don’t just check errors, handle them gracefully</h3><p>检查并优雅地处理错误，这是本篇的重点内容。</p><h4 id="2-2-1-避免冗长的错误处理代码"><a href="#2-2-1-避免冗长的错误处理代码" class="headerlink" title="2.2.1. 避免冗长的错误处理代码"></a>2.2.1. 避免冗长的错误处理代码</h4><p>Dave Cheney在<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">[3]</a>中给出一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        err := authenticate(r.User)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很明显代码可以简化到如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">return</span> authenticate(r.User)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是最基本的应对措施。</p><h4 id="2-2-2-携带堆栈信息"><a href="#2-2-2-携带堆栈信息" class="headerlink" title="2.2.2. 携带堆栈信息"></a>2.2.2. 携带堆栈信息</h4><p>尽管代码足够简约，返回的error信息还是太贫瘠，仅包含一个字符串形式的信息，例如它是：**”No such file or directory”**。</p><p>当错误产生在代码层次较深时，我们根本不知道这个错误来自于哪里？？？</p><p>如果错误中能携带堆栈信息，就能解决这一困境。</p><p>这就不得不说一个具有启蒙意义的第三方包：**”github.com&#x2F;pkg&#x2F;errors”**，一个携带有堆栈信息的错误管理包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New 使用提供的消息返回错误。</span><br><span class="hljs-comment">// New 还会记录调用时的堆栈跟踪。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(message <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;fundamental&#123;<br>msg:   message,<br>stack: callers(),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Errorf 根据格式说明符进行格式化，并将字符串作为满足错误的值返回。</span><br><span class="hljs-comment">// Errorf 还会记录调用时的堆栈跟踪。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;fundamental&#123;<br>msg:   fmt.Sprintf(format, args...),<br>stack: callers(),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// fundamental是一个错误，它有一个消息和一个堆栈，但没有调用者。</span><br><span class="hljs-keyword">type</span> fundamental <span class="hljs-keyword">struct</span> &#123;<br>msg <span class="hljs-type">string</span><br>*stack<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fundamental</strong> 结构包含堆栈信息 *<strong>stack</strong> 与自定义错误描述 <strong>msg</strong>，只要使用常规的 <strong>New</strong>() 与 <strong>Errorf()</strong> 新建error，就能记录当前位置的堆栈。</p><p>除此之外，<strong>fundamental</strong> 还提供了 **Format()**方法，实现了 <strong>Formatter</strong> 接口。使用 *<em>fmt.Printf(“%+v”, (<em>fundamental类型的error)</em></em> 时可以输出详细的堆栈信息。</p><blockquote><p>摘自Go&#x2F;src&#x2F;fmt&#x2F;print.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Formatter is implemented by any value that has a Format method.</span><br><span class="hljs-comment">// The implementation controls how State and rune are interpreted,</span><br><span class="hljs-comment">// and may call Sprint(f) or Fprint(f) etc. to generate its output.</span><br><span class="hljs-keyword">type</span> Formatter <span class="hljs-keyword">interface</span> &#123;<br>   Format(f State, verb <span class="hljs-type">rune</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>摘自pkg&#x2F;mod&#x2F;github.com&#x2F;pkg&#x2F;<a href="mailto:&#x65;&#114;&#x72;&#x6f;&#x72;&#115;&#64;&#x76;&#48;&#46;&#x39;&#46;&#49;">&#x65;&#114;&#x72;&#x6f;&#x72;&#115;&#64;&#x76;&#48;&#46;&#x39;&#46;&#49;</a>&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *fundamental)</span></span> Format(s fmt.State, verb <span class="hljs-type">rune</span>) &#123;<br><span class="hljs-keyword">switch</span> verb &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br><span class="hljs-keyword">if</span> s.Flag(<span class="hljs-string">&#x27;+&#x27;</span>) &#123;  <span class="hljs-comment">// &lt;---可以重点看这里的逻辑，进入这个分支可以输出详细的堆栈。</span><br>io.WriteString(s, f.msg)<br>f.stack.Format(s, verb)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>io.WriteString(s, f.msg)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>fmt.Fprintf(s, <span class="hljs-string">&quot;%q&quot;</span>, f.msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">readfile.go:27: could not read config<br>readfile.go:14: open failed<br>open /Users/dfc/.settings.xml: no such file or directory<br></code></pre></td></tr></table></figure><p>这对于定位问题来说就简单多了，不需要反复重现或debug，就能直接知道问题的根源。</p><h4 id="2-2-3-嵌套error链"><a href="#2-2-3-嵌套error链" class="headerlink" title="2.2.3. 嵌套error链"></a>2.2.3. 嵌套error链</h4><p>在1.3小节我们提到过嵌套错误的问题。当业务流程中，需要携带的错误不止一个时，可以用嵌套error的方式实现。</p><p>**”github.com&#x2F;pkg&#x2F;errors”<strong>也有一套</strong>“包装”<strong>与</strong>“解包”**的方法</p><blockquote><p>摘自pkg&#x2F;mod&#x2F;github.com&#x2F;pkg&#x2F;<a href="mailto:&#101;&#x72;&#114;&#x6f;&#114;&#115;&#64;&#118;&#x30;&#46;&#57;&#x2e;&#49;">&#101;&#x72;&#114;&#x6f;&#114;&#115;&#64;&#118;&#x30;&#46;&#57;&#x2e;&#49;</a>&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithStack 在调用 WithStack 时使用堆栈跟踪注释 err。</span><br><span class="hljs-comment">// 如果 err 为 nil，WithStack 返回 nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithStack</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;withStack&#123;<br>err,<br>callers(),<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> withStack <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">error</span><br>*stack<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *withStack)</span></span> Cause() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> w.<span class="hljs-type">error</span> &#125;<br><br><span class="hljs-comment">// Unwrap 为 Go 1.13 错误链提供兼容性。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *withStack)</span></span> Unwrap() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> w.<span class="hljs-type">error</span> &#125;<br></code></pre></td></tr></table></figure><p>类似地，<strong>withStack</strong> 与 <strong>fundamental</strong> 提供了记录堆栈的能力，但扩展了一套 <strong>Cause()</strong> 与 <strong>WithStack()</strong> 方法，意于装载任意的错误，当必要时可以通过解包获取最内部的错误，或对比整个嵌套链的错误包含有业务场景关注的错误。</p><blockquote><p>摘自pkg&#x2F;mod&#x2F;github.com&#x2F;pkg&#x2F;<a href="mailto:&#101;&#x72;&#x72;&#111;&#114;&#115;&#64;&#118;&#x30;&#46;&#x39;&#46;&#x31;">&#101;&#x72;&#x72;&#111;&#114;&#115;&#64;&#118;&#x30;&#46;&#x39;&#46;&#x31;</a>&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果错误没有实现Cause，则返回原来的错误。如果错误为 nil，则将返回 nil 而无需进一步调查。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cause</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">type</span> causer <span class="hljs-keyword">interface</span> &#123;<br>Cause() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> &#123;<br>cause, ok := err.(causer)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>err = cause.Cause()<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <strong>Cause()</strong> 方法是否与1.2小节中提到的 <strong>Unwrap()</strong> 很相像？其实在Go1.13版本前，是没有Unwrap()方法的，我们可以追溯到Go1.12最后一个发布版本的errors官方包代码，errors包下只有一个errors.go文件及其单元测试文件：</p><ul><li><p>摘自 <a href="https://github.com/golang/go/blob/go1.12.17/src/errors/errors.go">https://github.com/golang/go/blob/go1.12.17/src/errors/errors.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Copyright 2011 The Go Authors. All rights reserved.</span><br><span class="hljs-comment">// Use of this source code is governed by a BSD-style</span><br><span class="hljs-comment">// license that can be found in the LICENSE file.</span><br><br><span class="hljs-comment">// Package errors implements functions to manipulate errors.</span><br><span class="hljs-keyword">package</span> errors<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在Go1.13的第一个发布版本时，errors包下加入了wrap.go文件。<strong>Unwrap()</strong> 正式替代了 Cause() 方法。</p><p>有兴趣可以看：<a href="https://github.com/golang/go/blob/go1.13/src/errors/wrap.go">https://github.com/golang/go/blob/go1.13/src/errors/wrap.go</a></p><h3 id="2-3-Only-handle-errors-once"><a href="#2-3-Only-handle-errors-once" class="headerlink" title="2.3. Only handle errors once"></a>2.3. Only handle errors once</h3><blockquote><p>I want to mention that you should only handle errors once. Handling an error means inspecting the error value, and making a decision.</p><p>我想提一下，你应该只处理一次错误。处理错误意味着检查错误值并做出决定。</p></blockquote><h4 id="2-3-1-妥善处理每一个错误"><a href="#2-3-1-妥善处理每一个错误" class="headerlink" title="2.3.1. 妥善处理每一个错误"></a>2.3.1. 妥善处理每一个错误</h4><p>我们来看一下没处理错误的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Data)</span></span> ConvData(b []<span class="hljs-type">byte</span>) &#123;<br>    ...... <span class="hljs-comment">// 其他逻辑</span><br>    ......<br>    json.Unmarshal(b, d)   <span class="hljs-comment">// &lt;---此处直接吞掉了Unmarshal()的返回值error</span><br>    ......<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查格式是否正确。</span><br><span class="hljs-comment">// 避免在发现 JSON 语法错误之前填写半个数据结构。</span><br><span class="hljs-keyword">var</span> d decodeState<br>err := checkValid(data, &amp;d.scan)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>d.init(data)<br><span class="hljs-keyword">return</span> d.unmarshal(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个<strong>非常不好的习惯</strong>，当<strong>b</strong>的内容不是一个合法的json结构时，<strong>Unmarshal()</strong> 的错误没有被外层感知，调用 <strong>ConvData()</strong> 的开发者很可能认为内部不会发生错误，且在<strong>d</strong>在必须非空数据的业务场景时引发了业务错误，并且难以排查。</p><p>正如 Rob Pike 所说：**”But remember: Whatever you do, always check your errors!”**</p><p>但万事都有极端情况，当你非常确认该错误可以忽略时，请你用 <strong>_</strong> (下划线显式说明忽略该返回值)，起到一定的提示作用。</p><p>（goland编辑器针对隐式省略返回值的代码行也会进行高亮提示）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Data)</span></span> ConvData(b []<span class="hljs-type">byte</span>) &#123;<br>    _ = json.Unmarshal(b, d)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-只处理错误一次"><a href="#2-3-2-只处理错误一次" class="headerlink" title="2.3.2. 只处理错误一次"></a>2.3.2. 只处理错误一次</h4><p>针对一个错误做出多个决定也是有问题的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>        _, err := w.Write(buf)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 带注释的错误进入日志文件</span><br>                log.Println(<span class="hljs-string">&quot;unable to write:&quot;</span>, err)<br>            <br>                <span class="hljs-comment">// 未注释的错误返回给调用者</span><br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，如果在 <code>Write</code> 期间发生错误，会将一行写入日志文件，记录发生错误的文件和行，并将错误也返回给上层。上层调用者可能也会记录日志并返回错误给上上层。最终，会在日志文件中得到一堆重复的行，但在最外层，仅仅得到一个没有任何上下文的原始错误。这样的日志会给排查问题的人带来疑惑，到底发生了几次错误呢？</p><p>因此推荐只处理错误一次。</p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4. 总结"></a>2.4. 总结</h3><p>最后，Dave Cheney给出了他的总结：</p><blockquote><p>In conclusion, errors are part of your package’s public API, treat them with as much care as you would any other part of your public API.</p><p>For maximum flexibility I recommend that you try to treat all errors as opaque. In the situations where you cannot do that, assert errors for behaviour, not type or value.</p><p>Minimise the number of sentinel error values in your program and convert errors to opaque errors by wrapping them with <code>errors.Wrap</code> as soon as they occur.</p><p>Finally, use <code>errors.Cause</code> to recover the underlying error if you need to inspect it.</p></blockquote><p>这些总结也成为了处理错误和设计自定义错误结构的准则：</p><ul><li><p><strong>首先，错误隶属于包中 公共API 的一部分，请像对待公共 API 的任何其他部分一样小心对待它们。</strong></p></li><li><p><strong>为了获得最大的灵活性，建议尝试将所有错误视为不透明的。在你不能这样做的情况下，断言错误的行为，而不是类型或值。</strong></p></li><li><p><strong>最大限度地减少程序中 Sentinel errors 的数量，并通过在错误发生时，立即使用<code>errors.Wrap</code>将其包装起来，将错误转换为 opaque errors。</strong></p></li><li><p><strong>最后，如果您需要检查错误原因，请使用<code>errors.Cause</code>来恢复底层错误。</strong></p></li></ul><p>最终，结合业务场景，目前已经诞生出非常多的自定义error结构方案，下面我们着重分析一下go-brick中的实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://golang.google.cn/doc/faq">https://golang.google.cn/doc/faq</a> [GO官方FAQ]</p></li><li><p><a href="https://studygolang.com/articles/1674">https://studygolang.com/articles/1674</a> [Russ Cox回应“Why I’m not leaving python for go”]</p></li><li><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a> [Dave Cheney阐述如何优雅处理error]</p></li><li><p><a href="https://go.dev/blog/errors-are-values">https://go.dev/blog/errors-are-values</a> [Rob Pike阐述错误处理思想]</p></li><li><p><a href="https://github.com/golang/go">https://github.com/golang/go</a> [go语言官方开源库]</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>error</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-资源泄露</title>
    <link href="/2022/05/09/golang/leak/"/>
    <url>/2022/05/09/golang/leak/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-资源泄露"><a href="#Golang-资源泄露" class="headerlink" title="Golang-资源泄露"></a>Golang-资源泄露</h1><p align="right">Lamber</p><p align="right">2022-05-09</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要记录一些生产环境中遇到的各种资源问题，及对应的排查、解决方法。</p><h2 id="1-HTTP-Body泄露（2022-05-09）"><a href="#1-HTTP-Body泄露（2022-05-09）" class="headerlink" title="1. HTTP-Body泄露（2022-05-09）"></a>1. HTTP-Body泄露（2022-05-09）</h2><ul><li><p>运维监控发现生产环境某服务所有节点出现OOM现象，但预发布、测试环境未出现该现象，初步判断内存泄露与请求数成正比关系。但该服务同时承载HTTP与gRPC请求，需要进一步排查。</p><ul><li>下图5月7日内存泄露现象。</li></ul></li></ul><p><img src="buffer_leak.jpg"></p><ul><li><p>使用pprof工具采集测试环境服务内存使用信息，将采集后的信息下载到本地稍后分析。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -G &lt;被测服务域名&gt;/debug/pprof/heap &gt; heap.profile<br></code></pre></td></tr></table></figure></li><li><p>使用go工具链绘制调用流程图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool pprof -http :8111 ./profile<br></code></pre></td></tr></table></figure></li></ul><p><img src="buffer_leak_profile.png"></p><ul><li><p>由图中可以发现http的newBufioReader后续操作存在内存泄露，查代码发现在http中间件中有对Body数据重置的情况，但没有关闭io.Reader，因此造成内存泄露。修复方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    _ = c.Request.Body.Close()<br>    c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(body))<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>但是光懂得Close()还不够，要理解为什么原来的Body没有被释放，这里涉及到bytes.Buffer的内部实现，在另外的文章记录。</p></li></ul><h2 id="2-定时器泄露（2023-02-27）"><a href="#2-定时器泄露（2023-02-27）" class="headerlink" title="2. 定时器泄露（2023-02-27）"></a>2. 定时器泄露（2023-02-27）</h2><ul><li>运维监控发现生产环境某2个微服务的cpu有持续上升趋势，并在测试环境中有相同的现象，初步判断是有某种工具泄露。<ul><li>下图2月28日前的cpu占用率是未修复前的现象，乘持续上升趋势，且该服务没有cpu密集型任务。27日下午修复后CPU占用率恢复正常。</li></ul></li></ul><p><img src="timer_leak_1.png"></p><ul><li><p>使用pprof工具采集测试环境服务30秒的CPU使用信息，将采集后的信息下载到本地稍后分析。</p><ul><li>我们的服务内嵌了pprof，使用白名单方式做安全限制。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl &lt;被测服务域名&gt;/debug/pprof/profile --output ./profile<br></code></pre></td></tr></table></figure></li><li><p>使用go工具链绘制调用流程图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool pprof -http :8111 ./profile<br></code></pre></td></tr></table></figure></li></ul><p><img src="timer_leak_profile_1.png"></p><ul><li>从图中发现占了86%CPU资源的是定时器，没有其他更有价值的线索了。并且只有2个服务出现该情况，排除是三方库导致的问题。于是定位该服务中所有使用定时器的地方。于是发现有一处代码循环创建定时器： <strong>time.NewTimer()</strong> ，但没有调用 <strong>Stop()</strong> 方法。<ul><li>解决方式比较简单，使用 <strong>Reset()</strong> 方法每次重试定时器即可，这里不列出代码了；</li><li>相对于解决问题，认识定时器内部实现还比较重要。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源项目-Ants-学习记录</title>
    <link href="/2022/01/05/golang/project_ants/"/>
    <url>/2022/01/05/golang/project_ants/</url>
    
    <content type="html"><![CDATA[<h1 id="开源项目-Ants-学习记录"><a href="#开源项目-Ants-学习记录" class="headerlink" title="开源项目-Ants-学习记录"></a>开源项目-Ants-学习记录</h1><p align="right">Lamber</p><p align="right">2022-01-05</p><h1 id="1-理论基础-amp-理念支撑"><a href="#1-理论基础-amp-理念支撑" class="headerlink" title="1. 理论基础&amp;理念支撑"></a>1. 理论基础&amp;理念支撑</h1><h2 id="1-1-什么是goroutine池？"><a href="#1-1-什么是goroutine池？" class="headerlink" title="1.1 什么是goroutine池？"></a>1.1 什么是goroutine池？</h2><p>goroutine池是许多goroutine的管理器，与线程池类似，它至少具备以下能力：</p><ul><li>控制池中每一个goroutine的生命周期（换句话说，能知道并控制池中每一个goroutine的退出时机）</li><li>控制池中goroutine的总量，并能感知池中各goroutine的”忙&#x2F;闲”状态，通过复用的方式将工作调度给”闲”状态的goroutine</li><li>阻塞&#x2F;非阻塞</li></ul><h2 id="1-2-是否需要协程池？"><a href="#1-2-是否需要协程池？" class="headerlink" title="1.2 是否需要协程池？"></a>1.2 是否需要协程池？</h2><p>这是一个备受争议的问题</p><p><strong>站在支持不需要的立场有以下理由：</strong></p><ul><li><p>随着Go版本的更新，goroutine也在不断地得到优化，例如1.4版本将一个goroutine堆栈缩减到2kb，官方有云”so they are cheap”，创建和调度都不需要进入内核，两者的操作对性能的影响可以忽略不计；</p></li><li><p>增加了逻辑复杂度，需要处理池的初始化与退出；</p></li><li><p>限制了并发数，造成性能瓶颈；</p></li></ul><p><strong>站在支持需要的立场有以下理由：</strong></p><ul><li>在封装接口内部保证池中某个gouroutine panic后能被recover，不影响到g0；</li><li>可通过调用封装好的API简单控制整组goroutine安全退出时；</li><li>复用goroutine，节省创建&#x2F;销毁goroutine时的CPU开销；</li><li>并发数可控，从而资源占用率可控；</li></ul><p><strong>最终得到的结论是，按具体的场景决定是否使用池：</strong></p><ul><li><p>如果接口访问量不够大，当前服务足以支撑，不需要使用池；如果服务每秒需要处理数千个中小型请求，并且需要一致的低毫秒响应时间，可以使用池来优化；这也就是net&#x2F;http与fasthttp两者的适用场景的区别；</p></li><li><p>如果需要在goroutine中批量创建goroutine执行分段任务（两级goroutine并行任务），并且需要限制瞬时资源占用率时，可以通过使用池来控制两级goroutine的笛卡尔积；而单级goroutine执行并发任务一般不需要使用池；</p></li><li><p>如果需要动态地控制某组goroutine启动执行与终止执行，可以考虑使用池快速实现；</p></li></ul><p><strong>看看业界中的场景与数据：</strong></p><ul><li><p>随着go版本不断提升，goroutine与gc的能力也在不断提高；</p><p>TiDB项目（Star：30.1k）在v2.0.8之后的版本中删除了util&#x2F;goroutine_pool&#x2F;gp.go，某种意义上为goroutine本身创建-&gt;调度-&gt;回收的效率正名；</p><p>有兴趣可以阅读一下：<a href="https://github.com/pingcap/tidb/blob/v2.0.8/util/goroutine_pool/gp.go">https://github.com/pingcap/tidb/blob/v2.0.8/util/goroutine_pool/gp.go</a></p></li><li><p>截止当前<strong>（2022-01-05）</strong></p><p>  ants项目（Star：7.4k）、fasthttp项目（Star：16.7k）对不使用池与使用池的情况输出了性能报告：</p><blockquote><p>下图摘自出自ants项目：</p></blockquote><p>  <img src="https://user-images.githubusercontent.com/7496278/63449727-3ae6d400-c473-11e9-81e3-8b3280d8288a.gif" alt="img"></p><ul><li>从该 demo 测试吞吐性能对比可以看出，使用<code>ants</code>的吞吐性能相较于原生 goroutine 可以保持在 2-6 倍的性能压制，而内存消耗则可以达到 10-20 倍的节省优势。（这是作者的原话）</li><li>goroutine数量在100k以下时，是否使用池，差距并不大。</li><li>总的来说，在必要场景下，用比不用好很多！！！</li></ul></li></ul><h1 id="2-ants-—-开源的goroutine池"><a href="#2-ants-—-开源的goroutine池" class="headerlink" title="2. ants — 开源的goroutine池"></a>2. ants — 开源的goroutine池</h1><blockquote><p>项目地址：<a href="https://github.com/panjf2000/ants">https://github.com/panjf2000/ants</a></p><ul><li>自动调度海量的 goroutines，复用 goroutines</li><li>定期清理过期的 goroutines，进一步节省资源</li><li>提供了大量有用的接口：任务提交、获取运行中的 goroutine 数量、动态调整 Pool 大小、释放 Pool、重启 Pool</li><li>优雅处理 panic，防止程序崩溃</li><li>资源复用，极大节省内存使用量；在大规模批量并发任务场景下比原生 goroutine 并发具有<a href="https://github.com/panjf2000/ants/blob/v2.3.0/README_ZH.md#-%E6%80%A7%E8%83%BD%E5%B0%8F%E7%BB%93">更高的性能</a></li><li>非阻塞机制</li></ul></blockquote><p>本篇<strong>基于v2.3.0版本</strong>学习，如果后面有时间的话，可能会逐个阅读其中的实现并记录下来吧~</p><h2 id="2-1-工作流程"><a href="#2-1-工作流程" class="headerlink" title="2.1 工作流程"></a>2.1 工作流程</h2><blockquote><p>下图引自：<a href="https://github.com/panjf2000/ants">https://github.com/panjf2000/ants</a></p></blockquote><p><img src="https://user-images.githubusercontent.com/7496278/66396519-7ed66e00-ea0c-11e9-9c1a-5ca54bbd61eb.png" alt="ants-flowchart-cn"></p><blockquote><p>从图中可以看出，当初始化池时，并没有马上创建所需数量的goroutine（worker），而是当有需要时才动态扩展，直到池中的goroutine熟练达到预设的最大值。这种弹性伸缩的设计方式，可以尽可能地让现有的资源（已创建的worker）得到复用，从而尽最大可能减少goroutine在创建与销毁、以及常驻时所占用的系统资源；</p></blockquote><h2 id="2-2-选项"><a href="#2-2-选项" class="headerlink" title="2.2 选项"></a>2.2 选项</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 选项包含实例化ants时将应用的所有选项。</span><br><span class="hljs-keyword">type</span> Options <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// ExpiryDuration 清理器清理无效worker的时间间隔</span><br>    <span class="hljs-comment">// 每隔`ExpiryDuration`的时间，清理器会扫描所有worker，并清理那些在`ExpiryDuration`时间段内没有被使用过的worker。</span><br>    <span class="hljs-comment">// 1秒 (默认值)</span><br>ExpiryDuration time.Duration<br><br>    <span class="hljs-comment">// PreAlloc 表示在初始化池时是否进行内存预分配。(即是否预创建size数量的goroutine)</span><br>PreAlloc <span class="hljs-type">bool</span><br><br>    <span class="hljs-comment">// pool.Submit 时最大的goroutine阻塞数(即等待执行的task缓冲区大小)</span><br><span class="hljs-comment">// 0 (默认值) 表示没有限制</span><br>MaxBlockingTasks <span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// Nonblocking 是否开启非阻塞模式</span><br><span class="hljs-comment">// 当 Nonblocking == true, Pool.Submit 将非阻塞，且MaxBlockingTasks参数无效。</span><br><span class="hljs-comment">// 当 Pool.Submit 不能执行时，返回ErrPoolOverload错误。</span><br>Nonblocking <span class="hljs-type">bool</span><br><br><span class="hljs-comment">// PanicHandler 每一个worker归属的goroutine内部的panic处理函数。</span><br>PanicHandler <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><br><span class="hljs-comment">// Logger 自定义的日志输出器，如果没有重新实现这个接口，ants会使用ants包内默认的logger</span><br>Logger Logger<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-使用"><a href="#2-3-使用" class="headerlink" title="2.3 使用"></a>2.3 使用</h2><h3 id="2-3-1-公共池"><a href="#2-3-1-公共池" class="headerlink" title="2.3.1 公共池"></a>2.3.1 公共池</h3><p>ants包在初始化时会自动申请一个公共池，代码如下：ants.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>......<br><br><span class="hljs-comment">// 导入ants时初始化的实例池</span><br>defaultAntsPool, _ = NewPool(DefaultAntsPoolSize)<br>)<br></code></pre></td></tr></table></figure><p>而池的最大容量为 DefaultAntsPoolSize</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// DefaultAntsPoolSize 是默认 goroutine 池的默认容量。</span><br>    DefaultAntsPoolSize = math.MaxInt32 <span class="hljs-comment">// MaxInt32 = 1&lt;&lt;31-1 (2147483647)</span><br><br><span class="hljs-comment">// DefaultCleanIntervalTime 是清理 goroutine 的间隔时间。</span><br>    DefaultCleanIntervalTime = time.Second <span class="hljs-comment">// time.Second (1秒)</span><br>)<br></code></pre></td></tr></table></figure><p>修改一下作者的示例代码并执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">demoFunc</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAntsCase1</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;running goroutines: %d\n&quot;</span>, ants.Running())<br><span class="hljs-keyword">defer</span> ants.Release()  <span class="hljs-comment">// 销毁ants公共池</span><br><br>runTimes := <span class="hljs-number">1000</span>      <span class="hljs-comment">// 执行次数</span><br><br><span class="hljs-comment">// 使用公共池测试</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>syncCalculateSum := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>demoFunc()<br>wg.Done()<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runTimes; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>_ = ants.Submit(syncCalculateSum)  <span class="hljs-comment">// 把func交给一个空闲的worker/创建一个新的worker执行</span><br>&#125;<br>wg.Wait()<br>    <br>fmt.Printf(<span class="hljs-string">&quot;running goroutines: %d\n&quot;</span>, ants.Running())<br>fmt.Printf(<span class="hljs-string">&quot;finish all tasks.\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">......<br>Hello World!  <span class="hljs-comment">// &lt;-- 省略了1000次输出</span><br>running goroutines: <span class="hljs-number">685</span>  <span class="hljs-comment">// &lt;--全部任务执行完成后的某瞬时未被清理的goroutine数量（这里可能包含被复用的与被清理后剩余的goroutine数量，因此没有打满1000个）</span><br>finish all tasks.<br>running goroutines: <span class="hljs-number">0</span>    <span class="hljs-comment">// &lt;--调用ants.Release()后的goroutine数量</span><br>--- PASS: TestAntsCase1 (<span class="hljs-number">0.07</span>s)  <span class="hljs-comment">// &lt;--这个执行时间虽然不太准确，但远不足1s，因此不存在被清理的goroutine。</span><br></code></pre></td></tr></table></figure><h3 id="2-3-2-非带参任务池（预分配容量）"><a href="#2-3-2-非带参任务池（预分配容量）" class="headerlink" title="2.3.2 非带参任务池（预分配容量）"></a>2.3.2 非带参任务池（预分配容量）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAntsCase2</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<br>pool, _ := ants.NewPool(<span class="hljs-number">2000</span>, ants.WithPreAlloc(<span class="hljs-literal">true</span>))  <span class="hljs-comment">// 启用预分配容量的选项</span><br><br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;running goroutines: %d\n&quot;</span>, pool.Running())<br><span class="hljs-keyword">defer</span> pool.Release()<br><br>runTimes := <span class="hljs-number">1000</span><br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>syncCalculateSum := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>demoFunc()<br>wg.Done()<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runTimes; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>_ = pool.Submit(syncCalculateSum)<br>&#125;<br>wg.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;running goroutines: %d\n&quot;</span>, pool.Running())<br>fmt.Printf(<span class="hljs-string">&quot;finish all tasks.\n&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">running goroutines: <span class="hljs-number">628</span><br>finish all tasks.<br>running goroutines: <span class="hljs-number">0</span><br>--- PASS: TestAntsCase1 (<span class="hljs-number">0.05</span>s)<br>PASS  <span class="hljs-comment">// 得到的结果与Case1相差无几</span><br></code></pre></td></tr></table></figure><h3 id="2-3-3-带参任务池"><a href="#2-3-3-带参任务池" class="headerlink" title="2.3.3 带参任务池"></a>2.3.3 带参任务池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sum <span class="hljs-type">int32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">myFunc</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>n := i.(<span class="hljs-type">int32</span>)<br>atomic.AddInt32(&amp;sum, n)   <span class="hljs-comment">// &lt;--原子+操作</span><br>fmt.Printf(<span class="hljs-string">&quot;run with %d\n&quot;</span>, n)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestAntsCase3</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    <span class="hljs-comment">// 新建一个带参func池，参数是interface&#123;&#125;类型，可传递任意类型参数。</span><br>pool, _ := ants.NewPoolWithFunc(<span class="hljs-number">1000</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>myFunc(i)<br>wg.Done()<br>&#125;)<br><br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;running goroutines: %d\n&quot;</span>, pool.Running())<br><span class="hljs-keyword">defer</span> pool.Release()<br><br>runTimes := <span class="hljs-number">1000</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; runTimes; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br>_ = pool.Invoke(<span class="hljs-type">int32</span>(i))<br>&#125;<br>wg.Wait()<br>fmt.Printf(<span class="hljs-string">&quot;running goroutines: %d\n&quot;</span>, pool.Running())<br>fmt.Printf(<span class="hljs-string">&quot;finish all tasks, result is %d\n&quot;</span>, sum)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">......<br>run with <span class="hljs-number">998</span><br>run with <span class="hljs-number">999</span>  <span class="hljs-comment">// &lt;-- 相对无序输出</span><br>run with <span class="hljs-number">992</span><br>running goroutines: <span class="hljs-number">677</span><br>finish all tasks, result is <span class="hljs-number">499500</span><br>running goroutines: <span class="hljs-number">0</span><br>--- PASS: TestAntsCase3 (<span class="hljs-number">0.04</span>s)<br>PASS<br></code></pre></td></tr></table></figure><h2 id="2-4-关键结构"><a href="#2-4-关键结构" class="headerlink" title="2.4 关键结构"></a>2.4 关键结构</h2><h3 id="2-4-1-pool"><a href="#2-4-1-pool" class="headerlink" title="2.4.1 pool"></a>2.4.1 pool</h3><p><strong>非带参任务池结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pool 接受来自客户端的任务，它通过回收 goroutines 将 goroutines 的总数限制在给定的数量。</span><br><span class="hljs-keyword">type</span> Pool <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// 池的容量，负值表示池的容量是无限的，</span><br>    <span class="hljs-comment">// 无限池用于避免由于池的嵌套使用而导致的无限阻塞的潜在问题：将任务提交给池，该池将新任务提交给同一个池。</span><br>capacity <span class="hljs-type">int32</span><br><br><span class="hljs-comment">// running 当前正在运行的 goroutines 的数量。</span><br>running <span class="hljs-type">int32</span><br><br><span class="hljs-comment">// lock 用于保护worker队列。</span><br>lock sync.Locker<br><br><span class="hljs-comment">// workers 存储可用worker的切片。（workerArray是一个接口，意味着该worker切片有多种数据结构）。</span><br>workers workerArray<br><br><span class="hljs-comment">// state 用于通知池自行关闭。</span><br>state <span class="hljs-type">int32</span><br><br>    <span class="hljs-comment">// cond 等待得到一个空闲的worker。(sync.Cond -- 条件变量)</span><br>cond *sync.Cond<br><br>    <span class="hljs-comment">// workerCache 在 function:retrieveWorker 中加速获取可用的 worker。(sync.Pool -- go官方对象池)</span><br>workerCache sync.Pool<br><br><span class="hljs-comment">// blockingNum 已经在 pool.Submit 上阻塞的 goroutine 的数量，受 pool.lock 保护</span><br>blockingNum <span class="hljs-type">int</span><br><br>    <span class="hljs-comment">// 选项</span><br>options *Options<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>带参任务池结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PoolWithFunc 接受来自客户端的任务，它通过回收 goroutines 将 goroutines 的总数限制在给定的数量。</span><br><span class="hljs-keyword">type</span> PoolWithFunc <span class="hljs-keyword">struct</span> &#123;<br>......<br>    <br>    <span class="hljs-comment">// workers切片，这里没有封装接口，而是直接暴露出切片结构。意味着该worker切片只有一种数据结构。</span><br>workers []*goWorkerWithFunc<br>    <br>    <span class="hljs-comment">// poolFunc 处理任务的函数。不意外，毕竟需要将参数传入之后回调。</span><br>poolFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><br>......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-2-worker"><a href="#2-4-2-worker" class="headerlink" title="2.4.2 worker"></a>2.4.2 worker</h3><p><strong>非带参worker</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goWorker 运行任务的实际执行者，它启动一个接受任务并执行函数调用的 goroutine。</span><br><span class="hljs-keyword">type</span> goWorker <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// pool 谁拥有这个worker。</span><br>pool *Pool<br><br><span class="hljs-comment">// task 需要执行的一项工作.</span><br>task <span class="hljs-keyword">chan</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><br><span class="hljs-comment">// recycleTime 把worker放回队列时会更新。（这个就是定时清理空闲worker的时间依据）</span><br>recycleTime time.Time<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>带参worker</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// goWorkerWithFunc 运行任务的实际执行者，它启动一个接受任务并执行函数调用的 goroutine。</span><br><span class="hljs-keyword">type</span> goWorkerWithFunc <span class="hljs-keyword">struct</span> &#123;<br>......<br>    <br><span class="hljs-comment">// args 这里有明显不一样，很明显这传递的直接就是提交时任务时的参数。</span><br>args <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-4-3-workerArray"><a href="#2-4-3-workerArray" class="headerlink" title="2.4.3 workerArray"></a>2.4.3 workerArray</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// workerArray 是一个接口</span><br><span class="hljs-keyword">type</span> workerArray <span class="hljs-keyword">interface</span> &#123;<br>    <span class="hljs-comment">// 求切片长度</span><br><span class="hljs-built_in">len</span>() <span class="hljs-type">int</span><br>    <span class="hljs-comment">// 判空</span><br>isEmpty() <span class="hljs-type">bool</span><br>    <span class="hljs-comment">// 添加worker</span><br>insert(worker *goWorker) <span class="hljs-type">error</span><br>    <span class="hljs-comment">// 获取worker</span><br>detach() *goWorker<br>    <span class="hljs-comment">// 查询出超时worker切片</span><br>retrieveExpiry(duration time.Duration) []*goWorker<br>    <span class="hljs-comment">// 重置</span><br>reset()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有两种实现：</strong></p><ul><li>栈型 - workerStack<ul><li>优势：节约资源，初始化时不需要创建满size个worker，按实际需求新增，size值可以设置较大；</li><li>劣势：在弹性增加worker时有额外的性能消耗，影响核心调度逻辑的效率；</li><li>场景：适合不需要很准确地预估所需worker数，对性能要求不是非常高的场景；</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> workerStack <span class="hljs-keyword">struct</span> &#123;<br>items  []*goWorker  <span class="hljs-comment">// 空闲的worker</span><br>expiry []*goWorker  <span class="hljs-comment">// 过期的worker</span><br>size   <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newWorkerStack</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> *workerStack &#123;<br><span class="hljs-keyword">return</span> &amp;workerStack&#123;<br>items: <span class="hljs-built_in">make</span>([]*goWorker, <span class="hljs-number">0</span>, size),<br>size:  size,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 新建worker时塞到切片末尾</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *workerStack)</span></span> insert(worker *goWorker) <span class="hljs-type">error</span> &#123;<br>wq.items = <span class="hljs-built_in">append</span>(wq.items, worker)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// 获取worker时从切片尾部获取，先进后出，符合栈的特点</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *workerStack)</span></span> detach() *goWorker &#123;<br>l := wq.<span class="hljs-built_in">len</span>()<br><span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>w := wq.items[l<span class="hljs-number">-1</span>]<br>wq.items[l<span class="hljs-number">-1</span>] = <span class="hljs-literal">nil</span> <span class="hljs-comment">// 避免内存泄漏，这里设计非常巧妙，下文会讲到</span><br>wq.items = wq.items[:l<span class="hljs-number">-1</span>]<br><br><span class="hljs-keyword">return</span> w<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>循环队列型 - loopQueue<ul><li>优势：性能高，初始化时创建满size个worker的空间，不需要耗费额外资源创建worker，更不会阻塞调度；</li><li>劣势：相对占用资源，且需要很准确地预估worker数，如果预估size值偏低，段时间内难以切换；</li><li>场景：适合能很准确地预估所需worker数，对性能要求非常高的场景；</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> loopQueue <span class="hljs-keyword">struct</span> &#123;<br>items  []*goWorker  <span class="hljs-comment">// 空闲的worker</span><br>expiry []*goWorker  <span class="hljs-comment">// 过期的worker</span><br>head   <span class="hljs-type">int</span>  <span class="hljs-comment">// 头下标</span><br>tail   <span class="hljs-type">int</span>  <span class="hljs-comment">// 尾下标</span><br>size   <span class="hljs-type">int</span><br>isFull <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newWorkerLoopQueue</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> *loopQueue &#123;<br><span class="hljs-keyword">return</span> &amp;loopQueue&#123;<br>items: <span class="hljs-built_in">make</span>([]*goWorker, size),  <span class="hljs-comment">// 由于是循环队列，这里先创建好了一个长度为size的切片</span><br>size:  size,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 下面使用了循环队列数据结构的相关算法，不赘述。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *loopQueue)</span></span> insert(worker *goWorker) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> wq.size == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> errQueueIsReleased<br>&#125;<br><br><span class="hljs-keyword">if</span> wq.isFull &#123;<br><span class="hljs-keyword">return</span> errQueueIsFull<br>&#125;<br>wq.items[wq.tail] = worker<br>wq.tail++<br><br><span class="hljs-keyword">if</span> wq.tail == wq.size &#123;<br>wq.tail = <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">if</span> wq.tail == wq.head &#123;<br>wq.isFull = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *loopQueue)</span></span> detach() *goWorker &#123;<br><span class="hljs-keyword">if</span> wq.isEmpty() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>w := wq.items[wq.head]<br>wq.items[wq.head] = <span class="hljs-literal">nil</span><br>wq.head++<br><span class="hljs-keyword">if</span> wq.head == wq.size &#123;<br>wq.head = <span class="hljs-number">0</span><br>&#125;<br>wq.isFull = <span class="hljs-literal">false</span><br><br><span class="hljs-keyword">return</span> w<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-5-关键方法"><a href="#2-5-关键方法" class="headerlink" title="2.5 关键方法"></a>2.5 关键方法</h2><h3 id="2-5-1-创建池"><a href="#2-5-1-创建池" class="headerlink" title="2.5.1 创建池"></a>2.5.1 创建池</h3><ul><li>*<em>NewPool(size int, options …Option) (<em>Pool, error)</em></em>  – 非带参任务池</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewPool generates an instance of ants pool.</span><br><span class="hljs-comment">// size    -- 池的最大goroutine数</span><br><span class="hljs-comment">// options -- 选项可变参数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPool</span><span class="hljs-params">(size <span class="hljs-type">int</span>, options ...Option)</span></span> (*Pool, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 加载选项组</span><br>    opts := loadOptions(options...)<br><br><span class="hljs-keyword">if</span> size &lt;= <span class="hljs-number">0</span> &#123;<br>size = <span class="hljs-number">-1</span><br>&#125;<br><br>    <span class="hljs-comment">// 校验清理间隔时间合法性</span><br><span class="hljs-keyword">if</span> expiry := opts.ExpiryDuration; expiry &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrInvalidPoolExpiry<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> expiry == <span class="hljs-number">0</span> &#123;<br>opts.ExpiryDuration = DefaultCleanIntervalTime<br>&#125;<br><br>    <span class="hljs-comment">// 检查是否需要使用默认的日志实例</span><br><span class="hljs-keyword">if</span> opts.Logger == <span class="hljs-literal">nil</span> &#123;<br>opts.Logger = defaultLogger<br>&#125;<br><br>    <span class="hljs-comment">// 初始化池对象</span><br>p := &amp;Pool&#123;<br>capacity: <span class="hljs-type">int32</span>(size),            <span class="hljs-comment">// 最大goroutine数</span><br>lock:     internal.NewSpinLock(), <span class="hljs-comment">// 自旋锁</span><br>options:  opts,                   <span class="hljs-comment">// 选项组</span><br>&#125;<br>    <span class="hljs-comment">// 在 function:retrieveWorker 中加速获取可用的 worker。</span><br>p.workerCache.New = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> &amp;goWorker&#123;<br>pool: p,                                <span class="hljs-comment">// 池指针</span><br>task: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>, workerChanCap), <span class="hljs-comment">// worker channel。workerChanCap -- channel缓冲区大小</span><br>&#125;<br>&#125;<br>    <span class="hljs-comment">// 是否预分配worker内存</span><br><span class="hljs-keyword">if</span> p.options.PreAlloc &#123;<br><span class="hljs-keyword">if</span> size == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrInvalidPreAllocSize<br>&#125;<br>        <span class="hljs-comment">// 新建 循环队列型 worker 组</span><br>p.workers = newWorkerArray(loopQueueType, size)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 新建 栈型 worker 组</span><br>p.workers = newWorkerArray(stackType, <span class="hljs-number">0</span>)<br>&#125;<br><br>    <span class="hljs-comment">// 条件变量（将自旋锁交给条件变量管理，条件变量与信号的配对操作，这里不赘述）</span><br>p.cond = sync.NewCond(p.lock)<br><br><span class="hljs-comment">// 启动一个 goroutine 定期清理过期的worker</span><br><span class="hljs-keyword">go</span> p.purgePeriodically()<br><br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>*<em>func NewPoolWithFunc(size int, pf func(interface{}), options …Option) (<em>PoolWithFunc, error)</em></em> – 带参任务池</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewPoolWithFunc 生成具有特定功能的ants池实例.</span><br><span class="hljs-comment">// size    -- 池的最大goroutine数</span><br><span class="hljs-comment">// pf      -- 带参任务函数（此函数会在分配到空闲worker时执行回调，此时可取得）</span><br><span class="hljs-comment">// options -- 选项可变参数组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPoolWithFunc</span><span class="hljs-params">(size <span class="hljs-type">int</span>, pf <span class="hljs-keyword">func</span>(<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>, options ...Option) (*PoolWithFunc, <span class="hljs-type">error</span>) &#123;<br>......<br><br>p := &amp;PoolWithFunc&#123;<br>capacity: <span class="hljs-type">int32</span>(size),<br>poolFunc: pf,<br>lock:     internal.NewSpinLock(),<br>options:  opts,<br>&#125;<br>p.workerCache.New = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> &amp;goWorkerWithFunc&#123;<br>pool: p,<br>args: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;, workerChanCap),<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> p.options.PreAlloc &#123;<br><span class="hljs-keyword">if</span> size == <span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, ErrInvalidPreAllocSize<br>&#125;<br>        <span class="hljs-comment">// 这里预分配直接使用了类似 栈型 worker组的方式处理，而没有向非带参任务池那样封装workerArray</span><br>        <span class="hljs-comment">// 其他逻辑与NewPool()一致，不赘述。 </span><br>p.workers = <span class="hljs-built_in">make</span>([]*goWorkerWithFunc, <span class="hljs-number">0</span>, size)<br>&#125;<br><br>......<br><br><span class="hljs-keyword">return</span> p, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-2-提交任务"><a href="#2-5-2-提交任务" class="headerlink" title="2.5.2 提交任务"></a>2.5.2 提交任务</h3><p>*<em>func (p <em>Pool) Submit(task func()) error</em></em> – 非带参池提交任务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Submit 向此池提交任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Submit(task <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 检查池是否已经关闭</span><br><span class="hljs-keyword">if</span> p.IsClosed() &#123;<br><span class="hljs-keyword">return</span> ErrPoolClosed<br>&#125;<br>    <span class="hljs-comment">// 新建一个worker指针</span><br><span class="hljs-keyword">var</span> w *goWorker<br>    <span class="hljs-comment">// 获取一个空闲的worker</span><br><span class="hljs-keyword">if</span> w = p.retrieveWorker(); w == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ErrPoolOverload<br>&#125;<br>    <span class="hljs-comment">// 将任务发到worker的任务管道中等待执行</span><br>w.task &lt;- task<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// retrieveWorker 返回一个可用的worker来执行task</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> retrieveWorker() (w *goWorker) &#123;<br>spawnWorker := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>w = p.workerCache.Get().(*goWorker)<br>w.run()<br>&#125;<br><br>    <span class="hljs-comment">// 这里对池加锁（这里使用的是自旋锁）</span><br>    <span class="hljs-comment">// 这里有一处非常精巧的设计：为什么没有使用defer去Unlock而是每处return再去Unlcok？</span><br>    <span class="hljs-comment">// 可以追到spawnWorker()的实现中讲述，workerCache是sync.Pool，</span><br>    <span class="hljs-comment">// sync.Pool内部实现已经是线程安全的操作，而且充分使用了GMP模型的特性，因此在调用它之前解锁，提高性能。</span><br>p.lock.Lock()<br><br>w = p.workers.detach()<br><span class="hljs-keyword">if</span> w != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 首先尝试从队列中获取worker</span><br>p.lock.Unlock()<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> capacity := p.Cap(); capacity == <span class="hljs-number">-1</span> || capacity &gt; p.Running() &#123;<br><span class="hljs-comment">// 如果队列是空的并且我们没有用完池容量，那么只需生成一个新的工作 goroutine。</span><br>p.lock.Unlock()<br>spawnWorker()<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则，我们将不得不阻止它们并等待至少一个worker被放回池中。</span><br><span class="hljs-keyword">if</span> p.options.Nonblocking &#123;<br>p.lock.Unlock()<br><span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 这里进入循环等待</span><br>retry:<br><span class="hljs-keyword">if</span> p.options.MaxBlockingTasks != <span class="hljs-number">0</span> &amp;&amp; p.blockingNum &gt;= p.options.MaxBlockingTasks &#123;<br>p.lock.Unlock()<br><span class="hljs-keyword">return</span><br>&#125;<br>p.blockingNum++<br>        <span class="hljs-comment">// 阻塞并等待可用的worker（这里有两处可以唤醒这个wait，1.归还worker 2.定时清理worker的定时器）</span><br>        <span class="hljs-comment">// 按条件变量的特性，cond内部的lock会先解锁然后阻塞等待唤醒，保证其他调用Submit()的逻辑有同等优先级抢资源</span><br>p.cond.Wait() <br>p.blockingNum--<br><span class="hljs-keyword">var</span> nw <span class="hljs-type">int</span><br>        <span class="hljs-keyword">if</span> nw = p.Running(); nw == <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 这里判断cond是否被是被定时清理worker的控制器唤醒，证明没有存活的worker，应该新建。调用spawnWorker()创建新的worker。</span><br>p.lock.Unlock()<br><span class="hljs-keyword">if</span> !p.IsClosed() &#123;<br>spawnWorker()<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 走到这里证明池中存在正在执行的worker，尝试取空闲的worker来复用。</span><br><span class="hljs-keyword">if</span> w = p.workers.detach(); w == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-comment">// 如果拿不到空闲的worker，判断现有的worker数未达容量上限，可以新建worker，否则重试。</span><br>            <span class="hljs-comment">// 这里为什么存在 = 的情况？因为p.Running()内部使用原子操作返回瞬时值，不受p.lock控制，</span><br>            <span class="hljs-comment">// 即走到这里其实nw并不实时，w == nil 代表可用worker为0的情况，因此需要重试。</span><br><span class="hljs-keyword">if</span> nw &lt; capacity &#123;<br>p.lock.Unlock()<br>spawnWorker()<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">goto</span> retry<br>&#125;<br><br>p.lock.Unlock()<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// run 启动一个 goroutine 以重复执行函数调用的过程。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *goWorker)</span></span> run() &#123;<br>    <span class="hljs-comment">// 原子+执行中的worker数</span><br>w.pool.incRunning()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-comment">// 原子-执行中的worker数</span><br>w.pool.decRunning()<br>w.pool.workerCache.Put(w)<br>            <span class="hljs-comment">// panic捕捉并恢复</span><br>            <span class="hljs-comment">// PanicHandler是选项，可以调用自定义的恢复处理方法</span><br><span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> ph := w.pool.options.PanicHandler; ph != <span class="hljs-literal">nil</span> &#123;<br>ph(p)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 默认恢复处理 -- 输出日志</span><br>                    <span class="hljs-comment">// 打印panic原因</span><br>w.pool.options.Logger.Printf(<span class="hljs-string">&quot;worker exits from a panic: %v\n&quot;</span>, p)<br>                    <span class="hljs-comment">// 打印运行时堆栈信息</span><br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">4096</span>]<span class="hljs-type">byte</span><br>n := runtime.Stack(buf[:], <span class="hljs-literal">false</span>)<br>w.pool.options.Logger.Printf(<span class="hljs-string">&quot;worker exits from panic: %s\n&quot;</span>, <span class="hljs-type">string</span>(buf[:n]))<br>&#125;<br>&#125;<br>            <span class="hljs-comment">// 在这里调用 Signal()，唤醒pool.cond.Wait()，告诉pool有空闲的worker可使用</span><br>w.pool.cond.Signal()<br>&#125;()<br><br>        <span class="hljs-comment">// 循环地从task管道中获取任务（这里就是这个goroutine能被循环复用的核心）</span><br><span class="hljs-keyword">for</span> f := <span class="hljs-keyword">range</span> w.task &#123;<br>            <span class="hljs-comment">// 这里有两种情况返回nil（1.池被释放 2.归属的worker空闲时间超过限制被定时器回收）</span><br><span class="hljs-keyword">if</span> f == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>            <span class="hljs-comment">// 执行非带参任务</span><br>f()<br>            <span class="hljs-comment">// 归还worker到pool.workerArray中</span><br><span class="hljs-keyword">if</span> ok := w.pool.revertWorker(w); !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>*<em>func (p <em>PoolWithFunc) Invoke(args interface{}) error</em></em> – 带参池提交任务</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *PoolWithFunc)</span></span> Invoke(args <span class="hljs-keyword">interface</span>&#123;&#125;) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> p.IsClosed() &#123;<br><span class="hljs-keyword">return</span> ErrPoolClosed<br>&#125;<br><span class="hljs-keyword">var</span> w *goWorkerWithFunc<br><span class="hljs-keyword">if</span> w = p.retrieveWorker(); w == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> ErrPoolOverload<br>&#125;<br>    <span class="hljs-comment">// 将参数发到worker的任务管道中等待执行，与Submit()内部实现原理大同小异，不赘述。</span><br>w.args &lt;- args<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-3-销毁池"><a href="#2-5-3-销毁池" class="headerlink" title="2.5.3 销毁池"></a>2.5.3 销毁池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Release 关闭此池并释放worker队列。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Release() &#123;<br>    <span class="hljs-comment">// 原子改变pool.state值</span><br>atomic.StoreInt32(&amp;p.state, CLOSED)<br>p.lock.Lock()<br>    <span class="hljs-comment">// 抢占锁并且重置worker队列</span><br>p.workers.reset()<br>p.lock.Unlock()<br>    <span class="hljs-comment">// 广播唤醒所有的pool.cond.Wait()，可能有一些调用者在retrieveWorker()中等待，所以我们需要唤醒它们以防止那些调用者无限阻塞。</span><br>    <span class="hljs-comment">// 想起上文中的if nw = p.Running(); nw == 0判断的处理方式了吗?</span><br>p.cond.Broadcast()<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 这里看workerStack的实现，队列型实现大同小异</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *workerStack)</span></span> reset() &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; wq.<span class="hljs-built_in">len</span>(); i++ &#123;<br>        <span class="hljs-comment">// 这里向worker.task管道发送一个nil，会触发上文中worker.fun()的for f := range w.task退出循环，从而退出当前的goroutine。</span><br>wq.items[i].task &lt;- <span class="hljs-literal">nil</span><br>        <span class="hljs-comment">// 这里有一处非常巧妙的设计：</span><br>        <span class="hljs-comment">// 给当前的worker切片中指向当前worker的指针值置为nil，及不再引用该地址，将促进GC回收该内存资源，起到节约内存的作用。</span><br>wq.items[i] = <span class="hljs-literal">nil</span><br>&#125;<br>    <span class="hljs-comment">// 切片置空</span><br>wq.items = wq.items[:<span class="hljs-number">0</span>]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-6-关键技术细节"><a href="#2-6-关键技术细节" class="headerlink" title="2.6 关键技术细节"></a>2.6 关键技术细节</h2><p>ants能够有这么优秀的性能，取决于内部有多个非常巧妙的设计！</p><h3 id="2-6-1-缓冲区大小"><a href="#2-6-1-缓冲区大小" class="headerlink" title="2.6.1 缓冲区大小"></a>2.6.1 缓冲区大小</h3><p><strong>workerChanCap</strong> – channel缓冲区大小，chan性能调优方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// workerChanCap 确定worker的通道是否应该是缓冲通道以获得最佳性能。</span><br><span class="hljs-comment">// 受 fasthttp 启发</span><br><span class="hljs-comment">// https://github.com/valyala/fasthttp/blob/master/workerpool.go#L139</span><br>workerChanCap = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 如果 GOMAXPROCS=1 使用阻塞的 channel </span><br><span class="hljs-comment">// 这会立即将上下文从发送方切换到接收方，从而提高性能（至少在 go1.5 下）。这里是拿当前设备的CPU逻辑核心数。</span><br><span class="hljs-keyword">if</span> runtime.GOMAXPROCS(<span class="hljs-number">0</span>) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// 如果 GOMAXPROCS&gt;1 使用非阻塞 workerChan </span><br><span class="hljs-comment">// 否则，如果接收者受 CPU 限制，则发送者可能会被拖下。</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;()<br></code></pre></td></tr></table></figure><p><strong>GOMAXPROCS()</strong> – go官方包获取CPU逻辑核心数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GOMAXPROCS 设置可以同时执行的最大 CPU 数量并返回之前的设置。它默认为 runtime.NumCPU 的值。</span><br><span class="hljs-comment">// 如果 n &lt; 1，则不会更改当前设置。</span><br><span class="hljs-comment">// 当调度器改进时，这个调用将消失。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GOMAXPROCS</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> GOARCH == <span class="hljs-string">&quot;wasm&quot;</span> &amp;&amp; n &gt; <span class="hljs-number">1</span> &#123;<br>n = <span class="hljs-number">1</span> <span class="hljs-comment">// WebAssembly 还没有线程，所以只有一个 CPU 是可能的。</span><br>&#125;<br><br>lock(&amp;sched.lock)<br>ret := <span class="hljs-type">int</span>(gomaxprocs)<br>unlock(&amp;sched.lock)<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">0</span> || n == ret &#123;<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br>stopTheWorldGC(<span class="hljs-string">&quot;GOMAXPROCS&quot;</span>)<br><br><span class="hljs-comment">// newprocs 将由 startTheWorld 处理</span><br>newprocs = <span class="hljs-type">int32</span>(n)<br><br>startTheWorldGC()<br><span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-2-自旋锁"><a href="#2-6-2-自旋锁" class="headerlink" title="2.6.2 自旋锁"></a>2.6.2 自旋锁</h3><p><strong>SpinLock</strong> – 自旋锁</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> internal<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;runtime&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;sync/atomic&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> spinLock <span class="hljs-type">uint32</span><br><br><span class="hljs-keyword">const</span> maxBackoff = <span class="hljs-number">16</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sl *spinLock)</span></span> Lock() &#123;<br>backoff := <span class="hljs-number">1</span><br>    <span class="hljs-comment">// 这里使用原子操作实现自旋锁，非常地轻量。</span><br>    <span class="hljs-comment">// 与其他类型的锁不同，自旋锁在加锁失败之后不会立刻进入等待，而是会继续尝试。</span><br>    <span class="hljs-comment">// 这对于很快就能获得锁的应用来说能极大提升性能，因为能避免加锁和解锁导致的线程切换</span><br><span class="hljs-keyword">for</span> !atomic.CompareAndSwapUint32((*<span class="hljs-type">uint32</span>)(sl), <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) &#123;<br><span class="hljs-comment">// 利用指数退避算法, 看 https://en.wikipedia.org/wiki/Exponential_backoff.</span><br>        <span class="hljs-comment">// 先等1个循环周期，通过runtime.Gosched()告诉运行时切换其他 goroutine 运行。如果还是获取不到锁，就再等2个周期。如果还是不行，再等 4，8，16...以此类推。这可以防止短时间内获取不到锁，导致 CPU 时间的浪费。</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; backoff; i++ &#123;<br>runtime.Gosched()<br>&#125;<br><span class="hljs-keyword">if</span> backoff &lt; maxBackoff &#123;<br>backoff &lt;&lt;= <span class="hljs-number">1</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sl *spinLock)</span></span> Unlock() &#123;<br>atomic.StoreUint32((*<span class="hljs-type">uint32</span>)(sl), <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-comment">// NewSpinLock instantiates a spin-lock.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewSpinLock</span><span class="hljs-params">()</span></span> sync.Locker &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(spinLock)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-3-过期回收"><a href="#2-6-3-过期回收" class="headerlink" title="2.6.3 过期回收"></a>2.6.3 过期回收</h3><p><strong>workerStack.retrieveExpiry()</strong> – 利用有序性进行高效的过期扫描</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 栈型 worker切片管理器的 检索到期worker组</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *workerStack)</span></span> retrieveExpiry(duration time.Duration) []*goWorker &#123;<br>n := wq.<span class="hljs-built_in">len</span>()<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>expiryTime := time.Now().Add(-duration)<br>    <span class="hljs-comment">// 使用二分查找法找到已过期的最近一个 worker。</span><br>    <span class="hljs-comment">// 由于过期时间是按照 goroutine 执行任务后的空闲时间计算的，而workerStack.insert()入队顺序决定它们的过期时间是从早到晚的（有序的）。</span><br>index := wq.binarySearch(<span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, expiryTime)<br><br>wq.expiry = wq.expiry[:<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> index != <span class="hljs-number">-1</span> &#123;<br>wq.expiry = <span class="hljs-built_in">append</span>(wq.expiry, wq.items[:index+<span class="hljs-number">1</span>]...)<br>m := <span class="hljs-built_in">copy</span>(wq.items, wq.items[index+<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">for</span> i := m; i &lt; n; i++ &#123;<br>wq.items[i] = <span class="hljs-literal">nil</span><br>&#125;<br>wq.items = wq.items[:m]<br>&#125;<br><span class="hljs-keyword">return</span> wq.expiry<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 二分查找法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wq *workerStack)</span></span> binarySearch(l, r <span class="hljs-type">int</span>, expiryTime time.Time) <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> mid <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> l &lt;= r &#123;<br>mid = (l + r) / <span class="hljs-number">2</span><br><span class="hljs-keyword">if</span> expiryTime.Before(wq.items[mid].recycleTime) &#123;<br>r = mid - <span class="hljs-number">1</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>l = mid + <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> r<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-题外话"><a href="#3-题外话" class="headerlink" title="3. 题外话"></a>3. 题外话</h1><h2 id="3-1-为什么需要带参任务池？"><a href="#3-1-为什么需要带参任务池？" class="headerlink" title="3.1 为什么需要带参任务池？"></a>3.1 为什么需要带参任务池？</h2><p>因为明确地传参，可以很好地避免【闭包陷阱：延迟绑定】。</p><p>有兴趣可以执行下以下Case1~Case5，多执行几遍对比结果，加深理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">second</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> x &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">6</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">first</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (y <span class="hljs-type">int</span>) &#123;<br>w := sync.WaitGroup&#123;&#125;<br>w.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>y = second(x)<br>w.Done()<br>&#125;()<br>w.Wait()<br><span class="hljs-keyword">return</span> y<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCase1</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>x := i<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>y := first(x)<br>fmt.Printf(<span class="hljs-string">&quot;%d - %d\n&quot;</span>, x, y)<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCase2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>y := first(i)<br>fmt.Printf(<span class="hljs-string">&quot;%d - %d\n&quot;</span>, i, y)<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCase3</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> &#123;<br>y := first(x)<br>fmt.Printf(<span class="hljs-string">&quot;%d - %d\n&quot;</span>, x, y)<br>&#125;(i)<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCase4</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> *i = <span class="hljs-number">1</span>; *i &lt;= <span class="hljs-number">5</span>; *i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x = i<br>y := first(*x)<br>fmt.Printf(<span class="hljs-string">&quot;%d - %d\n&quot;</span>, *x, y)<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCase5</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> *i = <span class="hljs-number">1</span>; *i &lt;= <span class="hljs-number">5</span>; *i++ &#123;<br><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*x = *i<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>y := first(*x)<br>fmt.Printf(<span class="hljs-string">&quot;%d - %d\n&quot;</span>, *x, y)<br>&#125;()<br>&#125;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://github.com/panjf2000/ants/tree/v2.3.0">https://github.com/panjf2000/ants/tree/v2.3.0</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>ants</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-指针</title>
    <link href="/2021/08/02/golang/pointer/"/>
    <url>/2021/08/02/golang/pointer/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-指针"><a href="#Golang-指针" class="headerlink" title="Golang-指针"></a>Golang-指针</h1><p align="right">Lamber</p><p align="right">2021-08-02</p><h2 id="1-什么是指针"><a href="#1-什么是指针" class="headerlink" title="1. 什么是指针"></a>1. 什么是指针</h2><h3 id="1-1-历史"><a href="#1-1-历史" class="headerlink" title="1.1 历史"></a>1.1 历史</h3><p>引自：<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">https://en.wikipedia.org/wiki/Pointer_(computer_programming)</a></p><blockquote><p>在1964年，<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E7%BE%85%E5%BE%B7%C2%B7%E5%8B%9E%E6%A3%AE">哈罗德·劳森</a>发明了最早的指针。他在<a href="https://zh.wikipedia.org/wiki/PL/I">PL&#x2F;I</a>中实现出了这个概念，其他高级编程语言也很快跟进，使用了这个想法。指针（pointer）这个名称首次出现在系统发展公司（System Development Corporation，SDC）的技术文件，当中使用了堆栈指针（stack pointer）这个名词。</p></blockquote><h3 id="1-2-简介"><a href="#1-2-简介" class="headerlink" title="1.2 简介"></a>1.2 简介</h3><p>引自：<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">https://en.wikipedia.org/wiki/Pointer_(computer_programming)</a></p><blockquote><p>在计算机科学中，指针是许多编程语言中的一个对象，用于存储一个内存地址。它可以是位于计算机内存中的另一个值，或者在某些情况下，是内存映射的计算机硬件的值。指针引用(referencing)了内存中的一个位置，获得存储在该位置的值被称为解引用(dereferencing)。</p><p>做一个比喻，一本书索引中的页码可以被认为是一个指向相应页面的指针；通过翻到具有给定页码的页面并阅读该页面上的文本，就可以对这样一个指针进行解引用。指针变量的实际格式和内容取决于底层计算机结构。</p><p>使用指针可以显著提高重复性操作的性能，如遍历可迭代数据结构（如字符串、查找表、控制表和树形结构）。特别是，在时间和空间上，复制和取消引用指针往往比复制和访问指针所指向的数据要便宜得多。</p><p>指针也被用来保存程序设计中被调用的子程序的入口点地址，以及运行时链接到动态链接库（DLL）。在面向对象编程中，函数的指针用于绑定方法，通常使用虚拟方法表（这里说的是C++的虚函数表）。</p><p>但是指针本身也存在一些可被滥用之处，在访问某个数据结构时，可能会超出可用范围，使软件或操作系统出现异常，严重时可造成死机。利用指针去访问或修改非合法可取用的资料，也可能造成安全性问题。为此，C与C++语言规定指针类型为<a href="https://zh.wikipedia.org/wiki/%E5%BC%B1%E7%B1%BB%E5%9E%8B">强类型</a>，即指针值不仅是一个内存地址，同时它的数据类型说明了存在这个地址可以安全访问的地址的范围，例如，float<em>可以访问4个字节的内存空间，double</em>可以访问8个字节的内存空间。</p><p>许多编程语言中都支持某种形式的指针，最著名的是<a href="https://zh.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C语言</a>，但是有些编程语言对指针的运用采取比较严格的限制。因为指针的机制比较简单，其功能可以被集中重新实现成更抽象化的<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>（reference）资料形别，如<a href="https://zh.wikipedia.org/wiki/Java">Java</a>一般避免用指针，改为使用<a href="https://zh.wikipedia.org/wiki/%E5%8F%83%E7%85%A7">引用</a>。</p></blockquote><p><img src="pointer.png"></p><center>上图源自：https://www.runoob.com/cprogramming/c-pointers.html</center><h3 id="1-3-为什么需要指针？"><a href="#1-3-为什么需要指针？" class="headerlink" title="1.3 为什么需要指针？"></a>1.3 为什么需要指针？</h3><ol><li>提供了一种间接的途径来访问和修改值；</li><li>提高”大体积”的数据结构或数据类型在方法间的效率；</li><li>在某些语言中(如C&#x2F;C++)，直接控制变量的生命周期；</li></ol><h3 id="1-4-内存堆栈空间"><a href="#1-4-内存堆栈空间" class="headerlink" title="1.4 内存堆栈空间"></a>1.4 内存堆栈空间</h3><blockquote><p>内存堆栈空间有非常多的知识点，本篇只记录与指针有关的部分。</p></blockquote><p><img src="memory.jpg"></p><center>上图源自：https://www.cnblogs.com/clover-toeic/p/3754433.html</center><p>在用户内存空间中，栈(stack)和堆(heap)，如上图所示。</p><p>栈由高地址向低地址延伸，堆由低地址向高地址延伸。</p><p>在C&#x2F;C++中，堆栈空间的边界可以很清晰地看到，并且<strong>需要编程人员自己决策</strong>内存从堆还是在栈中分配：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdio.h&quot;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-number">4</span> <br> <span class="hljs-number">5</span> <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"> 8 </span>&#123;<br> <span class="hljs-number">9</span>     <span class="hljs-type">int</span> *p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span>);   &lt;-- 通过<span class="hljs-keyword">new</span>()方法，在堆上开辟空间<br><span class="hljs-number">10</span>     <span class="hljs-type">int</span> *p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">2</span>);<br><span class="hljs-number">11</span> <br><span class="hljs-number">12</span>     <span class="hljs-type">int</span> p3 = <span class="hljs-number">3</span>;   &lt;-- 不通过<span class="hljs-keyword">new</span>()方法，在栈上开辟空间<br><span class="hljs-number">13</span>     <span class="hljs-type">int</span> p4 = <span class="hljs-number">4</span>;<br><span class="hljs-number">14</span> <br><span class="hljs-number">15</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p1: %016p\n&quot;</span>, p1);<br><span class="hljs-number">16</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p2: %016p\n&quot;</span>, p2);<br><span class="hljs-number">17</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p3: %016p\n&quot;</span>, &amp;p3);<br><span class="hljs-number">18</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;p4: %016p\n&quot;</span>, &amp;p4);<br><span class="hljs-number">19</span> <br><span class="hljs-number">20</span>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-number">21</span>         <span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-number">22</span>     &#125;<br><span class="hljs-number">23</span> <br><span class="hljs-number">24</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">25</span> &#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@czy memory]# ./a.out <br>p1: 0x000000016f2010<br>p2: 0x000000016f2030   // &lt;-- p1和p2在堆上申请，内存地址由低往高<br>p3: 0x007ffcfb6dfb7c<br>p4: 0x007ffcfb6dfb78<br></code></pre></td></tr></table></figure><p>我们看下这时a.out进程的内存分配信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@czy ~]# ps -ef | grep a.out<br>root      18707  18389  0 19:01 pts/1    00:00:00 ./a.out<br>root      18751  18708  0 19:02 pts/2    00:00:00 grep --color=auto a.out<br>[root@czy ~]# cd /proc/18707<br>[root@czy 18707]# cat maps <br>00400000-00401000 r-xp 00000000 fd:00 4579414                            /usr/local/tools/share/memory/a.out<br>00600000-00601000 r--p 00000000 fd:00 4579414                            /usr/local/tools/share/memory/a.out<br>00601000-00602000 rw-p 00001000 fd:00 4579414                            /usr/local/tools/share/memory/a.out<br>016f2000-01713000 rw-p 00000000 00:00 0                                  [heap]<br>7f731e061000-7f731e223000 r-xp 00000000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e223000-7f731e423000 ---p 001c2000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e423000-7f731e427000 r--p 001c2000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e427000-7f731e429000 rw-p 001c6000 fd:00 148315                     /usr/lib64/libc-2.17.so<br>7f731e429000-7f731e42e000 rw-p 00000000 00:00 0 <br>7f731e42e000-7f731e443000 r-xp 00000000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e443000-7f731e642000 ---p 00015000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e642000-7f731e643000 r--p 00014000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e643000-7f731e644000 rw-p 00015000 fd:00 2776485                    /usr/lib64/libgcc_s-4.8.5-20150702.so.1<br>7f731e644000-7f731e745000 r-xp 00000000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e745000-7f731e944000 ---p 00101000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e944000-7f731e945000 r--p 00100000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e945000-7f731e946000 rw-p 00101000 fd:00 148323                     /usr/lib64/libm-2.17.so<br>7f731e946000-7f731ea2f000 r-xp 00000000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ea2f000-7f731ec2e000 ---p 000e9000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ec2e000-7f731ec36000 r--p 000e8000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ec36000-7f731ec38000 rw-p 000f0000 fd:00 2987710                    /usr/lib64/libstdc++.so.6.0.19<br>7f731ec38000-7f731ec4d000 rw-p 00000000 00:00 0 <br>7f731ec4d000-7f731ec6f000 r-xp 00000000 fd:00 2776504                    /usr/lib64/ld-2.17.so<br>7f731ee53000-7f731ee58000 rw-p 00000000 00:00 0 <br>7f731ee6c000-7f731ee6e000 rw-p 00000000 00:00 0 <br>7f731ee6e000-7f731ee6f000 r--p 00021000 fd:00 2776504                    /usr/lib64/ld-2.17.so<br>7f731ee6f000-7f731ee70000 rw-p 00022000 fd:00 2776504                    /usr/lib64/ld-2.17.so<br>7f731ee70000-7f731ee71000 rw-p 00000000 00:00 0 <br>7ffcfb6c0000-7ffcfb6e1000 rw-p 00000000 00:00 0                          [stack]<br>7ffcfb701000-7ffcfb703000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br></code></pre></td></tr></table></figure><p>重点关注这两行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">016f2000-01713000 rw-p 00000000 00:00 0                                  [heap]<br>7ffcfb6c0000-7ffcfb6e1000 rw-p 00000000 00:00 0                          [stack]<br></code></pre></td></tr></table></figure><p>对比程序中的打印信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">p1: 0x000000016f2010<br>p2: 0x000000016f2030   // &lt;-- p1和p2落在016f2000-01713000的内存空间上[heap]<br>p3: 0x007ffcfb6dfb7c<br>p4: 0x007ffcfb6dfb78   // &lt;-- p3和p4落在7ffcfb6c0000-7ffcfb6e1000的内存空间上[stack]<br></code></pre></td></tr></table></figure><p>Go也有**New()**方法，通过New()申请的内存空间是否也存在于heap上呢？这里我带着疑问往下学习。</p><h3 id="1-5-Golang的指针"><a href="#1-5-Golang的指针" class="headerlink" title="1.5 Golang的指针"></a>1.5 Golang的指针</h3><p>引自：<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Go">https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Go</a></p><blockquote><p><a href="https://en.wikipedia.org/wiki/Go_(programming_language)">Go</a> has pointers. Its declaration syntax is equivalent to that of C, but written the other way around, ending with the type. Unlike C, Go has garbage collection, and disallows pointer arithmetic. Reference types, like in C++, do not exist. Some built-in types, like maps and channels, are boxed (i.e. internally they are pointers to mutable structures), and are initialized using the <code>make</code> function. In an approach to unified syntax between pointers and non-pointers, the arrow (<code>-&gt;</code>) operator has been dropped: the dot operator on a pointer refers to the field or method of the dereferenced object. This, however, only works with 1 level of indirection.</p></blockquote><blockquote><p>Go有指针。它的声明语法等同于C语言，但反过来写，以类型结束。与C不同的是，Go有垃圾收集（GC），并且不允许指针运算。像C++中的引用类型并不存在。一些内置类型，如map和channel，是盒式的（即在内部它们是指向可变结构的指针），并使用make函数进行初始化。为了统一指针和非指针之间的语法，箭头（-&gt;）操作符被放弃了：指针上的点操作符指的是被解引用对象的字段或方法。然而，这只适用于一级指针(1 level of indirection)。</p></blockquote><p>引自：《go101》：</p><blockquote><p>一个内存地址表示操作系统管理的整个内存中的一个偏移量（相对于从整个内存的起始， 以字节计数）。</p><p>通常地，一个内存地址用一个操作系统原生字（native word）来存储。 一个原生字在32 位操作系统上占4个字节，在64位操作系统上占8个字节。所以，32位操作系统上的理论 最大支持内存容量为4GB（1GB &#x3D;&#x3D; 2 30字节），64位操作系统上的理论最大支持内存容量 为2^64Byte，即16EB（EB：艾字节，1EB &#x3D;&#x3D; 1024PB, 1PB &#x3D;&#x3D; 1024TB, 1TB &#x3D;&#x3D; 1024GB）。 </p><p>内存地址的字面形式常用整数的十六进制字面量来表示，比如0x1234CDEF。 以后我们常简称内存地址为地址。</p><p>为了安全起见，Go指针在使用上相对于C指针有很多限制。 通过施加这些限制，Go指针保 留了C指针的好处，同时也避免了C指针的危险性。</p></blockquote><ul><li><p>因为在C&#x2F;C++中，没有GC帮忙回收堆内存，指针存储的堆栈地址是需要显式调用 free()&#x2F;delete() 释放的，并且释放后需要重新把指针指向NULL，否则会产生许多严重后果：</p><ol><li><p>指针原本指向的堆内存没有被释放，又指向了另一块堆内存，从而导致原本申请的堆内存块无法被找到且释放（<strong>内存泄露</strong>）；</p></li><li><p>访问指向为NULL的指针，会产生<strong>空指针错误</strong>而让程序崩溃（<strong>Segment fault</strong>）；</p></li><li><p>如果指针指向的地址空间被释放，但未置NULL，且恰好被其他逻辑复用，那么代码逻辑的走向将不能控制（<strong>野指针</strong>）。这时段错误已经是最好的后果，其他后果例如不知为什么其他代码逻辑走向非常诡异 或 使得其他代码段访问相同地址后段错误，造成其他代码段有问题的假象。</p></li></ol></li><li><p><strong>庆幸的是</strong>，Go拥有runtime和GC，并且刻意地”隐藏”裸指针。</p></li></ul><p>​因此我们只需要考虑以上的一种情况情况：<strong>空指针</strong>。</p><p>​在Go中，访问空指针，会触发panic。</p><ul><li><p><strong>Go是如何限制指针操作来避免上述问题的呢？</strong></p><ol><li><p>Go指针不支持算术运算</p><blockquote><p>在Go中，指针是不能参与算术运算的。比如，对于一个指针p， 运算p++和p-2都是非法 的。</p></blockquote></li><li><p>一个指针类型的值不能被随意转换为另一个指针类型</p>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int64</span> <br><span class="hljs-keyword">type</span> Ta *<span class="hljs-type">int64</span> <br><span class="hljs-keyword">type</span> Tb *MyInt<br></code></pre></td></tr></table></figure><blockquote><p>对于上面所示的这些指针类型，下面的事实成立： </p><ol><li>类型*int64的值可以被隐式转换到类型Ta，反之亦然（因为它们的底层类型均 为*int64）。 </li><li>类型*MyInt的值可以被隐式转换到类型Tb，反之亦然（因为它们的底层类型均 为*MyInt）。 </li><li>类型MyInt的值可以被显式转换为类型*int64，反之亦然（因为它们都是非定义 的并且它们的基类型的底层类型均为int64）。 </li><li>类型Ta的值不能直接被转换为类型Tb，即使是显式转换也是不行的。 但是，通过 上述三条事实，通过三层显式转换Tb((*MyInt)((*int64)(ta)))，一个类型 为Ta的值ta可以被间接地转换为类型Tb。 </li><li>这些指针类型的任何值都无法被转换到类型*uint64。</li></ol></blockquote></li><li><p>一个指针值不能和其它任一指针类型的值进行比较</p><blockquote><p>Go指针值是支持（使用比较运算符&#x3D;&#x3D;和!&#x3D;）比较的。 </p><p>但是，两个指针只有在下列任一 条件被满足的时候才可以比较： </p><ol><li>这两个指针的类型相同。 </li><li>其中一个指针可以被隐式转换为另一个指针的类型。换句话说，这两个指针的类型 的底层类型必须一致并且其中一个指针类型为非定义的（考虑结构体字段的标签）。 </li><li>其中一个并且只有一个指针用类型不确定的nil标识符表示。</li></ol></blockquote>   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int64</span><br><span class="hljs-keyword">type</span> Ta *<span class="hljs-type">int64</span><br><span class="hljs-keyword">type</span> Tb *MyInt<br><br><span class="hljs-comment">// 4个不同类型的指针：</span><br><span class="hljs-keyword">var</span> pa0 Ta<br> <span class="hljs-keyword">var</span> pa1 *<span class="hljs-type">int64</span><br> <span class="hljs-keyword">var</span> pb0 Tb<br> <span class="hljs-keyword">var</span> pb1 *MyInt<br><br> <span class="hljs-comment">// 下面这6行编译没问题。它们的比较结果都为true。</span><br> _ = pa0 == pa1<br> _ = pb0 == pb1<br> _ = pa0 == <span class="hljs-literal">nil</span><br> _ = pa1 == <span class="hljs-literal">nil</span><br> _ = pb0 == <span class="hljs-literal">nil</span><br> _ = pb1 == <span class="hljs-literal">nil</span><br><br> <span class="hljs-comment">// 下面这三行编译不通过。</span><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment"> _ = pa0 == pb0</span><br><span class="hljs-comment"> _ = pa1 == pb1</span><br><span class="hljs-comment"> _ = pa0 == Tb(nil)</span><br><span class="hljs-comment"> */</span><br> &#125;<br>一个指针值不能被赋值给其它任意类型的指针值<br></code></pre></td></tr></table></figure></li><li><p>一个指针值不能被赋值给其它任意类型的指针值</p><blockquote><p>一个指针值可以被赋值给另一个指针值的条件和这两个指针值可以比较的条件（见上一小 节）是一致的。</p></blockquote><p>   <strong>但是！上述Go指针的限制是可以被打破的</strong>，Go给老哥们开了一道”后门”。</p><blockquote><p>unsafe标准库包中提供的非类型安全指针（unsafe.Pointer）机制可以被 用来打破上述Go指针的安全限制。 </p><p>unsafe.Pointer类型类似于C语言中的void*。</p><p>但是，非类型安全指针机制不推荐在Go业务编码中使用，而偏向于解决抽象性问题，例如封装一些通用的工具方法。</p></blockquote></li></ol></li></ul><h2 id="2-Go指针的使用姿势"><a href="#2-Go指针的使用姿势" class="headerlink" title="2. Go指针的使用姿势"></a>2. Go指针的使用姿势</h2><h3 id="2-1-指针（一级指针-）"><a href="#2-1-指针（一级指针-）" class="headerlink" title="2.1 指针（一级指针 *）"></a>2.1 指针（一级指针 *）</h3><p>最常见的指针形式，不赘述。</p><h3 id="2-2-空指针（nil）"><a href="#2-2-空指针（nil）" class="headerlink" title="2.2 空指针（nil）"></a>2.2 空指针（nil）</h3><blockquote><p>空指针-没有存储任何内存地址的指针。</p></blockquote><p>在go中，声明一个空指针类型，可以用nil表示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNilPtr</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// 以下两句效果等价</span><br><span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b *<span class="hljs-type">int</span> = <span class="hljs-literal">nil</span><br>fmt.Println(a)<br>fmt.Println(b)<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// === RUN   TestNilPtr</span><br><span class="hljs-comment">// &lt;nil&gt;</span><br><span class="hljs-comment">// &lt;nil&gt;</span><br><span class="hljs-comment">// --- PASS: TestNilPtr (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><h3 id="2-3-取地址（-amp-）"><a href="#2-3-取地址（-amp-）" class="headerlink" title="2.3 取地址（&amp;）"></a>2.3 取地址（&amp;）</h3><p>获得一个变量的地址，用以赋予给一个指针变量。使用%p，可以格式化打印变量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrGetAddr</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br>a = &amp;b<br>fmt.Println(a)<br>fmt.Println(&amp;b)<br>    fmt.Printf(<span class="hljs-string">&quot;b.addr: %p\n&quot;</span>, &amp;b)<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-comment">// 0xc000094288</span><br><span class="hljs-comment">// 0xc000094288</span><br><span class="hljs-comment">// b.addr: 0xc000094288</span><br></code></pre></td></tr></table></figure><h3 id="2-4-指针传递（-Type）"><a href="#2-4-指针传递（-Type）" class="headerlink" title="2.4 指针传递（* Type）"></a>2.4 指针传递（* Type）</h3><blockquote><p>指针传递 - 一般指使用指针传参</p></blockquote><p>指针传参的好处与规范：</p><p>引自：<a href="https://golang.google.cn/doc/faq#methods_on_values_or_pointers">https://golang.google.cn/doc/faq#methods_on_values_or_pointers</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyStruct)</span></span> pointerMethod() &#123; &#125; <span class="hljs-comment">// method on pointer</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s MyStruct)</span></span>  valueMethod()   &#123; &#125; <span class="hljs-comment">// method on value</span><br></code></pre></td></tr></table></figure><blockquote><p>将接收器定义为一个值还是一个指针，与函数参数应该是一个值还是一个指针的问题是一样的。这里有几个考虑因素。</p><p>首先，也是最重要的，方法是否需要修改接收器？如果需要，那么接收器必须是一个指针。(slice和map作为引用传递，所以它们的故事更微妙一些，但例如在一个方法中改变一个slice的长度，接收器仍然必须是一个指针。) 在上面的例子中，如果pointerMethod修改了s的字段，那么调用者会看到这些变化，但是valueMethod是用调用者参数的副本来调用的（这就是传递值的定义），所以它所做的变化对调用者来说是不可见的。</p><p>顺便说一下，在Java中，方法接收者总是指针，尽管它们的指针性质在某种程度上被掩盖了（有一个建议是在语言中增加值接收者）。Go中的值接收器才是不寻常的。</p><p>其次是对效率的考虑。如果接收器很大，例如一个大的结构体，那么使用指针接收器就会便宜很多。</p><p>其次是一致性。如果该类型的一些方法必须有指针接收器，那么其他的也应该有，所以无论该类型如何使用，方法集都是一致的。详见关于方法集的章节。</p><p>对于基本类型、切片和小结构等类型，值接收器是非常便宜的，所以除非方法的语义需要指针，否则值接收器是高效且清晰的。</p></blockquote><p>结构体传递，也是最常见的参数，必须使用指针来避免不必要的值拷贝，提高效率。对应开篇里的例子，指针就像一本书的索引目录，在一般情况下（上文情况），告诉别人看这本书的目录索引来查找对应章节内容，总比直接告诉别人对应章节的所有内容要快。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> XXXXXX <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-number">10</span>+个字段<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(x *XXXXXX)</span></span> &#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-解引用（-）"><a href="#2-5-解引用（-）" class="headerlink" title="2.5 解引用（*）"></a>2.5 解引用（*）</h3><blockquote><p>解引用 - dereference </p></blockquote><p>引自：<a href="https://www.golang-book.com/books/intro/8#section1">https://www.golang-book.com/books/intro/8#section1</a> </p><blockquote><p>‘*’ 也被用来 “解除引用 “指针变量。</p><p>解除对一个指针的引用使我们能够访问指针所指向的值。</p><p>当我们写<strong>*xPtr &#x3D; 0</strong>时，是指在<strong>xPtr</strong>所指的内存位置存储0（整型0）。</p><p>如果我们尝试<strong>xPtr &#x3D; 0</strong>，我们会得到一个编译器错误，因为<strong>xPtr</strong>不是一个<strong>int</strong>，而是一个 <strong>*int</strong> (int的指针类型)，它只能被赋予另一个<strong>*int</strong>。</p></blockquote><p>我们经常会用到解引用，其主要作用是改变指针变量指向的值的内容，简单的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestDereference</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<br>a := <span class="hljs-number">1</span><br>fmt.Println(a)  <span class="hljs-comment">// 1</span><br>iPtr := &amp;a<br>*iPtr = <span class="hljs-number">2</span>  <span class="hljs-comment">// &lt;-- 这里就是利用dereference修改a的值</span><br>fmt.Println(a)  <span class="hljs-comment">// 2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在Go的Reflect包反射赋值方法中，也多处使用<strong>解引用</strong>，下面摘出其一：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// SetBool sets v&#x27;s underlying value.</span><br><span class="hljs-comment">// It panics if v&#x27;s Kind is not Bool or if CanSet() is false.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span></span> SetBool(x <span class="hljs-type">bool</span>) &#123;<br>v.mustBeAssignable()<br>v.mustBe(Bool)<br>*(*<span class="hljs-type">bool</span>)(v.ptr) = x<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-6-new-amp-make"><a href="#2-6-new-amp-make" class="headerlink" title="2.6 new &amp; make"></a>2.6 new &amp; make</h3><blockquote><p>In short: <code>new</code> allocates memory, while <code>make</code> initializes the slice, map, and channel types.</p></blockquote><p>上面这句话表达得比较粗暴。</p><p>实际上new用于基础数据类型申请内存，并返回一个指针对象；</p><p>而make用于初始化slice、map、channel类型，返回的是一个对象实例（值），不是指针。</p><p>至于go为什么要这样设计？这个答案比较长，有兴趣了解请看：</p><p><a href="https://golang.google.cn/doc/effective_go#data">https://golang.google.cn/doc/effective_go#data</a></p><p><a href="https://golang.org/doc/effective_go#allocation_make">https://golang.org/doc/effective_go#allocation_make</a></p><p>借文中这段搞怪的代码来体验new和make：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p *[]<span class="hljs-type">int</span> = <span class="hljs-built_in">new</span>([]<span class="hljs-type">int</span>)<br>*p = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><h3 id="2-7-二级指针（-）"><a href="#2-7-二级指针（-）" class="headerlink" title="2.7 二级指针（**）"></a>2.7 二级指针（**）</h3><blockquote><p>二级指针 - 指向一级指针的指针变量</p></blockquote><p>指针不仅仅只有二级，而是多维；二级指针在go中已经是比较 “罕见” 了，但我们仍然需要学习它来解决和辨别一些问题。</p><p>引自：<a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection">https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection</a></p><blockquote><p>在一些语言中，一个指针可以引用另一个指针，这就需要进行多次转指操作来获取原始值。虽然每一级转指可能会增加性能成本，但为了给复杂的[数据结构]提供正确的行为，这有时是必要的。</p></blockquote><p>所以二级指针的本质也是一个指针变量，<strong>二级指针</strong>这个名字其实是对于 第一级指针 而言的，在C&#x2F;C++语言中经常出现；</p><p>例如在著名开源项目redis中</p><p>用于改变一级指针的指向（<strong>指针偏移</strong>）：</p><p>引自：<a href="https://github.com/redis/redis/blob/unstable/src/ziplist.c">https://github.com/redis/redis/blob/unstable/src/ziplist.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Delete a single entry from the ziplist, pointed to by *p.</span><br><span class="hljs-comment"> * Also update *p in place, to be able to iterate over the</span><br><span class="hljs-comment"> * ziplist, while deleting entries. */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">ziplistDelete</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl, <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> **p)</span> &#123;<br>    <span class="hljs-type">size_t</span> offset = *p-zl;<br>    zl = __ziplistDelete(zl,*p,<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">/* Store pointer to current element in p, because ziplistDelete will</span><br><span class="hljs-comment">     * do a realloc which might result in a different &quot;zl&quot;-pointer.</span><br><span class="hljs-comment">     * When the delete direction is back to front, we might delete the last</span><br><span class="hljs-comment">     * entry and end up with &quot;p&quot; pointing to ZIP_END, so check this. */</span><br>    *p = zl+offset;<br>    <span class="hljs-keyword">return</span> zl;<br>&#125;<br></code></pre></td></tr></table></figure><p>用于<strong>给一级指针分配堆内存空间</strong>：</p><p>引自：<a href="https://github.com/redis/redis/blob/unstable/src/server.c">https://github.com/redis/redis/blob/unstable/src/server.c</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Create the string returned by the INFO command. This is decoupled</span><br><span class="hljs-comment"> * by the INFO command itself as we need to report the same information</span><br><span class="hljs-comment"> * on memory corruption problems. */</span><br>sds <span class="hljs-title function_">genRedisInfoString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *section)</span> &#123;<br>    ......<br>        <span class="hljs-keyword">while</span>((de = dictNext(di)) != <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-type">char</span> *tmpsafe;  <span class="hljs-comment">// &lt;--声明tmpsafe的地方，并没有分配内存</span><br>            c = (<span class="hljs-keyword">struct</span> redisCommand *) dictGetVal(de);<br>            <span class="hljs-keyword">if</span> (!c-&gt;calls &amp;&amp; !c-&gt;failed_calls &amp;&amp; !c-&gt;rejected_calls)<br>                <span class="hljs-keyword">continue</span>;<br>            info = sdscatprintf(info,<br>                <span class="hljs-string">&quot;cmdstat_%s:calls=%lld,usec=%lld,usec_per_call=%.2f&quot;</span><br>                <span class="hljs-string">&quot;,rejected_calls=%lld,failed_calls=%lld\r\n&quot;</span>,<br>                                <br>                <span class="hljs-comment">// 注意下面这个tmpsafe，取地址传入</span><br>                getSafeInfoString(c-&gt;name, <span class="hljs-built_in">strlen</span>(c-&gt;name), &amp;tmpsafe), c-&gt;calls, c-&gt;microseconds,<br>                <br>                (c-&gt;calls == <span class="hljs-number">0</span>) ? <span class="hljs-number">0</span> : ((<span class="hljs-type">float</span>)c-&gt;microseconds/c-&gt;calls),<br>                c-&gt;rejected_calls, c-&gt;failed_calls);<br>            <br>            <span class="hljs-comment">// sdscatprintf方法中可能没有释放这个tmpsafe的内存，在这里释放（sdscatprintf外部），防止内存泄露</span><br>            <span class="hljs-keyword">if</span> (tmpsafe != <span class="hljs-literal">NULL</span>) zfree(tmpsafe);<br>        &#125;<br>    ......<br>&#125;<br><br><span class="hljs-comment">/* Returns a sanitized version of s that contains no unsafe info string chars.</span><br><span class="hljs-comment"> * If no unsafe characters are found, simply returns s. Caller needs to</span><br><span class="hljs-comment"> * free tmp if it is non-null on return.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title function_">getSafeInfoString</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">size_t</span> len, <span class="hljs-type">char</span> **tmp)</span> &#123;<br>    *tmp = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (mempbrk(s, len, unsafe_info_chars,<span class="hljs-keyword">sizeof</span>(unsafe_info_chars)<span class="hljs-number">-1</span>)<br>        == <span class="hljs-literal">NULL</span>) <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-type">char</span> *new = *tmp = zmalloc(len + <span class="hljs-number">1</span>);  <span class="hljs-comment">// &lt;--这里给tmpsafe分配了内存</span><br>    <span class="hljs-built_in">memcpy</span>(new, s, len);<br>    new[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-keyword">return</span> memmapchars(new, len, unsafe_info_chars, unsafe_info_chars_substs,<br>                       <span class="hljs-keyword">sizeof</span>(unsafe_info_chars)<span class="hljs-number">-1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们回到go，在go中也有对应的用法，但我们可能还不太理解 二级指针 的重要性，这里举一个示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AA <span class="hljs-keyword">struct</span> &#123;<br>B <span class="hljs-type">string</span><br>C <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AA)</span></span> SetB(b <span class="hljs-type">string</span>) &#123;<br><span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>a = <span class="hljs-built_in">new</span>(AA)<br>&#125;<br>a.B = b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrNew</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> a *AA<br><span class="hljs-comment">//a.B = &quot;bb&quot; 这里必然panic，上面学了new的支持已经明白</span><br>a.SetB(<span class="hljs-string">&quot;bb&quot;</span>)<br>fmt.Println(a.B)<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: invalid memory address or <span class="hljs-literal">nil</span> pointer dereference [recovered]<br></code></pre></td></tr></table></figure><p>这个例子在 *<em>func (a <em>AA) SetB(b string)</em></em> 中已经给 <strong>指针对象 a</strong> 申请了内存，为什么仍然报空指针错误呢？</p><p>大家能说出引发panic的是哪一行代码吗？</p><p>我们来打印 <strong>对象a</strong> 在new前后的自身地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> AA <span class="hljs-keyword">struct</span> &#123;<br>B <span class="hljs-type">string</span><br>C <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AA)</span></span> SetB(b <span class="hljs-type">string</span>) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Before New: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br><span class="hljs-keyword">if</span> a == <span class="hljs-literal">nil</span> &#123;<br>a = <span class="hljs-built_in">new</span>(AA)<br>&#125;<br>a.B = b<br>fmt.Printf(<span class="hljs-string">&quot;After New: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrNew</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> a *AA<br>fmt.Printf(<span class="hljs-string">&quot;Before SetB: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br><span class="hljs-comment">//a.B = &quot;bb&quot;</span><br>a.SetB(<span class="hljs-string">&quot;bb&quot;</span>)<br>    fmt.Printf(<span class="hljs-string">&quot;After SetB: value: %+v, addr: %p\n&quot;</span>, a, &amp;a)<br>fmt.Println(a.B)<br>&#125;<br><br><span class="hljs-comment">// 运行结果：</span><br><span class="hljs-comment">// === RUN   TestPtrNew</span><br><span class="hljs-comment">// Before SetB: value: &lt;nil&gt;, addr: 0xc000006038</span><br><span class="hljs-comment">// Before New: value: &lt;nil&gt;, addr: 0xc000006040</span><br><span class="hljs-comment">// After New: value: &amp;&#123;B:bb C:&#125;, addr: 0xc000006040</span><br><span class="hljs-comment">// After SetB: value: &lt;nil&gt;, addr: 0xc000006038</span><br><span class="hljs-comment">// --- FAIL: TestPtrNew (0.00s)</span><br><span class="hljs-comment">// panic: runtime error: invalid memory address or nil pointer dereference [recovered]</span><br></code></pre></td></tr></table></figure><p>这里可以看到，*<em>var a <em>AA</em></em> 的a变量 和 *<em>func (a <em>AA) SetB(b string)</em></em> 的a变量 ，</p><p>本质上不是同一个东西（不是同一个变量，即不是同一块内存地址），</p><p>只是他们都指向名为 <strong>AA</strong> 的结构体对象的指针罢了。</p><p>在 *<em>func (a <em>AA) SetB(b string)</em></em> 中给 a变量 申请内存，对 <strong>TestPtrNew()</strong> 中的a变量没有产生影响；</p><p>因为 <strong>a.SetB(“bb”)</strong> 这个动作中，a变量是指针传递，传递了<strong>nil</strong>，</p><p>而没有把 *<em>var a <em>AA</em></em> 的本身内存地址，传递到 *<em>func (a <em>AA) SetB(b string)</em></em> 中。</p><p>那我如果就是要在方法内给 <strong>a</strong>指针对象 申请内存，如何实现？</p><p><strong>方案一：</strong>将上文在 *<em>func (a <em>AA) SetB(b string)</em></em> 申请的 <strong>a</strong> 对象 return 出去，很常见的做法；</p><p><strong>方案二：</strong>传递二级指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*AA)</span></span> SetB_P2(b <span class="hljs-type">string</span>, a **AA)  &#123;<br><span class="hljs-keyword">if</span> *a == <span class="hljs-literal">nil</span> &#123;<br>*a = <span class="hljs-built_in">new</span>(AA)<br>&#125;<br>(*a).B = b<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrNew_P2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> a *AA<br>a.SetB_P2(<span class="hljs-string">&quot;bb&quot;</span>, &amp;a)<br>fmt.Println(a.B)<br>&#125;<br><br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-comment">// === RUN   TestPtrNew_P2</span><br><span class="hljs-comment">// bb</span><br><span class="hljs-comment">// --- PASS: TestPtrNew_P2 (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><h2 id="3-Go变量存储的内存位置"><a href="#3-Go变量存储的内存位置" class="headerlink" title="3. Go变量存储的内存位置"></a>3. Go变量存储的内存位置</h2><p>Go是否像C&#x2F;C++一样，是在堆内存上申请？</p><p>我们来看官方说法：<a href="https://golang.org/doc/effective_go#allocation_make">https://golang.org/doc/effective_go#allocation_make</a></p><blockquote><p>从正确性的角度来看，你不需要知道。</p><p>在Go中，每个变量的生命周期取决于它是否被引用。</p><p>实现所选择的存储位置与语言的语义无关。</p><p>存储位置确实对编写高效程序有影响。</p><p>在可能的情况下，Go编译器会在一个函数的堆栈框架中分配属于该函数的局部变量。</p><p>然而，如果编译器不能证明该变量在函数返回后没有被引用，那么编译器必须在GC的堆上分配该变量，以避免[悬空指针]错误。</p><p>另外，如果一个局部变量非常大，它会被存储在堆上。</p><p>在目前的编译器中，如果一个变量的地址被占用，那么这个变量就是在堆上分配的候选变量。</p><p>然而，编译期间的<strong>逃逸分析</strong>会识别哪些变量可以存放在栈空间上。</p></blockquote><p><strong>在上面的一大段文字可以总结出几个关键信息：</strong></p><ol><li><strong>Go的变量在内存中存储的位置与语法无关；</strong></li><li><strong>Go的变量生命周期与该变量本身被引用的范围有关；</strong></li><li><strong>Go的变量内存在GC的堆栈上分配；</strong></li><li><strong>Go的变量太大会强制在堆上分配；</strong></li><li><strong>Go编译期的逃逸分析对变量存储位置有决定性作用；</strong></li></ol><h3 id="3-1-堆-or-栈？"><a href="#3-1-堆-or-栈？" class="headerlink" title="3.1 堆 or 栈？"></a>3.1 堆 or 栈？</h3><p>我们来实际验证一下，上代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-number">1</span> <span class="hljs-keyword">package</span> main<br> <span class="hljs-number">2</span> <br> <span class="hljs-number">3</span> <span class="hljs-keyword">import</span> (<br> <span class="hljs-number">4</span>     <span class="hljs-string">&quot;time&quot;</span><br> <span class="hljs-number">5</span> )<br> <span class="hljs-number">6</span> <br> <span class="hljs-number">7</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testHeap</span><span class="hljs-params">()</span></span> (*<span class="hljs-type">int</span>, *<span class="hljs-type">int</span>) &#123;<br> <span class="hljs-number">8</span>     <span class="hljs-keyword">var</span> x <span class="hljs-type">int</span> = <span class="hljs-number">1</span><br> <span class="hljs-number">9</span>     <span class="hljs-keyword">var</span> y <span class="hljs-type">int</span> = <span class="hljs-number">2</span><br><span class="hljs-number">10</span> <br><span class="hljs-number">11</span>     z := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br><span class="hljs-number">12</span> <br><span class="hljs-number">13</span>     <span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br><span class="hljs-number">14</span>     <span class="hljs-keyword">var</span> j = <span class="hljs-number">2</span><br><span class="hljs-number">15</span> <br><span class="hljs-number">16</span>     <span class="hljs-built_in">println</span>(&amp;x, &amp;y, z, &amp;i, &amp;j)<br><span class="hljs-number">17</span> <br><span class="hljs-number">18</span>     <span class="hljs-keyword">return</span> &amp;x, &amp;y<br><span class="hljs-number">19</span> &#125;<br><span class="hljs-number">20</span> <br><span class="hljs-number">21</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-number">22</span>     <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-number">23</span>     <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br><span class="hljs-number">24</span> <br><span class="hljs-number">25</span>     x, y := testHeap()<br><span class="hljs-number">26</span>     s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>)<br><span class="hljs-number">27</span> <br><span class="hljs-number">28</span>     <span class="hljs-built_in">println</span>(&amp;a, &amp;b, x, y, &amp;(s[<span class="hljs-number">0</span>]))<br><span class="hljs-number">29</span> <br><span class="hljs-number">30</span>     <span class="hljs-keyword">for</span> &#123;<br><span class="hljs-number">31</span>         time.Sleep(time.Second)<br><span class="hljs-number">32</span>     &#125;<br><span class="hljs-number">33</span> &#125;<br><br></code></pre></td></tr></table></figure><p>使用 <strong>go run -gcflags ‘-m -l’ memory.go</strong> 命令观察”逃逸”（-m：逃逸分析  -l：禁止内联）</p><p>输出结果如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"># command-line-arguments<br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">8</span>:<span class="hljs-number">9</span>: moved to heap: x    <span class="hljs-comment">// &lt;- x,y因为要返回给func外部使用，因此在heap上存储</span><br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">9</span>:<span class="hljs-number">9</span>: moved to heap: y<br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">11</span>:<span class="hljs-number">13</span>: <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) does not escape  <span class="hljs-comment">// &lt;- z虽然是指针并且new()，但没有逃逸出func，因此在stack上存储</span><br>./memory.<span class="hljs-keyword">go</span>:<span class="hljs-number">26</span>:<span class="hljs-number">14</span>: <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10000</span>, <span class="hljs-number">10000</span>) escapes to heap  <span class="hljs-comment">// &lt;- s这个变量很大，逃逸到heap上存储</span><br><span class="hljs-number">0xc0000140a0</span> <span class="hljs-number">0xc0000140a8</span> <span class="hljs-number">0xc000066ea0</span> <span class="hljs-number">0xc000066e98</span> <span class="hljs-number">0xc000066e90</span><br><span class="hljs-number">0xc000066f20</span> <span class="hljs-number">0xc000066f18</span> <span class="hljs-number">0xc0000140a0</span> <span class="hljs-number">0xc0000140a8</span> [<span class="hljs-number">0</span>/<span class="hljs-number">10000</span>]<span class="hljs-number">0xc000080000</span><br></code></pre></td></tr></table></figure><p>我们再来整理出各个变量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>内:<br>x: <span class="hljs-number">0xc0000140a0</span><br>y: <span class="hljs-number">0xc0000140a8</span>  <span class="hljs-comment">// &lt;--相比x的地址高了8个byte</span><br>z: <span class="hljs-number">0xc000066ea0</span><br>i: <span class="hljs-number">0xc000066e98</span>  <span class="hljs-comment">// &lt;--相比z的地址低了8个byte</span><br>j: <span class="hljs-number">0xc000066e90</span>  <span class="hljs-comment">// &lt;--相比j的地址低了8个byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>外:<br>a: <span class="hljs-number">0xc000066f20</span><br>b: <span class="hljs-number">0xc000066f18</span>  <span class="hljs-comment">// &lt;--相比a的地址低了8个byte</span><br>x: <span class="hljs-number">0xc0000140a0</span><br>y: <span class="hljs-number">0xc0000140a8</span>  <span class="hljs-comment">// &lt;--相比x的地址高了8个byte</span><br>s: <span class="hljs-number">0xc000080000</span><br></code></pre></td></tr></table></figure><p>可以看出：其中x，y，s符合堆内存空间增长方向（递增）；a、b、z、i、j符合栈内存空间增长方向（递减）。</p><p>这部分数据证明了上述的1、2、5点。</p><h3 id="3-2-内存预申请"><a href="#3-2-内存预申请" class="headerlink" title="3.2 内存预申请"></a>3.2 内存预申请</h3><p>那在GO中，栈空间地址是否一定大于堆空间地址？试验几次之后，发现并不是~</p><p>我们看下这个进程的内存分布情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go">[root@czy memory]# ps -ef | grep <span class="hljs-keyword">go</span><br>czy       <span class="hljs-number">17772</span>      <span class="hljs-number">1</span>  <span class="hljs-number">0</span> Aug26 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/libexec/goa-daemon<br>czy       <span class="hljs-number">17810</span>      <span class="hljs-number">1</span>  <span class="hljs-number">0</span> Aug26 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/libexec/gvfs-goa-volume-monitor<br>czy       <span class="hljs-number">17839</span>      <span class="hljs-number">1</span>  <span class="hljs-number">0</span> Aug26 ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /usr/libexec/goa-identity-service<br>root      <span class="hljs-number">26104</span>  <span class="hljs-number">20319</span>  <span class="hljs-number">0</span> Aug26 pts/<span class="hljs-number">1</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-keyword">go</span> run -gcflags -m -N -l memory.<span class="hljs-keyword">go</span><br>root      <span class="hljs-number">26139</span>  <span class="hljs-number">26104</span>  <span class="hljs-number">0</span> Aug26 pts/<span class="hljs-number">1</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory <span class="hljs-comment">// &lt;-- 注意这个才是</span><br>root      <span class="hljs-number">26280</span>  <span class="hljs-number">22527</span>  <span class="hljs-number">0</span> <span class="hljs-number">00</span>:<span class="hljs-number">03</span> pts/<span class="hljs-number">2</span>    <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> grep --color=auto <span class="hljs-keyword">go</span><br>[root@czy memory]# cd /proc/<span class="hljs-number">26139</span><br>[root@czy <span class="hljs-number">26139</span>]# cat maps<br><span class="hljs-number">00400000</span><span class="hljs-number">-00458000</span> r-xp <span class="hljs-number">00000000</span> fd:<span class="hljs-number">00</span> <span class="hljs-number">57563390</span>                           /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory<br><span class="hljs-number">00458000</span><span class="hljs-number">-004</span>bf000 r--p <span class="hljs-number">00058000</span> fd:<span class="hljs-number">00</span> <span class="hljs-number">57563390</span>                           /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory<br><span class="hljs-number">004</span>bf000<span class="hljs-number">-004</span>c4000 rw-p <span class="hljs-number">000</span>bf000 fd:<span class="hljs-number">00</span> <span class="hljs-number">57563390</span>                           /tmp/<span class="hljs-keyword">go</span>-build1166535314/b001/exe/memory<br><span class="hljs-number">004</span>c4000<span class="hljs-number">-004</span>f7000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br>c000000000-c000400000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>    <span class="hljs-comment">// &lt;-- 重点看这段可读可写的内存，上面输出的变量地址均落在这个区间。</span><br>c000400000-c004000000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f2d974000<span class="hljs-number">-7</span>f4f2fce5000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f2fce5000<span class="hljs-number">-7</span>f4f3fe65000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f3fe65000<span class="hljs-number">-7</span>f4f3fe66000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f3fe66000<span class="hljs-number">-7</span>f4f51d15000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f51d15000<span class="hljs-number">-7</span>f4f51d16000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f51d16000<span class="hljs-number">-7</span>f4f540eb000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f540eb000<span class="hljs-number">-7</span>f4f540ec000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f540ec000<span class="hljs-number">-7</span>f4f54565000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f54565000<span class="hljs-number">-7</span>f4f54566000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f54566000<span class="hljs-number">-7</span>f4f545e5000 ---p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>f4f545e5000<span class="hljs-number">-7</span>f4f54645000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span> <br><span class="hljs-number">7</span>ffe8c4cb000<span class="hljs-number">-7</span>ffe8c4ec000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                          [stack]<br><span class="hljs-number">7</span>ffe8c56f000<span class="hljs-number">-7</span>ffe8c571000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>                  [vsyscall]<br></code></pre></td></tr></table></figure><p>为啥不能像C&#x2F;C++进程一样可以准确显示出 <strong>[heap]</strong> 和 <strong>[stack]</strong> 的内存分布呢？</p><p>来回顾到第3点，内存在GC上分配。</p><p>难道GO的内存是由GC统一申请一块大内存块，再按需进行分配给个个变量的？类似于内存池？</p><p>我们来看go1.17源码：src&#x2F;runtime&#x2F;malloc.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Allocate an object of size bytes.</span><br><span class="hljs-comment">// Small objects are allocated from the per-P cache&#x27;s free lists.</span><br><span class="hljs-comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mallocgc</span><span class="hljs-params">(size <span class="hljs-type">uintptr</span>, typ *_type, needzero <span class="hljs-type">bool</span>)</span></span> unsafe.Pointer &#123;<br><span class="hljs-keyword">if</span> gcphase == _GCmarktermination &#123;<br>throw(<span class="hljs-string">&quot;mallocgc called with gcphase == _GCmarktermination&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> size == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zerobase)<br>&#125;<br><br><span class="hljs-comment">// Set mp.mallocing to keep from being preempted by GC.</span><br>......<br>    <br><span class="hljs-keyword">if</span> size &lt;= maxSmallSize &#123;<br>......<br>        <br>&#125; <span class="hljs-keyword">else</span> &#123;<br>shouldhelpgc = <span class="hljs-literal">true</span><br>span = c.allocLarge(size, needzero, noscan)  <span class="hljs-comment">// &lt;--- 根据描述，大size必然在heap申请，我们关注这个方法</span><br>span.freeindex = <span class="hljs-number">1</span><br>span.allocCount = <span class="hljs-number">1</span><br>x = unsafe.Pointer(span.base())<br>size = span.elemsize<br>&#125;<br><br>    ......<br>    <br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-comment">// allocLarge allocates a span for a large object.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *mcache)</span></span> allocLarge(size <span class="hljs-type">uintptr</span>, needzero <span class="hljs-type">bool</span>, noscan <span class="hljs-type">bool</span>) *mspan &#123;<br>......<br><br>spc := makeSpanClass(<span class="hljs-number">0</span>, noscan)<br>s := mheap_.alloc(npages, spc, needzero)  <span class="hljs-comment">// &lt;--- 注意这个方法</span><br><span class="hljs-keyword">if</span> s == <span class="hljs-literal">nil</span> &#123;<br>throw(<span class="hljs-string">&quot;out of memory&quot;</span>)<br>&#125;<br>    <br>......<br>&#125;<br><br><span class="hljs-keyword">var</span> mheap_ mheap  &lt;--- !!!!原来<span class="hljs-keyword">go</span>一开始就定义一块全局<span class="hljs-keyword">struct</span>来管理heap<br><br><span class="hljs-comment">// Main malloc heap.</span><br><span class="hljs-comment">// The heap itself is the &quot;free&quot; and &quot;scav&quot; treaps,</span><br><span class="hljs-comment">// but all the other global data is here too.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// mheap must not be heap-allocated because it contains mSpanLists,</span><br><span class="hljs-comment">// which must not be heap-allocated.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//go:notinheap</span><br><span class="hljs-keyword">type</span> mheap <span class="hljs-keyword">struct</span> &#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里，已经猜测到十有八九，但没有再继续精细研究 <code>mheap_</code> 如何在各种情况下调度，姑且证明第4点。而第3点，在 <code>func mallocgc()</code> 的注释有说明：<strong>Large objects (&gt; 32 kB) are allocated straight from the heap.</strong></p><h2 id="4-unsafe-Pointer："><a href="#4-unsafe-Pointer：" class="headerlink" title="4. unsafe.Pointer："></a>4. unsafe.Pointer：</h2><h3 id="4-1-unsafe-Pointer的内部结构"><a href="#4-1-unsafe-Pointer的内部结构" class="headerlink" title="4.1 unsafe.Pointer的内部结构"></a>4.1 unsafe.Pointer的内部结构</h3><p>go1.16源码：unsafe&#x2F;unsafe.go，</p><p>unsafe.Pointer，请容我称之为真正的指针！我们来看看它的内部结构：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Pointer *ArbitraryType<br><br><span class="hljs-comment">// ArbitraryType 仅用于文档目的，实际上并不是 unsafe 包的一部分。它代表任意 Go 表达式的类型。</span><br><span class="hljs-keyword">type</span> ArbitraryType <span class="hljs-type">int</span><br></code></pre></td></tr></table></figure><p>所以，unsafe.Pointer的类型，就是一个<strong>int指针</strong>，随操作系统位数，指向4或8个字节的内存地址。</p><p>unsafe&#x2F;unsafe.go 这个文件中还有非常多关于 unsafe.Pointer 的使用说明，有空可以仔细阅读，有助于理解底层代码实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Pointer表示指向任意类型的指针。有四种特殊操作:</span><br><span class="hljs-comment">// Pointer有着其他指针类型不具备的能力：</span><br><span class="hljs-comment">// - 任何类型的指针值都可以转换为Pointer。</span><br><span class="hljs-comment">// - Pointer可以转换为任何类型的指针值。</span><br><span class="hljs-comment">// - uintptr可以转换为Pointer。</span><br><span class="hljs-comment">// - 可以将Pointer转换为uintptr。</span><br><span class="hljs-comment">// 因此Pointer允许程序突破golang类型系统的限制并读写任意内存。应该非常小心地使用它。</span><br></code></pre></td></tr></table></figure><h3 id="4-2-从string简析unsafe-Pointer"><a href="#4-2-从string简析unsafe-Pointer" class="headerlink" title="4.2 从string简析unsafe.Pointer"></a>4.2 从string简析unsafe.Pointer</h3><h4 id="4-1-1-string的内部结构"><a href="#4-1-1-string的内部结构" class="headerlink" title="4.1.1 string的内部结构"></a>4.1.1 string的内部结构</h4><p>我们就用string的底层结构来稍微了解下unsafe.Pointer的意义。</p><p>首先是位于 src&#x2F;builtin&#x2F;builtin.go 作者对 string 的描述：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// string is the set of all strings of 8-bit bytes, conventionally but not</span><br><span class="hljs-comment">// necessarily representing UTF-8-encoded text. A string may be empty, but</span><br><span class="hljs-comment">// not nil. Values of string type are immutable.</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">string</span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>包含几个信息：</p><blockquote><p>string是所有8位的字节的字符串的集合，通常但不一定代表UTF-8编码的文本。<br>string对象可以是空的，但不会nil。<br>string类型的值是不可变的。（这句话有点迷惑性~。[不可变]的意思是，可以被替换的。甚至在一些情况下，是可以被修改的，哪些情况，看下文）</p></blockquote><p>为什么是**[不可变]**？源码注释这样写，总有他的道理。</p><p>我们来看 string 的底层结构，可以看出由一个指针和一个int组成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer  <span class="hljs-comment">// 指向内存地址起点的指针</span><br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>             <span class="hljs-comment">// 内容的长度(占内存的字节数)</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你看这个string的结构开头小写，而且成员变量都是小写开头，按Go的语法，是<strong>私有</strong>的，当然不可修改啦~（不可变）。所以，[不可变]是对于<strong>常规手段</strong>而言的。</p><h4 id="4-1-2-string的拼接过程"><a href="#4-1-2-string的拼接过程" class="headerlink" title="4.1.2 string的拼接过程"></a>4.1.2 string的拼接过程</h4><p>探索一下string是如何构造的，我们来写一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1</span> <span class="hljs-keyword">package</span> main<br><span class="hljs-number">2</span> <br><span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-number">4</span>     a := <span class="hljs-string">&quot;1111111111&quot;</span><br><span class="hljs-number">5</span>     b := a + <span class="hljs-string">&quot;2222&quot;</span><br><span class="hljs-number">6</span>     <span class="hljs-built_in">print</span>(a, b)<br><span class="hljs-number">7</span> &#125;<br></code></pre></td></tr></table></figure><p>使用 go tool 工具分析编译过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool compile -S concat.go<br></code></pre></td></tr></table></figure><p>会产出非常多的信息，我们重点关注以下几段：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell">0x0000 00000 (concat.go:3)TEXT&quot;&quot;.main(SB), ABIInternal, $96-0<br>0x0000 00000 (concat.go:3)CMPQSP, 16(R14)<br>0x0004 00004 (concat.go:3)PCDATA$0, $-2<br>0x0004 00004 (concat.go:3)JLS116<br>0x0006 00006 (concat.go:3)PCDATA$0, $-1<br>0x0006 00006 (concat.go:3)SUBQ$96, SP<br>0x000a 00010 (concat.go:3)MOVQBP, 88(SP)<br>0x000f 00015 (concat.go:3)LEAQ88(SP), BP<br>0x0014 00020 (concat.go:3)FUNCDATA$0, gclocals·69c1753bd5f81501d95132d08af04464(SB)<br>0x0014 00020 (concat.go:3)FUNCDATA$1, gclocals·9fb7f0986f647f17cb53dda1484e0f7a(SB)<br>0x0014 00020 (concat.go:5)LEAQ&quot;&quot;..autotmp_2+48(SP), AX<br>0x0019 00025 (concat.go:5)LEAQgo.string.&quot;1111111111&quot;(SB), BX  // &lt;-- 这个暂时不分析，后面讲<br>0x0020 00032 (concat.go:5)MOVL$10, CX<br>0x0025 00037 (concat.go:5)LEAQgo.string.&quot;2222&quot;(SB), DI  // &lt;-- 这个暂时不分析，后面讲<br>0x002c 00044 (concat.go:5)MOVL$4, SI<br>0x0031 00049 (concat.go:5)PCDATA$1, $0<br>0x0031 00049 (concat.go:5)CALLruntime.concatstring2(SB)  // &lt;-- 重点关注这个<br></code></pre></td></tr></table></figure><p> 我们来到这个文件：src&#x2F;runtime&#x2F;string.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstring2</span><span class="hljs-params">(buf *tmpBuf, a [2]<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> concatstrings(buf, a[:])<br>&#125;<br><br><span class="hljs-comment">// concatstrings implements a Go string concatenation x+y+z+...</span><br><span class="hljs-comment">// The operands are passed in the slice a.</span><br><span class="hljs-comment">// If buf != nil, the compiler has determined that the result does not</span><br><span class="hljs-comment">// escape the calling function, so the string data can be stored in buf</span><br><span class="hljs-comment">// if small enough.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">concatstrings</span><span class="hljs-params">(buf *tmpBuf, a []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>idx := <span class="hljs-number">0</span><br>l := <span class="hljs-number">0</span><br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i, x := <span class="hljs-keyword">range</span> a &#123;<br>n := <span class="hljs-built_in">len</span>(x)<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">if</span> l+n &lt; l &#123;<br>throw(<span class="hljs-string">&quot;string concatenation too long&quot;</span>)<br>&#125;<br>l += n     <span class="hljs-comment">// &lt;---累加总长度</span><br>count++<br>idx = i<br>&#125;<br><span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br><span class="hljs-comment">// If there is just one string and either it is not on the stack</span><br><span class="hljs-comment">// or our result does not escape the calling frame (buf != nil),</span><br><span class="hljs-comment">// then we can return that string directly.</span><br><span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> &amp;&amp; (buf != <span class="hljs-literal">nil</span> || !stringDataOnStack(a[idx])) &#123;<br><span class="hljs-keyword">return</span> a[idx]<br>&#125;<br>s, b := rawstringtmp(buf, l)  <span class="hljs-comment">// &lt;--一次性申请一块完整内存</span><br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> a &#123;         <span class="hljs-comment">// &lt;--遍历原始字符串再逐个拷贝到空的已分配内存的slice中</span><br><span class="hljs-built_in">copy</span>(b, x)<br>b = b[<span class="hljs-built_in">len</span>(x):]            <span class="hljs-comment">// &lt;--切片指向往后偏移，方便下一次赋值。</span><br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rawstringtmp</span><span class="hljs-params">(buf *tmpBuf, l <span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">string</span>, b []<span class="hljs-type">byte</span>) &#123;<br><span class="hljs-keyword">if</span> buf != <span class="hljs-literal">nil</span> &amp;&amp; l &lt;= <span class="hljs-built_in">len</span>(buf) &#123;<br>b = buf[:l]<br>s = slicebytetostringtmp(&amp;b[<span class="hljs-number">0</span>], <span class="hljs-built_in">len</span>(b))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s, b = rawstring(l)  <span class="hljs-comment">// &lt;-- 抛开这个判断，我们重点看buf==nil的情况</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">stringStructOf</span><span class="hljs-params">(sp *<span class="hljs-type">string</span>)</span></span> *stringStruct &#123;<br><span class="hljs-keyword">return</span> (*stringStruct)(unsafe.Pointer(sp))<br>&#125;<br><br><span class="hljs-comment">// rawstring allocates storage for a new string. The returned</span><br><span class="hljs-comment">// string and byte slice both refer to the same storage.</span><br><span class="hljs-comment">// The storage is not zeroed. Callers should use</span><br><span class="hljs-comment">// b to set the string contents and then drop b.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">rawstring</span><span class="hljs-params">(size <span class="hljs-type">int</span>)</span></span> (s <span class="hljs-type">string</span>, b []<span class="hljs-type">byte</span>) &#123;<br>p := mallocgc(<span class="hljs-type">uintptr</span>(size), <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>) <span class="hljs-comment">// &lt;--给p申请一块size个byte的内存空间</span><br><br>stringStructOf(&amp;s).str = p<br>stringStructOf(&amp;s).<span class="hljs-built_in">len</span> = size<br><br>    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;  <span class="hljs-comment">// &lt;--这里切片构造三个参数是slice&#123;array, len, cap&#125;，把p交给slice对象的array指针接管。就是构造一个有size大小的[]byte类型的空切片。</span><br><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是字符串拼接时，指针对内存的操作，但这里的copy()方法我没有找到实现，比较遗憾，还不够明显看到如何拷贝内存</p><p>再来看下go对外提供插件生成字符串的的gostring()方法，从中看到指针偏移拷贝内存的过程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// This is exported via linkname to assembly in syscall (for Plan9).</span><br><span class="hljs-comment">//go:linkname gostring</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gostring</span><span class="hljs-params">(p *<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>l := findnull(p)<br><span class="hljs-keyword">if</span> l == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>    s, b := rawstring(l)  <span class="hljs-comment">// &lt;--获取一个string对象s及s.str(已申请l个byte内存的[]byte切片)</span><br>    memmove(unsafe.Pointer(&amp;b[<span class="hljs-number">0</span>]), unsafe.Pointer(p), <span class="hljs-type">uintptr</span>(l))  <span class="hljs-comment">// &lt;--相当于memcpy()，将p地址起始的值逐个拷贝到b[0]指向的地址(就是[]byte的头地址)，逐个偏移，偏移l个字节。</span><br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-comment">// memmove copies n bytes from &quot;from&quot; to &quot;to&quot;.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// memmove ensures that any pointer in &quot;from&quot; is written to &quot;to&quot; with</span><br><span class="hljs-comment">// an indivisible write, so that racy reads cannot observe a</span><br><span class="hljs-comment">// half-written pointer. This is necessary to prevent the garbage</span><br><span class="hljs-comment">// collector from observing invalid pointers, and differs from memmove</span><br><span class="hljs-comment">// in unmanaged languages. However, memmove is only required to do</span><br><span class="hljs-comment">// this if &quot;from&quot; and &quot;to&quot; may contain pointers, which can only be the</span><br><span class="hljs-comment">// case if &quot;from&quot;, &quot;to&quot;, and &quot;n&quot; are all be word-aligned.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// Implementations are in memmove_*.s.</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//go:noescape</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">memmove</span><span class="hljs-params">(to, from unsafe.Pointer, n <span class="hljs-type">uintptr</span>)</span></span>   <span class="hljs-comment">// &lt;--系统函数</span><br></code></pre></td></tr></table></figure><p>我们再来看下memmove在linux系统函数中的定义（下图来自CentOS7）man 3 memmove：</p><p><img src="manbook.png"></p><p>重点关注<strong>copies</strong>字样，从src(数据源)内存区域拷贝n个字节到dest(目标)内存区域。并且<strong>线程安全</strong>。</p><blockquote><p>小贴士：memmove() 是 memcpy() 的改良版本，解决memcpy()在src和dest存在重叠的内存空间时copy数据出现的问题；因为需要向下兼容所以改了个名字叫memmove，并不是真正意义上的”move”操作。有兴趣可以再研究下内部如何做到线程安全以及避免内存空间重叠。</p></blockquote><h4 id="4-1-3-string的传递效率"><a href="#4-1-3-string的传递效率" class="headerlink" title="4.1.3 string的传递效率"></a>4.1.3 string的传递效率</h4><p>我们再来看string传参的内存分布，可以看出string传参表面上是值传递，内部的 str 则是指针传递：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// StringHeader is the runtime representation of a string.</span><br><span class="hljs-comment">// It cannot be used safely or portably and its representation may</span><br><span class="hljs-comment">// change in a later release.</span><br><span class="hljs-comment">// Moreover, the Data field is not sufficient to guarantee the data</span><br><span class="hljs-comment">// it references will not be garbage collected, so programs must keep</span><br><span class="hljs-comment">// a separate, correctly typed pointer to the underlying data.</span><br><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span><br>Len  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> stringStruct <span class="hljs-keyword">struct</span> &#123;<br>str unsafe.Pointer  <span class="hljs-comment">// 指向内存地址起点的指针</span><br>    <span class="hljs-built_in">len</span> <span class="hljs-type">int</span>             <span class="hljs-comment">// 内容的长度(占内存的字节数)</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestStringPassingParameters</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>f := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-comment">// 由于string底层的stringStruct是私有的不能直接访问，因此使用反射包通过runtime获取</span><br>hdr := (*reflect.StringHeader)(unsafe.Pointer(&amp;s))   <span class="hljs-comment">// &lt;---查看指向的内存是否一致</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, hdr.Data)<br>&#125;<br>s1 := <span class="hljs-string">&quot;abd&quot;</span><br>hdr1 := (*reflect.StringHeader)(unsafe.Pointer(&amp;s1))   <span class="hljs-comment">// &lt;---查看指向的内存是否一致</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, hdr1.Data)<br>f(s1)<br>&#125;<br><br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-comment">// === RUN   TestStringPassingParameters</span><br><span class="hljs-comment">// 3f6d04</span><br><span class="hljs-comment">// 3f6d04</span><br><span class="hljs-comment">// --- PASS: TestStringPassingParameters (0.00s)</span><br></code></pre></td></tr></table></figure><p>当外部的s1被修改时，只修改内部str的指向，旧数据仍然被其他指针引用着，因此 f 方法外的 s1 对象被修改，也不会影响到 f 方法内部的s对象；当方法退出，没有指针再引用该旧数据时，GC会将其回收。</p><blockquote><p>小贴士：</p><p>在大量字符串拼接时，应该使用bytes.Buffer，极大提高性能！</p><p>拼接字符串性能：bytes.Buffer() &gt; +号 &gt; fmt.Sprintf()</p></blockquote><h3 id="4-3-指针偏移读写内存"><a href="#4-3-指针偏移读写内存" class="headerlink" title="4.3 指针偏移读写内存"></a>4.3 指针偏移读写内存</h3><h4 id="4-3-1-读写字符串内容"><a href="#4-3-1-读写字符串内容" class="headerlink" title="4.3.1 读写字符串内容"></a>4.3.1 读写字符串内容</h4><p>我们写一段代码看看如何通过指针偏移获取字符串中的各个字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br><span class="hljs-string">&quot;unsafe&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := <span class="hljs-string">&quot;1234567&quot;</span><br><br>fmt.Println(a)<br>fmt.Println(&amp;a)<br>fmt.Println(unsafe.Pointer(&amp;a))<br><br>p := (*reflect.StringHeader)(unsafe.Pointer(&amp;a)).Data  <span class="hljs-comment">// &lt;-- 拿出底层数组的头指针，这个指针指向真实存储string内存的内存地址</span><br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, p)<br><br>p1 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p))<br>fmt.Println(*p1)  <span class="hljs-comment">// &lt;-- 打印一下是不是第一个字符的ASCII码</span><br><br>p2 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p+<span class="hljs-number">1</span>))<br>fmt.Println(*p2)  <span class="hljs-comment">// &lt;-- 向后偏移一个字节</span><br><br><span class="hljs-comment">//*p2 = 88   如果解开这个注释会panic，这里不能赋值，为什么呢？大家猜一猜~</span><br><br><span class="hljs-keyword">for</span> &#123;<br>time.Sleep(time.Minute)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 输出结果:</span><br><span class="hljs-number">1234567</span><br><span class="hljs-number">0xc000010240</span>  <span class="hljs-comment">// &lt;-- a的地址</span><br><span class="hljs-number">0xc000010240</span>  <span class="hljs-comment">// &lt;-- a的地址</span><br><span class="hljs-number">495</span>b45        <span class="hljs-comment">// &lt;-- a.str 指向的地址：真正存储string内容的内存地址</span><br><span class="hljs-number">49</span>            <span class="hljs-comment">// &lt;-- 字符1的 ASCII 码</span><br><span class="hljs-number">50</span>            <span class="hljs-comment">// &lt;-- 字符2的 ASCII 码</span><br></code></pre></td></tr></table></figure><p>我们来看看内存分布：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@czy ~]# ps -ef | grep offset<br>root      18930  18429  0 20:16 pts/1    00:00:00 go run offset_1.go<br>root      18970  18930  0 20:16 pts/1    00:00:00 /tmp/go-build4270767253/b001/exe/offset_1<br>root      19036  18991  0 20:18 pts/2    00:00:00 grep --color=auto offset<br>[root@czy ~]# cd /proc/18970<br>[root@czy 18970]# cat maps<br>00400000-00480000 r-xp 00000000 fd:00 50573659                           /tmp/go-build4270767253/b001/exe/offset_1<br>00480000-0050f000 r--p 00080000 fd:00 50573659                           /tmp/go-build4270767253/b001/exe/offset_1<br>0050f000-00527000 rw-p 0010f000 fd:00 50573659                           /tmp/go-build4270767253/b001/exe/offset_1<br>00527000-0055c000 rw-p 00000000 00:00 0 <br>c000000000-c000400000 rw-p 00000000 00:00 0 <br>c000400000-c004000000 ---p 00000000 00:00 0 <br>7f27818eb000-7f2783c9c000 rw-p 00000000 00:00 0 <br>7f2783c9c000-7f2793e1c000 ---p 00000000 00:00 0 <br>7f2793e1c000-7f2793e1d000 rw-p 00000000 00:00 0 <br>7f2793e1d000-7f27a5ccc000 ---p 00000000 00:00 0 <br>7f27a5ccc000-7f27a5ccd000 rw-p 00000000 00:00 0 <br>7f27a5ccd000-7f27a80a2000 ---p 00000000 00:00 0 <br>7f27a80a2000-7f27a80a3000 rw-p 00000000 00:00 0 <br>7f27a80a3000-7f27a851c000 ---p 00000000 00:00 0 <br>7f27a851c000-7f27a851d000 rw-p 00000000 00:00 0 <br>7f27a851d000-7f27a859c000 ---p 00000000 00:00 0 <br>7f27a859c000-7f27a85fc000 rw-p 00000000 00:00 0 <br>7fff115fc000-7fff1161d000 rw-p 00000000 00:00 0                          [stack]<br>7fff1166e000-7fff11670000 r-xp 00000000 00:00 0                          [vdso]<br>ffffffffff600000-ffffffffff601000 r-xp 00000000 00:00 0                  [vsyscall]<br><br></code></pre></td></tr></table></figure><p>我们重点关注两行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">c000000000-c000400000 rw-p <span class="hljs-number">00000000</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span> <span class="hljs-number">0</span>     <span class="hljs-comment">// &lt;--- a的地址: 0xc000010240</span><br><span class="hljs-number">00480000</span><span class="hljs-number">-0050</span>f000 r--p <span class="hljs-number">00080000</span> fd:<span class="hljs-number">00</span> <span class="hljs-number">50573659</span>  /tmp/<span class="hljs-keyword">go</span>-build4270767253/b001/exe/offset_1<br><span class="hljs-comment">// &lt;--- a.str的地址，权限是r--p，不可写。认真听课的小伙伴已经想到，该数据处于内存的Text Segment(代码段)，存储常量。</span><br></code></pre></td></tr></table></figure><blockquote><p>小贴士：权限：r-可读  w-可写  x-可执行  p-私有</p></blockquote><p>为了进一步验证指针的行为，我们再写一个非代码段的字符串来通过指针偏移读写内存：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestString_Case2</span><span class="hljs-params">(t *testing.T)</span></span>  &#123;<br>a := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, rand.Uint32())  <span class="hljs-comment">// 构造一个随机字符串</span><br>fmt.Println(a)<br><br>p := (*reflect.StringHeader)(unsafe.Pointer(&amp;a)).Data  <span class="hljs-comment">// &lt;-- 拿出底层数组的头指针，这个指针指向真实存储string内存的内存地址</span><br><br>p1 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p))<br>fmt.Println(*p1)  <span class="hljs-comment">// &lt;-- 打印一下是不是第一个字符的ASCII码</span><br><br>p2 := (*<span class="hljs-type">byte</span>)(unsafe.Pointer(p+<span class="hljs-number">1</span>))<br>fmt.Println(*p2)  <span class="hljs-comment">// &lt;-- 向后偏移一个字节</span><br><br>*p2 = <span class="hljs-number">88</span>  <span class="hljs-comment">// &lt;-- 把a的第二个字符修改为&#x27;X&#x27;</span><br>fmt.Println(a)<br>&#125;<br><br><span class="hljs-comment">// 输出结果：</span><br><span class="hljs-number">2596996162</span><br><span class="hljs-number">50</span>   &lt;-- 字符<span class="hljs-number">2</span>的ASCII码<br><span class="hljs-number">53</span>   &lt;-- 字符<span class="hljs-number">5</span>的ASCII码<br><span class="hljs-number">2</span>X96996162<br></code></pre></td></tr></table></figure><p>字符串a的值从 2596996162 变为  2X96996162，验证了string底层的实现，也验证了指针对内存的操作行为。</p><h4 id="4-3-2-读写结构体私有变量"><a href="#4-3-2-读写结构体私有变量" class="headerlink" title="4.3.2 读写结构体私有变量"></a>4.3.2 读写结构体私有变量</h4><p>share&#x2F;ptr&#x2F;ptr_offset&#x2F;ptr_offset.go 文件，构造一个私有变量c。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PtrOffsetTest <span class="hljs-keyword">struct</span> &#123;<br>A <span class="hljs-type">string</span><br>B <span class="hljs-type">int8</span><br>c <span class="hljs-type">int64</span>  <span class="hljs-comment">// &lt;-- 注意这个c是小写的（私有变量）</span><br>D <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(a <span class="hljs-type">string</span>, b <span class="hljs-type">int8</span>, c <span class="hljs-type">int64</span>, d <span class="hljs-type">string</span>)</span></span> *PtrOffsetTest &#123;<br><span class="hljs-keyword">return</span> &amp;PtrOffsetTest&#123;<br>A: a,<br>B: b,<br>c: c,<br>D: d,<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>share&#x2F;ptr&#x2F;ptr_test.go 文件，利用指针偏移方式，修改私有变量c的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPtrOffsetModifyMem</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>testPtr := ptr_offset.New(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-string">&quot;678&quot;</span>)<br>fmt.Println(testPtr)<br><br><span class="hljs-keyword">var</span> tmp <span class="hljs-type">uint32</span> = <span class="hljs-number">10000</span><br><br><span class="hljs-comment">// testPtr.c  // 正常情况下testPtr.c是ptr_offset包的私有变量，外部包不可访问</span><br>unsafePtr := unsafe.Pointer(testPtr) <span class="hljs-comment">// 转为unsafe.Pointer，但unsafe.Pointer不能做运算，因此转为uintptr</span><br>uintPtr := <span class="hljs-type">uintptr</span>(unsafePtr)<br><br><span class="hljs-comment">// 因为存在结构体字节对齐问题，因此我们已知结构体中最大系数应该是string类型，获取string类型系数</span><br>x := unsafe.Alignof(<span class="hljs-type">string</span>(<span class="hljs-string">&quot;&quot;</span>))<br>fmt.Println(x)  <span class="hljs-comment">// 得到对齐系数是8，意味着结构体内size &lt; 8的变量都按8个字节对齐</span><br><br><span class="hljs-keyword">var</span> bSize = unsafe.Sizeof(<span class="hljs-type">int8</span>(<span class="hljs-number">0</span>))<br><span class="hljs-keyword">if</span> x &gt; bSize &#123;<br>bSize = x <span class="hljs-comment">// int8是1个字节，向8字节对齐</span><br>&#125;<br><br>p := (*<span class="hljs-type">uint32</span>)(unsafe.Pointer(uintPtr + unsafe.Sizeof(testPtr.A) + bSize)) <span class="hljs-comment">// 指针偏移到testPtr.c变量的起始地址</span><br>*p = tmp<br><br>fmt.Println(testPtr)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-reflect-Ptr"><a href="#5-reflect-Ptr" class="headerlink" title="5. reflect.Ptr"></a>5. reflect.Ptr</h2><p>反射包中，也有指针类型</p><p>举一个典型的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一个mysql表model</span><br><span class="hljs-keyword">type</span> XXXXModel <span class="hljs-keyword">struct</span> &#123;<br>.....<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetXX</span><span class="hljs-params">(ctx context.Context, id <span class="hljs-type">uint</span>)</span></span> (*XXXXModel, <span class="hljs-type">error</span>) &#123;<br>db := GetDB(YiShouERP)  <span class="hljs-comment">// 获取一个gorm.DB指针</span><br><span class="hljs-keyword">var</span> info *XXXXModel<br>    err := db.WithContext(ctx).First(&amp;info)  <span class="hljs-comment">// &lt;--传递info的地址给interface&#123;&#125;</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> info, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么能正常？info变量不是nil吗？为啥不panic呢？</p><p>哦豁，有没有想起方法内可以通过二级指针改变一级指针的指向？</p><p>那必然是First()内部做了申请内存的工作~我们来看看</p><p>摘自 gorm.io\<a href="mailto:&#x67;&#111;&#x72;&#x6d;&#x40;&#x76;&#x31;&#46;&#50;&#49;&#x2e;&#56;">&#x67;&#111;&#x72;&#x6d;&#x40;&#x76;&#x31;&#46;&#50;&#49;&#x2e;&#56;</a>\callbacks.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *processor)</span></span> Execute(db *DB) &#123;<br>    ......<br>    ......<br>    <span class="hljs-comment">// assign stmt.ReflectValue</span><br><span class="hljs-keyword">if</span> stmt.Dest != <span class="hljs-literal">nil</span> &#123;<br>stmt.ReflectValue = reflect.ValueOf(stmt.Dest)<br><span class="hljs-keyword">for</span> stmt.ReflectValue.Kind() == reflect.Ptr &#123;  <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">if</span> stmt.ReflectValue.IsNil() &amp;&amp; stmt.ReflectValue.CanAddr() &#123;  <span class="hljs-comment">// 2</span><br>stmt.ReflectValue.Set(reflect.New(stmt.ReflectValue.Type().Elem()))  <span class="hljs-comment">// 3</span><br>&#125;<br><br>stmt.ReflectValue = stmt.ReflectValue.Elem()<br>&#125;<br><span class="hljs-keyword">if</span> !stmt.ReflectValue.IsValid() &#123;<br>db.AddError(ErrInvalidValue)<br>&#125;<br>&#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>我们一步步来拆解：</p><ol><li><strong>.Kind()</strong> 取得变量的反射类型，并且识别类型是否为<strong>reflect.Ptr</strong></li><li><strong>.IsNil()</strong> 判断指针是否指向<strong>nil</strong>，并且通过**.CanAddr()**判断变量地址是否可访问<ol><li>这里有一个另外的知识点，私有变量(结构体中小写开头的变量)，变量地址不可访问</li><li>可访问地址的变量，才可以修改地址指向；</li></ol></li><li>通过**.Type().Elem()<strong>取得变量的元信息，传递到</strong>reflect.New()**，用于在内部申请对应数据类型的内存空间</li></ol><p>再继续看 <strong>reflect.New()</strong> 内部实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New returns a Value representing a pointer to a new zero value</span><br><span class="hljs-comment">// for the specified type. That is, the returned Value&#x27;s Type is PtrTo(typ).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(typ Type)</span></span> Value &#123;<br>    <span class="hljs-keyword">if</span> typ == <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;reflect: New(nil)&quot;</span>)<br>    &#125;<br>    t := typ.(*rtype)<br>    ptr := unsafe_New(t)<br>    fl := flag(Ptr)<br>    <span class="hljs-keyword">return</span> Value&#123;t.ptrTo(), ptr, fl&#125;<br>&#125;<br><br><span class="hljs-comment">// implemented in package runtime</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unsafe_New</span><span class="hljs-params">(*rtype)</span></span> unsafe.Pointer<br></code></pre></td></tr></table></figure><p>通过 **.(<em>rtype)</em>* 获得了原始数据类型，使用 <strong>unsafe_New()</strong> 分配 (*rtype) 所需的内存空间。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.golang-book.com/books/intro/8#section1">https://www.golang-book.com/books/intro/8#section1</a></li><li><a href="https://github.com/redis/redis">https://github.com/redis/redis</a></li><li><a href="https://github.com/go-gorm/gorm">https://github.com/go-gorm/gorm</a></li><li><a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection">https://en.wikipedia.org/wiki/Pointer_(computer_programming)#Multiple_indirection</a></li><li><a href="https://github.com/golang101/golang101">https://github.com/golang101/golang101</a></li><li><a href="https://www.cnblogs.com/clover-toeic/p/3754433.html">https://www.cnblogs.com/clover-toeic/p/3754433.html</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
