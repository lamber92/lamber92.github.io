<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GORM-使用记录</title>
    <link href="/2023/12/23/golang/gorm/"/>
    <url>/2023/12/23/golang/gorm/</url>
    
    <content type="html"><![CDATA[<h1 id="GORM-使用记录"><a href="#GORM-使用记录" class="headerlink" title="GORM-使用记录"></a>GORM-使用记录</h1><p align="right">Lamber</p><p align="right">2023-12-23</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要记录一些开发过程中遇到使用GORM操作MySQL的需求及其实现方案。</p><p>本篇使用v1.22.2版本gorm阐述。</p><p>dbresolver的原理浅析记录在第1小节，对后面小节功能实现的理解有帮助。</p><h2 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="1. 读写分离"></a>1. 读写分离</h2><ul><li><p><strong>需求背景：</strong></p><ul><li>MySQL主节点1个，从节点7个，需要在服务侧做读写分离，并随机到从节点读数据。</li></ul></li><li><p><strong>实现方案：</strong></p><ul><li>有现成的开源项目：<a href="https://github.com/go-gorm/dbresolver">https://github.com/go-gorm/dbresolver</a></li><li>这里使用的是v1.1.0的dbresolver</li></ul></li><li><p><strong>实现示例：</strong></p><ul><li><p>定义一个MySQL配置的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MysqlConf <span class="hljs-keyword">struct</span> &#123;<br>Source      <span class="hljs-type">string</span> <span class="hljs-comment">// 主节点DSN</span><br>Replicas    []<span class="hljs-type">string</span> <span class="hljs-comment">// 从节点DSN组</span><br>....<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置应用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterDBResolver</span><span class="hljs-params">(db *gorm.DB, conf *MysqlConf)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(conf.Replicas) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> (<br>sources  []gorm.Dialector<br>replicas []gorm.Dialector<br>)<br>sources = <span class="hljs-built_in">append</span>(sources, mysql.Open(conf.Source))<br>        <span class="hljs-keyword">for</span> _, dsn := <span class="hljs-keyword">range</span> conf.Replicas &#123;<br>            replicas = <span class="hljs-built_in">append</span>(replicas, mysql.Open(dsn))<br>        &#125;<br>resolver := dbresolver.Register(dbresolver.Config&#123;<br>Sources:  sources,<br>Replicas: replicas,<br><span class="hljs-comment">// 代理规则是随机</span><br>Policy: dbresolver.RandomPolicy&#123;&#125;,<br>&#125;)<br><span class="hljs-comment">// 注册读写分离解析器</span><br><span class="hljs-keyword">if</span> err := db.Use(resolver); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>实现原理：</strong></p><ul><li><p>整个包代码不多，逻辑很清晰，主要是基于GORM的插件扩展接口实现，以及GORM执行SQL前的丰富CallBack</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Plugin GORM plugin interface</span><br><span class="hljs-keyword">type</span> Plugin <span class="hljs-keyword">interface</span> &#123;<br>Name() <span class="hljs-type">string</span><br>Initialize(*DB) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GORM提供的这套回调方法，可以让调用者精细地在每一种操作前后插入中间干预操作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Create() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;create&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Query() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;query&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Update() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;update&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Delete() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;delete&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Row() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;row&quot;</span>]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cs *callbacks)</span></span> Raw() *processor &#123;<br><span class="hljs-keyword">return</span> cs.processors[<span class="hljs-string">&quot;raw&quot;</span>]<br>&#125;<br>......<br></code></pre></td></tr></table></figure></li><li><p>在解析器的包实现里，可以看到有对应实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gorm:db_resolver&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> Initialize(db *gorm.DB) <span class="hljs-type">error</span> &#123;<br>dr.DB = db<br>dr.registerCallbacks(db)<br><span class="hljs-keyword">return</span> dr.compile()<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>这里可以追踪到 gorm.Plugin.Initialize() 的两处触发调用位置：</p><ul><li><p>gorm.Open() &lt;– 适用于建立MySQL连接前确定插件列表；</p></li><li><p>gorm.DB.Use() &lt;– 上面例子是使用了这种方法，适用于在得到MySQL连接后，再追加加载插件。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db *DB)</span></span> Use(plugin Plugin) <span class="hljs-type">error</span> &#123;<br>name := plugin.Name()<br><span class="hljs-keyword">if</span> _, ok := db.Plugins[name]; ok &#123;<br><span class="hljs-keyword">return</span> ErrRegistered<br>&#125;<br><span class="hljs-keyword">if</span> err := plugin.Initialize(db); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>db.Plugins[name] = plugin<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>然后看dbresolver.DBResolver的registerCallbacks这个方法的处理方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 重点在于这个方法，将SQL操作区分出Write与Read，给Read操作区分DB.Connector做铺垫。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> registerCallbacks(db *gorm.DB) &#123;<br>dr.Callback().Create().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchSource)<br>dr.Callback().Query().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchReplica)<br>dr.Callback().Update().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchSource)<br>dr.Callback().Delete().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchSource)<br>dr.Callback().Row().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchReplica)<br>dr.Callback().Raw().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:db_resolver&quot;</span>, dr.switchGuess)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> switchSource(db *gorm.DB) &#123;<br>    <span class="hljs-comment">// 非事务操作才走解析器，下同，不赘述。</span><br><span class="hljs-keyword">if</span> !isTransaction(db.Statement.ConnPool) &#123;<br>        <span class="hljs-comment">// 通过解析器，选择SQL执行的连接池，下同，不赘述。</span><br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> switchReplica(db *gorm.DB) &#123;<br><span class="hljs-keyword">if</span> !isTransaction(db.Statement.ConnPool) &#123;<br><span class="hljs-keyword">if</span> rawSQL := db.Statement.SQL.String(); <span class="hljs-built_in">len</span>(rawSQL) &gt; <span class="hljs-number">0</span> &#123;<br>dr.switchGuess(db)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这个&quot;FOR&quot;是默认query事件默认携带的</span><br>_, locking := db.Statement.Clauses[<span class="hljs-string">&quot;FOR&quot;</span>]<br>            <span class="hljs-comment">// 这里区分除了Write和Read，从而解析出不同的DB连接。</span><br>            <span class="hljs-comment">// 这里注意这个&quot;writeName&quot;标识，这个&quot;标识&quot;使得可以在业务侧修改Clauses的值，让查询强制走主节点，使用场景请看下文；下同，不赘述。</span><br><span class="hljs-keyword">if</span> _, ok := db.Statement.Clauses[writeName]; ok || locking &#123;<br>                <span class="hljs-comment">// 这里走到dr.resolve()方法，这个方法给用户提供了更高的扩展性，下文详细分析。</span><br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Read)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> switchGuess(db *gorm.DB) &#123;<br><span class="hljs-keyword">if</span> !isTransaction(db.Statement.ConnPool) &#123;<br><span class="hljs-keyword">if</span> _, ok := db.Statement.Clauses[writeName]; ok &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> rawSQL := strings.TrimSpace(db.Statement.SQL.String()); <span class="hljs-built_in">len</span>(rawSQL) &gt; <span class="hljs-number">10</span> &amp;&amp; strings.EqualFold(rawSQL[:<span class="hljs-number">6</span>], <span class="hljs-string">&quot;select&quot;</span>) &amp;&amp; !strings.EqualFold(rawSQL[<span class="hljs-built_in">len</span>(rawSQL)<span class="hljs-number">-10</span>:], <span class="hljs-string">&quot;for update&quot;</span>) &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Read)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db.Statement.ConnPool = dr.resolve(db.Statement, Write)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isTransaction</span><span class="hljs-params">(connPool gorm.ConnPool)</span></span> <span class="hljs-type">bool</span> &#123;<br>_, ok := connPool.(gorm.TxCommitter)<br><span class="hljs-keyword">return</span> ok<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再往里看，dbresolver.DBResolver 的 resolve() 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> resolve(stmt *gorm.Statement, op Operation) gorm.ConnPool &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(dr.resolvers) &gt; <span class="hljs-number">0</span> &#123;<br>        <span class="hljs-comment">// 这个特别注意usingName，这个标识是dbresolver的关键扩展项。</span><br><span class="hljs-keyword">if</span> u, ok := stmt.Clauses[usingName].Expression.(using); ok &amp;&amp; u.Use != <span class="hljs-string">&quot;&quot;</span> &#123;<br>            <span class="hljs-comment">// u.Use是usingName的动作，用于在解析器组中查找是否存在指定的解析器(标识这个特殊逻辑为[1])</span><br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[u.Use]; ok &#123;<br>                <span class="hljs-comment">// 无一例外都会走到resolve这个方法</span><br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> stmt.Table != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[stmt.Table]; ok &#123;<br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> stmt.Schema != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[stmt.Schema.Table]; ok &#123;<br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> rawSQL := stmt.SQL.String(); rawSQL != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">if</span> r, ok := dr.resolvers[getTableFromRawSQL(rawSQL)]; ok &#123;<br><span class="hljs-keyword">return</span> r.resolve(stmt, op)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> dr.global != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> dr.global.resolve(stmt, op)<br>&#125;<br><br><span class="hljs-keyword">return</span> stmt.ConnPool<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后会走到 dbresolver.resolver.resolve() 方法，选择之前创建好的主从连接。至此，读写分离的主流程就走完了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *resolver)</span></span> resolve(stmt *gorm.Statement, op Operation) (connPool gorm.ConnPool) &#123;<br><span class="hljs-keyword">if</span> op == Read &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.replicas) == <span class="hljs-number">1</span> &#123;<br>connPool = r.replicas[<span class="hljs-number">0</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>connPool = r.policy.Resolve(r.replicas)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(r.sources) == <span class="hljs-number">1</span> &#123;<br>connPool = r.sources[<span class="hljs-number">0</span>]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>connPool = r.policy.Resolve(r.sources)<br>&#125;<br><br><span class="hljs-keyword">if</span> stmt.DB.PrepareStmt &#123;<br><span class="hljs-keyword">if</span> preparedStmt, ok := r.dbResolver.prepareStmtStore[connPool]; ok &#123;<br><span class="hljs-keyword">return</span> &amp;gorm.PreparedStmtDB&#123;<br>ConnPool: connPool,<br>Mux:      preparedStmt.Mux,<br>Stmts:    preparedStmt.Stmts,<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>这里延伸出一个问题，如果要求实时性很高，要强制查主节点，使用dbresolver会影响吗？</strong></p><ul><li><p>dbresolver和gorm提供了强制查主节点的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.Clauses(dbresolver.Write)<br></code></pre></td></tr></table></figure></li><li><p>看看这个Clauses()方法做了什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Clauses Add clauses</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db *DB)</span></span> Clauses(conds ...clause.Expression) (tx *DB) &#123;<br>tx = db.getInstance()<br><span class="hljs-keyword">var</span> whereConds []<span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">for</span> _, cond := <span class="hljs-keyword">range</span> conds &#123;<br>        <span class="hljs-comment">// 这里看cond是否是clause.Interface的实现，如果是则调AddClause()</span><br><span class="hljs-keyword">if</span> c, ok := cond.(clause.Interface); ok &#123;<br>tx.Statement.AddClause(c)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> optimizer, ok := cond.(StatementModifier); ok &#123;<br>optimizer.ModifyStatement(tx.Statement)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>whereConds = <span class="hljs-built_in">append</span>(whereConds, cond)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(whereConds) &gt; <span class="hljs-number">0</span> &#123;<br>tx.Statement.AddClause(clause.Where&#123;Exprs: tx.Statement.BuildCondition(whereConds[<span class="hljs-number">0</span>], whereConds[<span class="hljs-number">1</span>:]...)&#125;)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>看gorm.AddClause()方法做了什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// AddClause add clause</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(stmt *Statement)</span></span> AddClause(v clause.Interface) &#123;<br><span class="hljs-keyword">if</span> optimizer, ok := v.(StatementModifier); ok &#123;<br>optimizer.ModifyStatement(stmt)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 会调用Name()方法，得到一个标识，并存入stmt.Clauses。</span><br>        <span class="hljs-comment">// 这里很容易联系到上文中 db.Statement.Clauses[writeName] 走Write节点的逻辑。继续往下追查确实如此。</span><br>name := v.Name()<br>c := stmt.Clauses[name]<br>c.Name = name<br>v.MergeClause(&amp;c)<br>stmt.Clauses[name] = c<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>接下来看dbresolver如何实现clause.Interface，证实了上文的猜想。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>Write Operation = <span class="hljs-string">&quot;write&quot;</span><br>Read  Operation = <span class="hljs-string">&quot;read&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Operation <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> writeName = <span class="hljs-string">&quot;gorm:db_resolver:write&quot;</span><br><br><span class="hljs-comment">// 实现了clause.Interface.Name()，这样就把&quot;writeName&quot;设置进了db.Statement.Clauses，</span><br><span class="hljs-comment">// 也就让dbresolver在执行 switchReplica() 时走了Write的分支逻辑，即在主节点查询。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(op Operation)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> op == Write &#123;<br><span class="hljs-keyword">return</span> writeName<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;gorm:db_resolver:read&quot;</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(op Operation)</span></span> Build(clause.Builder) &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(op Operation)</span></span> MergeClause(*clause.Clause) &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul></li></ul><h2 id="2-指定使用某DB节点"><a href="#2-指定使用某DB节点" class="headerlink" title="2. 指定使用某DB节点"></a>2. 指定使用某DB节点</h2><ul><li><p><strong>需求背景：</strong></p><ul><li>在7个从节点中，有其中4个节点配置较高，另外3个节点配置较低；<ul><li>配置较高的节点提供APP访问用，配置较低的节点用于后台系统查询，因此后台业务需要指定使用这3个节点进行读取。</li><li>而我们的业务代码中，有部分Model层方法是后台与APP逻辑共用的；且在分布式系统中，部分gRPC接口是后台与APP逻辑共用的；因此需要考虑改动量最低的方案，并尽量让业务层无感知。</li></ul></li></ul></li><li><p><strong>实现方案：</strong></p><ul><li><p><strong>有两种方式，第一种是使用gorm.DB.AddClause()方法显式指定MySQL执行节点</strong></p></li><li><p>在上一小点记录了如何强制使用主节点，以及在dbresolver.DBResolver 的 <strong>resolve()</strong> 方法中，会优先判断 <strong>gorm.Statement.Clause</strong> 是否有<strong>usingName</strong>，从而继续查找指定的 <strong>dbresolver.resolver</strong> 可以利用这点来实现对MySQL节点的选择。</p></li><li><p>先在配置中添加一套指定的Source与Replicas，并注册到resolver：</p><ul><li>这里其实就是把需要独立访问的3个节点拆分出来，单独与主节点形成一套新的配置，并以specifyNodeName命名。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">resolver = resolver.Register(dbresolver.Config&#123;<br>    Sources:  sources,<br>    Replicas: spReplicas,<br>    Policy:   dbresolver.RandomPolicy&#123;&#125;,<br>&#125;, SpecifyNodeName) <span class="hljs-comment">// 注意，这里的变量值需要与下文调用DB.AddClause()显示切换节点的变量值一致。</span><br></code></pre></td></tr></table></figure><ul><li><p>有兴趣可以追查到这个<strong>SpecifyNodeName变量</strong>最终会记录到 <strong>dbresolver.DBResolver.resolvers</strong> 中，因此可以走到标识逻辑[i]中，从而找到对应的解析器(存有指定MySQL节点的连接池)</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(dr *DBResolver)</span></span> compileConfig(config Config) (err <span class="hljs-type">error</span>) &#123;<br>......<br><span class="hljs-comment">// 注意这一段代码</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(config.datas) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">for</span> _, data := <span class="hljs-keyword">range</span> config.datas &#123;<br><span class="hljs-keyword">if</span> t, ok := data.(<span class="hljs-type">string</span>); ok &#123;<br>dr.resolvers[t] = &amp;r<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>stmt := &amp;gorm.Statement&#123;DB: dr.DB&#125;<br><span class="hljs-keyword">if</span> err := stmt.Parse(data); err == <span class="hljs-literal">nil</span> &#123;<br>dr.resolvers[stmt.Table] = &amp;r<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br>&#125;<br>&#125; ......<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>在业务逻辑中，只需要在gorm.DB的调用链中加入以下代码即可实现显式选择MySQL执行节点：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.AddClause(dbresolver.Use(SpecifyNodeName)<br></code></pre></td></tr></table></figure></li><li><p><strong>第二种方式，是作用于整条逻辑链路上的所有SQL语句</strong></p></li><li><p>这种方式，依赖于go语言编码过程中核心参数：Context；在具备良好编程风格的代码中，gorm.DB.WithContext()自然是必不可少的。</p></li><li><p>实现方式是基于第一种方式的原理上，把AddClause放到gorm的Callback()方法中处理，这样业务层就不需要做任何改动了。</p><ul><li>需要注意的是，Before(“*”)，因为节点的选择应该是优先级最高的；并且注册逻辑在gorm.DB.Use(resolver)前，即与dbresolver的原始注册逻辑同时加载到gorm的插件组中。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RegisterQuerySpecifyNode</span><span class="hljs-params">(db *gorm.DB)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> db.Callback().Query().Before(<span class="hljs-string">&quot;*&quot;</span>).Register(<span class="hljs-string">&quot;gorm:specify-node&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br>        node := db.Statement.Context.Value(<span class="hljs-string">&quot;specify_node_key&quot;</span>)<br>        <span class="hljs-keyword">if</span> node != <span class="hljs-literal">nil</span> &#123;<br>            db.Statement.AddClause(dbresolver.Use(node.String()))<br>        &#125;<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在链路的起始位置对ctx加入”specify_node_key”的kv，例如插入点在http接口请求中间件中，即可实现逻辑链路中对SQL执行读操作节点的控制。</p><ul><li>这里的ctx可以是二次封装的Context结构对象，这又是另一个话题，这里不详细说明了，只使用go方法提供的<strong>valueCtx</strong>对象举例。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ctx = context.WithValue(ctx, <span class="hljs-string">&quot;specify_node_key&quot;</span>, <span class="hljs-string">&quot;specify_node&quot;</span>)<br></code></pre></td></tr></table></figure></li><li><p>这里可以延伸一下，在分布式gRPC调用链中，也可以通过Context控制下游服务指定MySQL节点，这种方式是go的基操，不多说。</p></li></ul></li></ul><h2 id="3-限制某些表不能执行Delete操作"><a href="#3-限制某些表不能执行Delete操作" class="headerlink" title="3. 限制某些表不能执行Delete操作"></a>3. 限制某些表不能执行Delete操作</h2><ul><li><p><strong>需求背景：</strong></p><ul><li>业务中需要大量的热数据表，而热数据表与原数据表命名类似，热数据表只保留某时间段内的数据，而原表则有全量数据且基本只有软删。为了防止误删数据，需要在代码层面先限制某些表不能执行Delete操作，将原数据表保护起来。</li><li>虽然在生产和UAT环境中，运维层面也对MySQL账号做了限制，但代码层面也做防范能更精细地做控制，也减少沟通成本。</li></ul></li><li><p><strong>实现方案：</strong></p><ul><li><p>利用gorm.DB.Callback中，Delete操作的前置操作做拦截。</p><ul><li>这里做一步优化，为了减少业务层面的改动，以及避免对现有逻辑的改动，使用接口类型判断实现比较合理。</li><li>先声明一个控制表可删除数据的接口”RestrictedTableDeleter”，再声明一个”CanDelete”方法，那么现有的表Model就可以通过实现这个接口方法让gorm在Callback中轻松判断是否该表的Delete操作被限制。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RestrictedTableDeleter 接口定义</span><br><span class="hljs-keyword">type</span> RestrictedTableDeleter <span class="hljs-keyword">interface</span> &#123;<br>CanDelete() <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-comment">// UserModel 用户表模型</span><br><span class="hljs-keyword">type</span> UserModel <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-type">uint</span><br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// 实现 RestrictedTableDeleter 接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *UserModel)</span></span> CanDelete() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 在这里实现逻辑，判断是否允许删除数据</span><br><span class="hljs-comment">// 这个例子中简单地返回 true，表示允许删除</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在gorm实例初始化后，注册Delete操作的前置行为，判断Model是否包含CanDelete方法与该方法的返回值，拦截误删操作。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 注册 BeforeDelete 钩子，限制只有满足条件的数据可以删除</span><br>db.Callback().Delete().Before(<span class="hljs-string">&quot;gorm:before_delete&quot;</span>).Register(<span class="hljs-string">&quot;gorm:check-delete-allowed&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(db *gorm.DB)</span></span> &#123;<br>    <span class="hljs-comment">// 获取删除的模型</span><br>    model := db.Statement.Model<br>    <span class="hljs-comment">// 判断是否为实现了 RestrictedTableDeleter 接口的模型</span><br>    <span class="hljs-keyword">if</span> deleter, ok := model.(RestrictedTableDeleter); ok &#123;<br>        <span class="hljs-comment">// 调用 CanDelete 方法判断是否允许删除</span><br>        <span class="hljs-keyword">if</span> deleter.CanDelete() &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Delete operation is allowed for this data.&quot;</span>)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;Delete operation is not allowed for this data.&quot;</span>)<br>            db.AddError(fmt.Errorf(<span class="hljs-string">&quot;delete operation is not allowed for this data&quot;</span>))<br>        &#125;<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Agollo项目学习与魔改记录</title>
    <link href="/2023/08/03/golang/agollo/"/>
    <url>/2023/08/03/golang/agollo/</url>
    
    <content type="html"><![CDATA[<h1 id="Agollo项目学习与魔改记录"><a href="#Agollo项目学习与魔改记录" class="headerlink" title="Agollo项目学习与魔改记录"></a>Agollo项目学习与魔改记录</h1><p align="right">Lamber</p><p align="right">2023-08-03</p><p>​    </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇原意是记录 <a href="https://github.com/apolloconfig/agollo">apolloconfig&#x2F;agollo</a> v4.3.1学习心得。</p><p>试用后感觉有些用得不太舒服的地方，决定魔改一下它~</p><p>魔改后项目路径：<a href="https://github.com/lamber92/agollo">lamber92&#x2F;agollo</a></p><p>改动点：</p><ul><li>首次连接Apollo服务时检查IP地址、App秘钥合法性，并同步返回连接失败原因；</li><li>修改Log接口定义，使之与其他开源库Log库更加贴合；</li><li>修复请求失败后，因为触发重试机制导致body没有释放而可能导致短暂内存泄露的问题；</li><li>支持动态新增指定namespace配置缓存，并自动监听对应namespace配置变动；<ul><li>改写 GetConfigAndInit() 方法</li><li>改写 notify 包逻辑</li></ul></li><li>优化针对请求 notifications&#x2F;v2&#x2F; 接口因为系统架构中存在中间网络组件导致返回http-status-code&#x3D;401时的处理方式（<a href="https://github.com/apolloconfig/apollo/issues/3652">#3652</a>）；</li><li>增加3个常用错误，方便业务层面处理；</li><li>修改部分变量名称及注释，使之更贴合实际意义；</li></ul><p>​    </p><h3 id="Agollo启动的大致流程"><a href="#Agollo启动的大致流程" class="headerlink" title="Agollo启动的大致流程"></a>Agollo启动的大致流程</h3><p><img src="start.png"></p><h2 id="1-检验Secret合法性"><a href="#1-检验Secret合法性" class="headerlink" title="1. 检验Secret合法性"></a>1. 检验Secret合法性</h2><h3 id="1-1-现象"><a href="#1-1-现象" class="headerlink" title="1.1. 现象"></a>1.1. 现象</h3><p>使用原版客户端，填写<strong>错误的secret</strong>，比如我使用README中的示例配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">Apollo:</span><br>  <span class="hljs-attr">IP:</span> <span class="hljs-string">&quot;http://apollo-configservice-dev.example.com&quot;</span><br>  <span class="hljs-attr">AppID:</span> <span class="hljs-string">&quot;example-app-id&quot;</span><br>  <span class="hljs-attr">Cluster:</span> <span class="hljs-string">&quot;dev1&quot;</span><br>  <span class="hljs-attr">NamespaceName:</span> <span class="hljs-string">&quot;application&quot;</span><br>  <span class="hljs-attr">IsBackupConfig:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">Secret:</span> <span class="hljs-string">&quot;xxxxxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><br></code></pre></td></tr></table></figure><p>​    </p><p>日志的内容非常具有迷惑性，会输出 <strong>“agollo start finished ! “</strong> 日志，让我误以为配置一切正常；</p><p>当尝试使用 <strong>Load()</strong> 方法读取远程配置时，会因为获取配置缓存失败而报错；</p><p>如果在生产环境中填错了secret，是十分危险的，应该在初始化时就把配置异常暴露出来，避免执行业务逻辑时才感知异常；</p><p>​    </p><h3 id="1-2-分析"><a href="#1-2-分析" class="headerlink" title="1.2. 分析"></a>1.2. 分析</h3><p>先说根本原因：</p><p>在调用 <strong>StartWithConfig()</strong> 方法时，<strong>AppConfig.MustStart</strong>参数没有置为<strong>True</strong>，最终没有校验secret的有效性~~！</p><p>​    </p><p>来看下原库v4.3.1代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartWithConfig</span><span class="hljs-params">(loadAppConfig <span class="hljs-keyword">func</span>()</span></span> (*config.AppConfig, <span class="hljs-type">error</span>)) (Client, <span class="hljs-type">error</span>) &#123;<br>......<br><br>serverlist.InitSyncServerIPList(c.getAppConfig) <span class="hljs-comment">// &lt;---初始化时需要请求Apollo服务的两处</span><br><br><span class="hljs-comment">//first sync</span><br>configs := syncApolloConfig.Sync(c.getAppConfig) <span class="hljs-comment">// &lt;---初始化时需要请求Apollo服务的两处</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(configs) == <span class="hljs-number">0</span> &amp;&amp; appConfig != <span class="hljs-literal">nil</span> &amp;&amp; appConfig.MustStart &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;start failed cause no config was read&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, apolloConfig := <span class="hljs-keyword">range</span> configs &#123;<br>c.cache.UpdateApolloConfig(apolloConfig, c.getAppConfig)<br>&#125;<br><br>log.Debug(<span class="hljs-string">&quot;init notifySyncConfigServices finished&quot;</span>)<br><br>......<br><br>log.Info(<span class="hljs-string">&quot;agollo start finished ! &quot;</span>)<br><br><span class="hljs-keyword">return</span> c, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出这个方法内很少去处理内部错误，并将错误返回到调用方，而是直接将err<strong>吞掉</strong>了，导致业务侧无法获得apollo-client真正初始化成功的依据；</p><p>​    </p><p>从命名上看，下面两个方法似乎比较关键~</p><p><strong>serverlist.InitSyncServerIPList(c.getAppConfig)</strong> </p><p><strong>syncApolloConfig.Sync(c.getAppConfig)</strong></p><p>​    </p><p>先看 <strong>serverlist.InitSyncServerIPList(c.getAppConfig)</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//InitSyncServerIPList 初始化同步服务器信息列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitSyncServerIPList</span><span class="hljs-params">(appConfig <span class="hljs-keyword">func</span>()</span></span> config.AppConfig) &#123;<br><span class="hljs-keyword">go</span> component.StartRefreshConfig(&amp;SyncServerIPListComponent&#123;appConfig&#125;)<br>&#125;<br><br><span class="hljs-comment">//SyncServerIPListComponent set timer for update ip list</span><br><span class="hljs-comment">//interval : 20m</span><br><span class="hljs-keyword">type</span> SyncServerIPListComponent <span class="hljs-keyword">struct</span> &#123;<br>appConfig <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，这是一个异步任务，再往里看</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> component<br><br><span class="hljs-comment">//AbsComponent 定时组件</span><br><span class="hljs-keyword">type</span> AbsComponent <span class="hljs-keyword">interface</span> &#123;<br>Start()<br>&#125;<br><br><span class="hljs-comment">//StartRefreshConfig 开始定时服务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">StartRefreshConfig</span><span class="hljs-params">(component AbsComponent)</span></span> &#123;<br>component.Start()<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个定时组件接口，内部调用 <strong>Start()</strong> 方法，那么联系上下文，就是调用了 <strong>SyncServerIPListComponent</strong> 对象的 <strong>Start()</strong> 方法</p><p>继续看后面的逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Start 启动同步服务器列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *SyncServerIPListComponent)</span></span> Start() &#123;<br>SyncServerIPList(s.appConfig)<br>log.Debug(<span class="hljs-string">&quot;syncServerIpList started&quot;</span>)<br><br>t2 := time.NewTimer(refreshIPListInterval)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t2.C:<br>SyncServerIPList(s.appConfig)<br>t2.Reset(refreshIPListInterval)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//SyncServerIPList sync ip list from server</span><br><span class="hljs-comment">//then</span><br><span class="hljs-comment">//1.update agcache</span><br><span class="hljs-comment">//2.store in disk</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SyncServerIPList</span><span class="hljs-params">(appConfigFunc <span class="hljs-keyword">func</span>()</span></span> config.AppConfig) (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*config.ServerInfo, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> appConfigFunc == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;can not find apollo config!please confirm!&quot;</span>)<br>&#125;<br>......<br>    <br>serverMap, err := http.Request(appConfig.GetServicesConfigURL(), c, &amp;http.CallBack&#123;<br>SuccessCallBack: SyncServerIPListSuccessCallBack,<br>AppConfigFunc:   appConfigFunc,<br>&#125;)<br>    <br>......<br><br>m := serverMap.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*config.ServerInfo)<br>server.SetServers(appConfig.GetHost(), m)  <span class="hljs-comment">// &lt;--注意：将Apollo返回的Meta-Service信息保存</span><br><span class="hljs-keyword">return</span> m, err<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//GetServicesConfigURL 获取服务器列表url</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AppConfig)</span></span> GetServicesConfigURL() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%sservices/config?appId=%s&amp;ip=%s&quot;</span>,<br>a.GetHost(),<br>url.QueryEscape(a.AppID),<br>utils.GetInternal())<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 <strong>services&#x2F;config</strong> 接口，获取Apollo服务IP列表；</p><p>结合 <a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_12-%e6%9e%b6%e6%9e%84%e6%a8%a1%e5%9d%97">Apollo架构模块</a>，这部分的逻辑其实是获取<strong>Apollo-Meta-Service</strong>地址，结合Eureka注册发现，实现负载均衡；</p><p>但是这里有一个坑<a href="#1270">#1270</a>，会一直触发<strong>ERROR</strong>级别日志，使得使用者会误以为底层连接出现问题，其实逻辑上并不会对配置产生影响；</p><p>​    </p><p>再看<strong>syncApolloConfig.Sync(c.getAppConfig)</strong></p><p>即调用了 <strong>(*syncApolloConfig).Sync()</strong> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *syncApolloConfig)</span></span> Sync(ctx context.Context, appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig) []*config.ApolloConfig &#123;<br>appConfig := appConfigFunc()<br>configs := <span class="hljs-built_in">make</span>([]*config.ApolloConfig, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>)<br>config.SplitNamespaces(appConfig.NamespaceName, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>)</span></span> &#123;<br>apolloConfig := a.SyncWithNamespace(ctx, namespace, appConfigFunc) <span class="hljs-comment">// &lt;--注意看这里</span><br><span class="hljs-keyword">if</span> apolloConfig != <span class="hljs-literal">nil</span> &#123;<br>configs = <span class="hljs-built_in">append</span>(configs, apolloConfig)<br><span class="hljs-keyword">return</span><br>&#125;<br>configs = <span class="hljs-built_in">append</span>(configs, loadBackupConfig(appConfig.NamespaceName, appConfig)...)<br>&#125;)<br><span class="hljs-keyword">return</span> configs<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <strong>SyncWithNamespace()</strong> 方法中会调用 <a href="https://www.apolloconfig.com/#/zh/usage/other-language-client-user-guide?id=_12-%e9%80%9a%e8%bf%87%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84http%e6%8e%a5%e5%8f%a3%e4%bb%8eapollo%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae"><strong>configfiles&#x2F;json</strong></a> 接口获取远程配置，然后更新本地缓存。</p><p>这里看到了<strong>判断是否成功地获取远程配置的关键逻辑</strong>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//first sync</span><br>configs := syncApolloConfig.Sync(c.getAppConfig)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(configs) == <span class="hljs-number">0</span> &amp;&amp; appConfig != <span class="hljs-literal">nil</span> &amp;&amp; appConfig.MustStart &#123;  <span class="hljs-comment">// &lt;--MustStart 配置参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;start failed cause no config was read&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, apolloConfig := <span class="hljs-keyword">range</span> configs &#123;<br>    c.cache.UpdateApolloConfig(apolloConfig, c.getAppConfig)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果填错了Secret，必然读不到远程配置；</p><p>而 <strong>RequestRecovery()</strong> 内部默认有5次重试，每次间隔2秒；</p><p>因此<strong>堵塞10秒</strong>后，会到达 <strong>len(configs) &#x3D;&#x3D; 0 &amp;&amp; appConfig !&#x3D; nil &amp;&amp; appConfig.MustStart</strong> 的判断逻辑；</p><p>又因为 <strong>appConfig.MustStart</strong> 默认值是<strong>false</strong>，会继续往下执行后续逻辑，此时就忽略了Secret错误导致配置没有读取成功的错误。</p><p>​    </p><p>如果将 <strong>MustStart</strong> 配置项填<strong>true</strong>，满足检测Secret合法性的需求；</p><p>但是还是需要等待10s才能消耗完底层请求的默认重试次数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//AppConfig 配置文件</span><br><span class="hljs-keyword">type</span> AppConfig <span class="hljs-keyword">struct</span> &#123;<br>AppID             <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;appId&quot;`</span><br>Cluster           <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;cluster&quot;`</span><br>NamespaceName     <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;namespaceName&quot;`</span><br>IP                <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;ip&quot;`</span><br>IsBackupConfig    <span class="hljs-type">bool</span>   <span class="hljs-string">`default:&quot;true&quot; json:&quot;isBackupConfig&quot;`</span><br>BackupConfigPath  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;backupConfigPath&quot;`</span><br>Secret            <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;secret&quot;`</span><br>Label             <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;label&quot;`</span><br>SyncServerTimeout <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;syncServerTimeout&quot;`</span><br><span class="hljs-comment">// MustStart 可用于控制第一次同步必须成功</span><br>MustStart               <span class="hljs-type">bool</span> <span class="hljs-string">`default:&quot;false&quot;`</span> <span class="hljs-comment">// &lt;-- 强制校验远程配置是否获取成功的开关</span><br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><h3 id="1-3-魔改"><a href="#1-3-魔改" class="headerlink" title="1.3. 魔改"></a>1.3. 魔改</h3><p>因为apollo客户端作为重要的配置加载组件，在服务启动时尤为关键，应该尽快暴露首次连接失败的原因，及时排查问题；</p><p>因此想办法加上首次连接失败后马上抛出错误的机制；</p><p>变动项：</p><ul><li><strong>SyncServerIPList()</strong>  先同步执行一次，确保能够正常获取Meta-Service信息，保证IP配置正确；</li><li>利用 <a href="https://www.apolloconfig.com/#/zh/usage/other-language-client-user-guide?id=_12-%e9%80%9a%e8%bf%87%e5%b8%a6%e7%bc%93%e5%ad%98%e7%9a%84http%e6%8e%a5%e5%8f%a3%e4%bb%8eapollo%e8%af%bb%e5%8f%96%e9%85%8d%e7%bd%ae"><strong>configfiles&#x2F;json</strong></a> 需要secret的特性，在 <strong>SyncServerIPList()</strong> 执行成功后，同步地请求获取一次远程配置，保证secret配置正确；</li><li>上面两个步骤执行完成后，再启动异步定时更新 IPList 的任务；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// InitSyncServerIPList 初始化同步服务器信息列表</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitSyncServerIPList</span><span class="hljs-params">(ctx context.Context, appConfig <span class="hljs-keyword">func</span>()</span></span> config.AppConfig) <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// sync ip list once at first</span><br><span class="hljs-keyword">if</span> _, err := SyncServerIPList(ctx, appConfig); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>    <span class="hljs-comment">// check if the secret is valid</span><br><span class="hljs-keyword">if</span> err := CheckSecretOK(ctx, appConfig); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>    <span class="hljs-comment">// start scheduled tasks to async update ip list</span><br><span class="hljs-keyword">go</span> component.StartRefreshConfig(&amp;SyncServerIPListComponent&#123;<br>appConfig: appConfig,<br>stopCh:    <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;),<br>&#125;)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>CheckSecretOK()</strong> 直接调用 Request()，并判断response-http-status-code是否是 <strong>401</strong> ，是则直接返回错误；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> res *http.Response<br>res, err = client.Do(req)<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">defer</span> res.Body.Close()<br>&#125;<br><span class="hljs-keyword">if</span> res == <span class="hljs-literal">nil</span> || err != <span class="hljs-literal">nil</span> &#123;<br>    log.Warnf(<span class="hljs-string">&quot;request failed. url: %s, err: %s&quot;</span>, requestURL, err)<br>    <span class="hljs-comment">// if error then sleep</span><br>    time.Sleep(onErrorRetryInterval)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, continueErr<br>&#125;<br><br><span class="hljs-comment">// not modified break</span><br><span class="hljs-keyword">switch</span> res.StatusCode &#123;<br>    <span class="hljs-keyword">case</span> http.StatusOK:<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusNotModified:<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusUnauthorized:<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusUnauthorized:<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perror.ErrUnauthorized<br>        ......<br>    <span class="hljs-keyword">case</span> http.StatusNotFound:<br>        ......<br>    <span class="hljs-keyword">default</span>:<br>    log.Debugf(<span class="hljs-string">&quot;response return err. url: %s, http-status-code: %d&quot;</span>, requestURL, res.StatusCode)<br>    <span class="hljs-comment">// if error then sleep</span><br>    time.Sleep(onErrorRetryInterval)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, continueErr<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RequestRecovery 可以恢复的请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RequestRecovery</span><span class="hljs-params">(ctx context.Context,</span></span><br><span class="hljs-params"><span class="hljs-function">appConfig config.AppConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">connectConfig *env.ConnectConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">callBack *CallBack)</span></span> (response <span class="hljs-keyword">interface</span>&#123;&#125;, err <span class="hljs-type">error</span>) &#123;<br><br><span class="hljs-keyword">for</span> &#123;<br>host := loadBalance(appConfig)<br><span class="hljs-keyword">if</span> host == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>requestURL := fmt.Sprintf(<span class="hljs-string">&quot;%s%s&quot;</span>, host, connectConfig.URI)<br>response, err = Request(ctx, requestURL, connectConfig, callBack)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> response, <span class="hljs-literal">nil</span><br>&#125;<br><br>server.SetDownNode(appConfig.GetHost(), host)<br><br><span class="hljs-keyword">if</span> errors.Is(err, perror.ErrUnauthorized) ||<br>errors.Is(err, perror.ErrOverMaxRetryTimes) ||<br>errors.Is(err, perror.ErrNotFound) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><h2 id="2-短暂内存泄露"><a href="#2-短暂内存泄露" class="headerlink" title="2. 短暂内存泄露"></a>2. 短暂内存泄露</h2><h3 id="2-1-分析"><a href="#2-1-分析" class="headerlink" title="2.1. 分析"></a>2.1. 分析</h3><p>在Request()方法中，在for的代码块直接使用defer；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Request 建立网络请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Request</span><span class="hljs-params">(requestURL <span class="hljs-type">string</span>, connectionConfig *env.ConnectConfig, callBack *CallBack)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>client := &amp;http.Client&#123;&#125;<br>......<br><span class="hljs-keyword">for</span> &#123;<br><br>retry++<br><br><span class="hljs-keyword">if</span> retry &gt; retries &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">var</span> req *http.Request<br>req, err = http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, requestURL, <span class="hljs-literal">nil</span>)<br>......<br><br><span class="hljs-keyword">var</span> res *http.Response<br>res, err = client.Do(req)<br><span class="hljs-keyword">if</span> res != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">defer</span> res.Body.Close()  <span class="hljs-comment">// &lt;--在for代码块中使用defer</span><br>&#125;<br><br>......<br>    &#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这处如果遇到反复重试的极端情况，在重试次数达到上限时，res.Body的资源才被释放，中间过程会出现资源堆积；</p><h3 id="2-3-魔改"><a href="#2-3-魔改" class="headerlink" title="2.3. 魔改"></a>2.3. 魔改</h3><p>将 <strong>res, err &#x3D; client.Do(req)</strong> 的后续逻辑移动到一个func块中，在func块中使用defer，使res.Body能及时被回收。</p><p>​    </p><h2 id="3-长轮询接口返回401"><a href="#3-长轮询接口返回401" class="headerlink" title="3. 长轮询接口返回401"></a>3. 长轮询接口返回401</h2><h3 id="3-1-现象"><a href="#3-1-现象" class="headerlink" title="3.1. 现象"></a>3.1. 现象</h3><p>长轮询接口~60秒返回，并没有返回304，而返回了401；打印大量error日志；</p><p>​    </p><h3 id="3-2-分析"><a href="#3-2-分析" class="headerlink" title="3.2. 分析"></a>3.2. 分析</h3><p><a href="#3652">#3652</a> 这个issue中已经列举了很多种情况，我遇到的情况与klboke这位老哥相同</p><p><img src="klboke.png"></p><p>但ingress的配置不是说改运维就会改呀~ </p><p>毕竟还牵扯到其他业务，所以决定魔改代码来兼容一下这种情况~</p><p>​    </p><h3 id="3-3-魔改"><a href="#3-3-魔改" class="headerlink" title="3.3. 魔改"></a>3.3. 魔改</h3><p>在http-status-code &#x3D; 401，且是长轮询接口请求时，也走304的逻辑；</p><p>尽管这不是优雅的实现，但为了尽量不过多改动核心逻辑，先以满足需求优先。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">case</span> http.StatusNotModified:<br>log.Debugf(<span class="hljs-string">&quot;config not modified, err: %v&quot;</span>, err)<br><span class="hljs-keyword">if</span> callBack != <span class="hljs-literal">nil</span> &amp;&amp; callBack.NotModifyCallBack != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, callBack.NotModifyCallBack()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> http.StatusUnauthorized:<br><span class="hljs-comment">// https://github.com/apolloconfig/apollo/issues/3652</span><br><span class="hljs-comment">// During the long polling process, if the client is not directly connected to ApolloService</span><br><span class="hljs-comment">// and passes through a gateway in the middle, it is likely to return http-status-code: 401.</span><br><span class="hljs-comment">// Because the request timeout time set by the gateway is shorter than the suspension time</span><br><span class="hljs-comment">// of apollo Notifications-API, the request is disconnected on the gateway side and retried.</span><br><span class="hljs-comment">// At this time, the request time has been refreshed and does not match the signature of the</span><br><span class="hljs-comment">// original request, which eventually causes apolloService to return 401.</span><br><span class="hljs-comment">// Although this is not an elegant way, it is safest to handle it here for the time being.</span><br><span class="hljs-keyword">if</span> strings.Contains(requestURL, <span class="hljs-string">&quot;notifications/v2&quot;</span>) &#123;<br>log.Debugf(<span class="hljs-string">&quot;config not modified, err: %v&quot;</span>, err)<br><span class="hljs-keyword">if</span> callBack != <span class="hljs-literal">nil</span> &amp;&amp; callBack.NotModifyCallBack != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, callBack.NotModifyCallBack()<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perror.ErrUnauthorized<br><span class="hljs-keyword">case</span> http.StatusNotFound:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, perror.ErrNotFound<br></code></pre></td></tr></table></figure><p>​    </p><h2 id="4-动态增加指定namespace配置缓存及监听变动"><a href="#4-动态增加指定namespace配置缓存及监听变动" class="headerlink" title="4. 动态增加指定namespace配置缓存及监听变动"></a>4. 动态增加指定namespace配置缓存及监听变动</h2><p>由于业务上需要一个不停服动态增加指定namespace配置的能力，而原版的v4.3.1版本只能在启动时读取配置项中已预置的namespace组，于是考虑不需要运维介入的情况下实现这个功能。</p><p>当然最妥善的方式当然是在启动配置中预置所需的namespace组，待下一次读取配置时可以在初始化过程及时拉取对应配置。</p><p>​    </p><h3 id="4-1-分析"><a href="#4-1-分析" class="headerlink" title="4.1. 分析"></a>4.1. 分析</h3><p>看原库v4.3.1代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//GetConfig 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *internalClient)</span></span> GetConfig(namespace <span class="hljs-type">string</span>) *storage.Config &#123;<br><span class="hljs-keyword">return</span> c.GetConfigAndInit(namespace)<br>&#125;<br><br><span class="hljs-comment">//GetConfigAndInit 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *internalClient)</span></span> GetConfigAndInit(namespace <span class="hljs-type">string</span>) *storage.Config &#123;<br><span class="hljs-keyword">if</span> namespace == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>config := c.cache.GetConfig(namespace)<br><br><span class="hljs-keyword">if</span> config == <span class="hljs-literal">nil</span> &#123;  <span class="hljs-comment">// &lt;--注意看这个代码块的逻辑</span><br><span class="hljs-comment">//init cache</span><br>storage.CreateNamespaceConfig(namespace)<br><br><span class="hljs-comment">//sync config</span><br>syncApolloConfig.SyncWithNamespace(namespace, c.getAppConfig)<br>&#125;<br><br>config = c.cache.GetConfig(namespace)<br><br><span class="hljs-keyword">return</span> config<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>GetConfigAndInit()</strong> 中有涉及到貌似增量加载namespace缓存的逻辑</p><p>来看看 <strong>storage.CreateNamespaceConfig(namespace)</strong> 和 <strong>syncApolloConfig.SyncWithNamespace(namespace, c.getAppConfig)</strong> 中做了什么</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CreateNamespaceConfig 根据namespace初始化agollo内容配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CreateNamespaceConfig</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>)</span></span> *Cache &#123;<br><span class="hljs-comment">// config from apollo</span><br><span class="hljs-keyword">var</span> apolloConfigCache sync.Map<br>config.SplitNamespaces(namespace, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, ok := apolloConfigCache.Load(namespace); ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>c := initConfig(namespace, extension.GetCacheFactory())<br>apolloConfigCache.Store(namespace, c)<br>&#125;)<br><span class="hljs-keyword">return</span> &amp;Cache&#123;<br>apolloConfigCache: apolloConfigCache,<br>changeListeners:   list.New(),<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initConfig</span><span class="hljs-params">(namespace <span class="hljs-type">string</span>, factory agcache.CacheFactory)</span></span> *Config &#123;<br>c := &amp;Config&#123;<br>namespace: namespace,<br>cache:     factory.Create(),<br>&#125;<br>c.isInit.Store(<span class="hljs-literal">false</span>)<br>c.waitInit.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>看这里会为新的namespace创建一个专属的 <strong>Cache</strong> 对象，并返回到外部；</p><p>而 <strong>SyncWithNamespace()</strong> 在上文2.1中分析过，内部是请求了 <strong>configfiles&#x2F;json</strong> 接口获取该namespace下所有配置信息，并返回 *<strong>config.ApolloConfig</strong> 对象；</p><p>但奇怪的是外部的 <strong>GetConfigAndInit()</strong> 方法没有接收上述2个方法的返回对象，有点不可思议；</p><p>​    </p><p>从 GetConfigAndInit 来看配置存储于<strong>c.cache</strong> 这个变量中，那么 Cache 的数据结构支持存储多个namespace的映射关系吗？</p><p>来看 <strong>Cache</strong> 的数据结构，和如何 set&#x2F;get</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cache apollo 配置缓存</span><br><span class="hljs-keyword">type</span> Cache <span class="hljs-keyword">struct</span> &#123;<br>apolloConfigCache *sync.Map<br>changeListeners   *list.List<br>rw                sync.RWMutex <span class="hljs-comment">// listener locker</span><br>&#125;<br><br><span class="hljs-comment">// GetConfig 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> GetConfig(namespace <span class="hljs-type">string</span>) *Config &#123;<br><span class="hljs-keyword">if</span> namespace == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>config, ok := c.apolloConfigCache.Load(namespace)<br><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">return</span> config.(*Config)<br>&#125;<br><br><span class="hljs-comment">// UpdateApolloConfigCache 根据conf[ig server返回的内容更新内存</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> UpdateApolloConfigCache(configurations <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, expireTime <span class="hljs-type">int</span>, namespace <span class="hljs-type">string</span>) <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*ConfigChange &#123;<br>config := c.GetConfig(namespace)<br><span class="hljs-keyword">if</span> config == <span class="hljs-literal">nil</span> &#123;<br>config = initConfig(namespace, extension.GetCacheFactory())<br>c.apolloConfigCache.Store(namespace, config)<br>&#125;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>看来 apolloConfigCache 可以存储多个namespace对应的配置树，而且找到了set方法的触发方式 <strong>UpdateApolloConfigCache()</strong> ；</p><p>​    </p><p>顺藤摸瓜，来到 <strong>UpdateApolloConfig()</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// UpdateApolloConfig 根据config server返回的内容更新内存</span><br><span class="hljs-comment">// 并判断是否需要写备份文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cache)</span></span> UpdateApolloConfig(apolloConfig *config.ApolloConfig, appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig) &#123;<br><span class="hljs-keyword">if</span> apolloConfig == <span class="hljs-literal">nil</span> &#123;<br>log.Error(<span class="hljs-string">&quot;apolloConfig is null, can&#x27;t update!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>appConfig := appConfigFunc()<br><span class="hljs-comment">// update apollo connection config</span><br>appConfig.SetCurrentApolloConfig(&amp;apolloConfig.ApolloConnConfig)<br><br><span class="hljs-comment">// get change list</span><br>changeList := c.UpdateApolloConfigCache(apolloConfig.Configurations, configCacheExpireTime, apolloConfig.NamespaceName)<br><br>notify := appConfig.GetNotificationsMap().GetNotify(apolloConfig.NamespaceName)<br><br><span class="hljs-comment">// push all newest changes</span><br>c.pushNewestChanges(apolloConfig.NamespaceName, apolloConfig.Configurations, notify)<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(changeList) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">// create config change event base on change list</span><br>event := createConfigChangeEvent(changeList, apolloConfig.NamespaceName, notify)<br><br><span class="hljs-comment">// push change event to channel</span><br>c.pushChangeEvent(event)<br>&#125;<br><br><span class="hljs-keyword">if</span> appConfig.GetIsBackupConfig() &#123;<br><span class="hljs-comment">// write config file async</span><br>apolloConfig.AppID = appConfig.AppID<br><span class="hljs-keyword">go</span> extension.GetFileHandler().WriteConfigFile(apolloConfig, appConfig.GetBackupConfigPath())<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段逻辑中已经把 <code>获取当前连接--&gt;更新配置缓存--&gt;异步通知配置变更--&gt;异步备份配置信息成本地文件</code> 这条链完整实现了，于是只需要调用这个方法即可将 <strong>SyncWithNamespace()</strong> 得到的新增配置set到 <strong>Cache</strong> 中；</p><p>​    </p><p>但还剩一个问题，监听Apollo配置更新需要依赖长轮询，即依赖这段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Start 启动配置组件定时器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ConfigComponent)</span></span> Start() &#123;<br><span class="hljs-keyword">if</span> c.stopCh == <span class="hljs-literal">nil</span> &#123;<br>c.stopCh = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>&#125;<br><br>t2 := time.NewTimer(longPollInterval)<br>instance := remote.CreateAsyncApolloConfig()<br><span class="hljs-comment">//long poll for sync</span><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-t2.C:<br>configs := instance.Sync(c.appConfigFunc)  <span class="hljs-comment">// 请求notifications/v2接口，挂起等待apollo应答</span><br><span class="hljs-keyword">for</span> _, apolloConfig := <span class="hljs-keyword">range</span> configs &#123;<br>c.cache.UpdateApolloConfig(apolloConfig, c.appConfigFunc)  <span class="hljs-comment">// 将新配置刷新到内存本地缓存中</span><br>&#125;<br>t2.Reset(longPollInterval)<br><span class="hljs-keyword">case</span> &lt;-c.stopCh:<br><span class="hljs-keyword">break</span> loop<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p>那么问题来了~</p><p><strong>【问题1】</strong>如何通知这个方法获取<strong>新增namespace</strong>的连接信息呢？</p><p><strong>【问题2】</strong>这个方法是堵塞式长轮询，如何<strong>重启</strong>长轮询来触发订阅新namespace的变动呢？</p><p>​    </p><p>我们先解决<strong>【问题1】</strong>，看 <strong>instance.Sync(c.appConfigFunc)</strong> 的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *asyncApolloConfig)</span></span> Sync(appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig) []*config.ApolloConfig &#123;<br>appConfig := appConfigFunc()<br>remoteConfigs, err := a.notifyRemoteConfig(appConfigFunc, utils.Empty)  <span class="hljs-comment">// 获取需要更新的远程配置</span><br><br><span class="hljs-keyword">var</span> apolloConfigs []*config.ApolloConfig<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>apolloConfigs = loadBackupConfig(appConfig.NamespaceName, appConfig)<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(remoteConfigs) == <span class="hljs-number">0</span> || <span class="hljs-built_in">len</span>(apolloConfigs) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> apolloConfigs<br>&#125;<br><span class="hljs-comment">//只是拉去有变化的配置, 并更新拉取成功的namespace的notify ID</span><br><span class="hljs-keyword">for</span> _, notifyConfig := <span class="hljs-keyword">range</span> remoteConfigs &#123;<br>apolloConfig := a.SyncWithNamespace(notifyConfig.NamespaceName, appConfigFunc)<br><span class="hljs-keyword">if</span> apolloConfig != <span class="hljs-literal">nil</span> &#123;<br>appConfig.GetNotificationsMap().UpdateNotify(notifyConfig.NamespaceName, notifyConfig.NotificationID)<br>apolloConfigs = <span class="hljs-built_in">append</span>(apolloConfigs, apolloConfig)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> apolloConfigs<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *asyncApolloConfig)</span></span> notifyRemoteConfig(appConfigFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> config.AppConfig, namespace <span class="hljs-type">string</span>) ([]*config.Notification, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> appConfigFunc == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;can not find apollo config!please confirm!&quot;</span>)<br>&#125;<br>appConfig := appConfigFunc()<br>notificationsMap := appConfig.GetNotificationsMap()  <span class="hljs-comment">// 获取所有需要长轮询的namespace配置</span><br>urlSuffix := a.GetNotifyURLSuffix(notificationsMap.GetNotifies(namespace), appConfig)<br><br>connectConfig := &amp;env.ConnectConfig&#123;<br>URI:    urlSuffix,<br>AppID:  appConfig.AppID,<br>Secret: appConfig.Secret,<br>&#125;<br>connectConfig.Timeout = notifyConnectTimeout<br>notifies, err := http.RequestRecovery(appConfig, connectConfig, &amp;http.CallBack&#123;<br>SuccessCallBack: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(responseBody []<span class="hljs-type">byte</span>, callback http.CallBack)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> toApolloConfig(responseBody)<br>&#125;,<br>NotModifyCallBack: touchApolloConfigCache,<br>Namespace:         namespace,<br>&#125;)<br><br><span class="hljs-keyword">if</span> notifies == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">return</span> notifies.([]*config.Notification), err<br>&#125;<br><br><span class="hljs-comment">// .....</span><br><span class="hljs-comment">// GetNotificationsMap 获取notificationsMap</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *AppConfig)</span></span> GetNotificationsMap() *notificationsMap &#123;<br><span class="hljs-keyword">return</span> a.notificationsMap<br>&#125;<br><br><span class="hljs-comment">// map[string]int64</span><br><span class="hljs-keyword">type</span> notificationsMap <span class="hljs-keyword">struct</span> &#123;<br>notifications sync.Map<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码可以知道，只需要将新增的 <strong>namespace</strong> set入notifications即可~</p><p>然后没找到现成的方法，但是可以加嘛~</p><p>​    </p><p><strong>【问题2】</strong>其实很好解决，比较粗暴就是中断当前的请求，且获取新的namespaceMaps后重新发起长轮询请求，可以通过<strong>context.Context</strong>实现，当然代码里面也没有传递上下文，但是可以加嘛~</p><p>​    </p><p>虽然但是，其实距离实现我的需求只剩 <strong>四步之遥</strong>：</p><p><strong>【步骤1】</strong>获取新增namespace的所有配置信息</p><p><strong>【步骤2】</strong>把新增namespace加入到notificationMap</p><p><strong>【步骤3】</strong>重启长轮询，使得能够监听新增namespace的配置变动</p><p><strong>【步骤4】</strong>将新增namespace的配置存储到本地缓存</p><p>​    </p><h3 id="4-2-魔改"><a href="#4-2-魔改" class="headerlink" title="4.2. 魔改"></a>4.2. 魔改</h3><p>综合上述四个步骤，<strong>GetConfigAndInit()</strong> 的改动如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// GetConfigAndInit 根据namespace获取apollo配置</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *internalClient)</span></span> GetConfigAndInit(namespace <span class="hljs-type">string</span>) *storage.Config &#123;<br><span class="hljs-keyword">if</span> namespace == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>conf := c.cache.GetConfig(namespace)<br><span class="hljs-keyword">if</span> conf == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// sync config</span><br>apolloConfig := syncApolloConfig.SyncWithNamespace(context.Background(), namespace, c.getAppConfig)<br><span class="hljs-keyword">if</span> apolloConfig != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// trigger restart long polling, used to monitor changes in new namespaces</span><br>c.appConfig.GetNotificationsMap().AddNamespace(apolloConfig.NamespaceName)<br>c.changeMonitor.Stop()<br><span class="hljs-keyword">go</span> c.changeMonitor.Start()<br><span class="hljs-comment">// refresh cache</span><br>c.cache.UpdateApolloConfig(apolloConfig, c.getAppConfig)<br><span class="hljs-comment">// fetch config from cache again</span><br>conf = c.cache.GetConfig(namespace)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> conf<br>&#125;<br></code></pre></td></tr></table></figure><p>具体方法的内部修改可以看 <a href="https://github.com/lamber92/agollo">lamber92&#x2F;agollo</a> v4.3.2版本代码~</p><p>​    </p><h2 id="相关Issues"><a href="#相关Issues" class="headerlink" title="相关Issues"></a>相关Issues</h2><h3 id="1270-配置地址变成了服务器的内网ip"><a href="#1270-配置地址变成了服务器的内网ip" class="headerlink" title="#1270 配置地址变成了服务器的内网ip"></a><a id="1270">#1270 配置地址变成了服务器的内网ip</a></h3><p><a href="https://github.com/apolloconfig/apollo/issues/1270">https://github.com/apolloconfig/apollo/issues/1270</a></p><p>先说现象：</p><p><strong>services&#x2F;config</strong> 接口返回的是<strong>内网域名(或IP地址)</strong></p><p>如果使用Agollo配置时IP填写了外网IP或者不是内网域名，会导致访问 Apollo-Meta-Service 失败，反复输出ERROR日志，具有一定的迷惑性；</p><p>​    </p><p>解析原因：</p><p>看原库v4.3.1代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//RequestRecovery 可以恢复的请求</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RequestRecovery</span><span class="hljs-params">(appConfig config.AppConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">connectConfig *env.ConnectConfig,</span></span><br><span class="hljs-params"><span class="hljs-function">callBack *CallBack)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>format := <span class="hljs-string">&quot;%s%s&quot;</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">var</span> response <span class="hljs-keyword">interface</span>&#123;&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>host := loadBalance(appConfig)<br><span class="hljs-keyword">if</span> host == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br>requestURL := fmt.Sprintf(format, host, connectConfig.URI)<br>response, err = Request(requestURL, connectConfig, callBack)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> response, <span class="hljs-literal">nil</span><br>&#125;<br><br>server.SetDownNode(appConfig.GetHost(), host)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadBalance</span><span class="hljs-params">(appConfig config.AppConfig)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> !server.IsConnectDirectly(appConfig.GetHost()) &#123;<br><span class="hljs-keyword">return</span> appConfig.GetHost()<br>&#125;<br>serverInfo := extension.GetLoadBalance().Load(server.GetServers(appConfig.GetHost()))<br><span class="hljs-keyword">if</span> serverInfo == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> utils.Empty<br>&#125;<br><br><span class="hljs-keyword">return</span> serverInfo.HomepageURL<br>&#125;<br></code></pre></td></tr></table></figure><p>在<strong>loadBalance</strong>逻辑中，当直连请求失败时（使用配置中的IP作为Domain请求失败），在会<strong>server.SetDownNode()</strong> 中会设置一个再次尝试的周期(30秒)，使得下一次请求不再使用配置的IP，而用 <strong>serverInfo.HomepageURL（Apollo-Meta-Service-URL）</strong> 代替 <strong>IP</strong>；</p><p>这时候 HomepageURL 记录的是**内网域名(或IP)**，如果Client和Apollo-Meta-Service间没有打通网络，会导致进一步失败；</p><p>在 <strong>Request(requestURL, connectConfig, callBack)</strong> 方法内部，默认有5次重试，会一直输出ERROR日志，有一定的误导性；</p><p>最后走到 **server.SetDownNode(appConfig.GetHost(), host)**，摘除这个Apollo-Meta-Service节点URL；</p><p>如果最终没有可用的Apollo-Meta-Service-URL，将直接退出循环；</p><p>等30秒后，由componet_notify.go发起的长轮询会再次使用配置中的 Host 直连Apollo-Config-Service请求。</p><p>​    </p><h3 id="3652-长轮询报-Invalid-timestamp"><a href="#3652-长轮询报-Invalid-timestamp" class="headerlink" title="#3652 长轮询报 Invalid timestamp"></a><a id="3652">#3652 长轮询报 Invalid timestamp</a></h3><p><a href="https://github.com/apolloconfig/apollo/issues/3652">https://github.com/apolloconfig/apollo/issues/3652</a></p><p>结合通过长轮询接口实现 <a href="https://www.apolloconfig.com/#/zh/design/apollo-design?id=_212-config-service%E9%80%9A%E7%9F%A5%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F">Config Service通知客户端的实现方式</a> 逻辑，得知ApolloConfig-Service接收到请求后会挂起，期间有配置变更则会立即响应客户端请求，否则超时后返回304错误码。</p><p>我的定位流程大致与这篇文章相似，只是我的Agollo与Apollo-Config-Service之间隔了一层k8s-ingress，过程的抓包结果比较敏感就不截取了，分析过程可以借鉴这位博主的文章：</p><p><a href="https://blog.csdn.net/li281037846/article/details/122421089">记一次诡异的Apollo Long polling failed 401问题</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>apollo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决Hexo问题记录</title>
    <link href="/2023/04/05/hexo/hexo/"/>
    <url>/2023/04/05/hexo/hexo/</url>
    
    <content type="html"><![CDATA[<h1 id="解决Hexo问题记录"><a href="#解决Hexo问题记录" class="headerlink" title="解决Hexo问题记录"></a>解决Hexo问题记录</h1><p align="right">Lamber</p><p align="right">2023-04-05</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>hexo版本信息</p><blockquote><p>λ hexo -v<br>INFO  Validating config<br>hexo: 6.3.0<br>hexo-cli: 4.3.0<br>os: win32 10.0.19045<br>node: 18.14.2<br>v8: 10.2.154.26-node.22<br>uv: 1.44.2<br>zlib: 1.2.13<br>brotli: 1.0.9<br>ares: 1.18.1<br>modules: 108<br>nghttp2: 1.51.0<br>napi: 8<br>llhttp: 6.0.10<br>uvwasi: 0.0.14<br>acorn: 8.8.1<br>simdutf: 3.1.0<br>undici: 5.20.0<br>openssl: 3.0.8+quic<br>cldr: 42.0<br>icu: 72.1<br>tz: 2022g<br>unicode: 15.0<br>ngtcp2: 0.8.1<br>nghttp3: 0.7.0             </p></blockquote><h1 id="1-部署提示”Cannot-find-module-‘-x2F-db-json’”"><a href="#1-部署提示”Cannot-find-module-‘-x2F-db-json’”" class="headerlink" title="1. 部署提示”Cannot find module ‘.&#x2F;db.json’”"></a>1. 部署提示”Cannot find module ‘.&#x2F;db.json’”</h1><p>运行 <code>hexo g</code> 报错如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs shell">INFO  Validating config<br>ERROR Plugin load failed: hexo-server<br>Error: Cannot find module &#x27;./db.json&#x27;<br>Require stack:<br>- F:\blog\hexo-blog\node_modules\mime-db\index.js<br>- F:\blog\hexo-blog\node_modules\mime-types\index.js<br>- F:\blog\hexo-blog\node_modules\accepts\index.js<br>- F:\blog\hexo-blog\node_modules\compression\index.js<br>- F:\blog\hexo-blog\node_modules\hexo-server\lib\middlewares\gzip.js<br>- F:\blog\hexo-blog\node_modules\hexo-server\index.js<br>    at Module._resolveFilename (node:internal/modules/cjs/loader:1075:15)<br>    at Module._load (node:internal/modules/cjs/loader:920:27)<br>    at Module.require (node:internal/modules/cjs/loader:1141:19)<br>    at require (node:internal/modules/cjs/helpers:110:18)<br>    at Object.&lt;anonymous&gt; (F:\blog\hexo-blog\node_modules\mime-db\index.js:12:18)<br>    at Module._compile (node:internal/modules/cjs/loader:1254:14)<br>    at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)<br>    at Module.load (node:internal/modules/cjs/loader:1117:32)<br>    at Module._load (node:internal/modules/cjs/loader:958:12)<br>    at Module.require (node:internal/modules/cjs/loader:1141:19)<br>    at require (node:internal/modules/cjs/helpers:110:18)<br>    at Object.&lt;anonymous&gt; (F:\blog\hexo-blog\node_modules\mime-types\index.js:15:10)<br>    at Module._compile (node:internal/modules/cjs/loader:1254:14)<br>    at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)<br>    at Module.load (node:internal/modules/cjs/loader:1117:32)<br>    at Module._load (node:internal/modules/cjs/loader:958:12)<br>    at Module.require (node:internal/modules/cjs/loader:1141:19)<br>    at require (node:internal/modules/cjs/helpers:110:18)<br>    at Object.&lt;anonymous&gt; (F:\blog\hexo-blog\node_modules\accepts\index.js:16:12)<br>    at Module._compile (node:internal/modules/cjs/loader:1254:14)<br>    at Module._extensions..js (node:internal/modules/cjs/loader:1308:10)<br>    at Module.load (node:internal/modules/cjs/loader:1117:32)<br></code></pre></td></tr></table></figure><p>我的本地项目在 <code>F:\blog\hexo-blog\node_modules\</code> 路径下，解决步骤如下：</p><ol><li>删除这个路径下 <code>mime-db</code> 、 <code>hexo-server</code> 两个目录</li><li>重新下载这两个依赖包 <code>npm install</code></li><li>重新执行 <code>hexo g</code> 成功不报错</li></ol><h1 id="2-MD文件插入图片使用-“-”-方式，hexo生成HTML后路径不正确"><a href="#2-MD文件插入图片使用-“-”-方式，hexo生成HTML后路径不正确" class="headerlink" title="2. MD文件插入图片使用 “[]()” 方式，hexo生成HTML后路径不正确"></a>2. MD文件插入图片使用 “[]()” 方式，hexo生成HTML后路径不正确</h1><p>修改 <code>node_modules\hexo-renderer-marked\lib\renderer.js</code> 文件</p><p>在 <code>image(href, title, text)</code> 方法的中部加入如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Prepend root to image path</span><br><span class="hljs-title function_">image</span>(<span class="hljs-params">href, title, text</span>) &#123;<br>    <span class="hljs-keyword">const</span> &#123; hexo, options &#125; = <span class="hljs-variable language_">this</span>;<br>    <span class="hljs-keyword">const</span> &#123; relative_link &#125; = hexo.<span class="hljs-property">config</span>;<br>    <span class="hljs-keyword">const</span> &#123; lazyload, prependRoot, postPath &#125; = options;<br><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-regexp">/^(#|\/\/|http(s)?:)/</span>.<span class="hljs-title function_">test</span>(href) &amp;&amp; !relative_link &amp;&amp; prependRoot) &#123;<br>        <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;/&#x27;</span>) &amp;&amp; !href.<span class="hljs-title function_">startsWith</span>(<span class="hljs-string">&#x27;\\&#x27;</span>) &amp;&amp; postPath) &#123;<br>            <span class="hljs-keyword">const</span> <span class="hljs-title class_">PostAsset</span> = hexo.<span class="hljs-title function_">model</span>(<span class="hljs-string">&#x27;PostAsset&#x27;</span>);<br>            <span class="hljs-comment">// findById requires forward slash</span><br>            <span class="hljs-keyword">const</span> asset = <span class="hljs-title class_">PostAsset</span>.<span class="hljs-title function_">findById</span>(<span class="hljs-title function_">join</span>(postPath, href.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>)));<br>            <span class="hljs-comment">// asset.path is backward slash in Windows</span><br>            <span class="hljs-keyword">if</span> (asset) href = asset.<span class="hljs-property">path</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>        &#125;<br>        href = url_for.<span class="hljs-title function_">call</span>(hexo, href);<br>    &#125;<br><br>    <span class="hljs-comment">// 加入这段代码===========================================</span><br>    <span class="hljs-comment">// 如果第一个符号是&#x27;/&#x27;,切掉</span><br>    <span class="hljs-keyword">if</span> (href.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; href[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;/&#x27;</span>) &#123;<br>        href = href.<span class="hljs-title function_">substring</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果字符串不包含子串&#x27;http&#x27;,且包含&#x27;/&#x27;字符,截取&#x27;/&#x27;字符后的子串</span><br>    <span class="hljs-keyword">if</span> (!href.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;://&#x27;</span>) &amp;&amp; href.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> index = href.<span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>        href = href.<span class="hljs-title function_">substring</span>(index + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 加入这段代码===========================================</span><br><br>    <span class="hljs-keyword">let</span> out = <span class="hljs-string">`&lt;img src=&quot;<span class="hljs-subst">$&#123;encodeURL(href)&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">if</span> (text) out += <span class="hljs-string">` alt=&quot;<span class="hljs-subst">$&#123;text&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">if</span> (title) out += <span class="hljs-string">` title=&quot;<span class="hljs-subst">$&#123;title&#125;</span>&quot;`</span>;<br>    <span class="hljs-keyword">if</span> (lazyload) out += <span class="hljs-string">&#x27; loading=&quot;lazy&quot;&#x27;</span>;<br><br>    out += <span class="hljs-string">&#x27;&gt;&#x27;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br></code></pre></td></tr></table></figure><p>重新执行 <code>hexo g</code> –&gt; <code>hexo s</code></p>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ使用记录</title>
    <link href="/2023/04/05/rabbitmq/rabbitmq/"/>
    <url>/2023/04/05/rabbitmq/rabbitmq/</url>
    
    <content type="html"><![CDATA[<h1 id="RabbitMQ使用记录"><a href="#RabbitMQ使用记录" class="headerlink" title="RabbitMQ使用记录"></a>RabbitMQ使用记录</h1><p align="right">Lamber</p><p align="right">2023-04-05</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>1. RabbitMQ与AMQP的关系：</strong></p><ul><li><p>RabbitMQ 是实现了 AMQP 协议的一种消息队列软件。它作为 AMQP 协议的一个实现，提供了可靠的消息传递机制，用于在分布式系统中传递和处理消息。</p><ul><li>RabbitMQ 仅实现了 <a href="https://www.rabbitmq.com/specification.html">AMQP 0-9-1 版本</a>。</li><li><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 是与 RabbitMQ 兼容的协议版本，而不是 AMQP 规范的官方版本</a>。</li></ul></li><li><p>AMQP 定义了一种消息传递的标准协议，包括了消息的格式、交换机（Exchange）和队列（Queue）的操作规范，以及消息的确认机制、事务机制等。RabbitMQ 遵循了 AMQP 协议的规范，实现了这些功能。</p></li><li><p>RabbitMQ 提供了丰富的功能，如消息持久化、消息路由、消息过滤、消息优先级、发布&#x2F;订阅模式、RPC（Remote Procedure Call，远程过程调用）等，这些功能都是基于 AMQP 协议的规范实现的。</p></li></ul><p><strong>2. 选择好RabbitMQ的消息传递模式，是正确使用RabbitMQ解决实际问题的前提。</strong></p><ul><li><p><strong>Direct模式：</strong></p><p>生产者将消息发送到指定的队列，并且消费者只会从指定的队列接收消息。消息的路由键（routing key）与队列的绑定键（binding key）完全匹配时，消息才会被发送到对应的队列。这种模式适合于一对一的消息通信，例如系统间的点对点通信。常见的使用场景包括日志记录、任务分发等。</p></li><li><p><strong>Fanout模式：</strong></p><p>生产者将消息发送到一个交换机，而交换机会将消息广播给所有绑定到它上面的队列。消费者可以同时订阅多个队列，从而接收到相同的消息。Fanout模式适合于广播通信，例如系统内的通知、事件广播等。</p></li><li><p><strong>Topic模式：</strong></p><p>生产者将消息发送到一个交换机（exchange），而不是直接发送到队列。交换机会根据消息的路由键将消息发送到多个队列，而消费者可以根据队列的绑定键（binding key）来订阅消息。<strong>Topic模式支持通配符的匹配，可以根据路由键的模式匹配多个队列。</strong>这种模式适合于发布和订阅模型，允许生产者发送广播消息，同时允许消费者选择订阅自己感兴趣的消息。常见的使用场景包括新闻订阅、社交网络等。</p></li></ul><p><strong>3. 下文中的RabbitMQ-Go代码示例均使用”<a href="https://github.com/rabbitmq/amqp091-go%22%E5%8C%85">https://github.com/rabbitmq/amqp091-go&quot;包</a></strong></p><h2 id="场景-amp-方案"><a href="#场景-amp-方案" class="headerlink" title="场景&amp;方案"></a>场景&amp;方案</h2><h3 id="1-保证消息顺序消费，且保证数据最终一致性"><a href="#1-保证消息顺序消费，且保证数据最终一致性" class="headerlink" title="1. 保证消息顺序消费，且保证数据最终一致性"></a>1. 保证消息顺序消费，且保证数据最终一致性</h3><p>这种场景的典型例子是不同数据库间表数据的增量同步。</p><h4 id="1-1-功能配置"><a href="#1-1-功能配置" class="headerlink" title="1.1. 功能配置"></a><strong>1.1. 功能配置</strong></h4><ul><li>交换机模式：Direct</li><li>生产者：<ul><li>消息持久化</li><li>消息推送成功确认</li></ul></li><li>消费者：<ul><li>保证每个队列只有一个消费者（保证顺序）<ul><li>如果条件允许，或者消息量巨大，可以在生产者侧根据业务属性对消息分散投递到不同队列，每个队列对应一个消费者，并行消费。</li><li>比如10个队列同步user表数据，只要确保相同user_id的消息投递到同一队列，就能保证这个user_id的数据按顺序消费。将user_id对10取模，投递到对应序号的队列即可。</li></ul></li><li>设置Qos.PrefetchCount &#x3D; 1，保证消息每次从队列重新获取，避免消费失败后，获取的消息是预获取缓冲区内消息，导致乱序<ul><li>如果消费者侧可以保证消息消费幂等性，或有消息消费顺序保护策略，可加大PrefetchCount值。</li></ul></li><li>消费成功时手动 Ack</li><li>消费失败时手动 Nack，并且requeue&#x3D;true，使得消息能重回队首重新消费，否则消息将进入死信队列</li></ul></li></ul><h4 id="1-2-代码示例"><a href="#1-2-代码示例" class="headerlink" title="1.2. 代码示例"></a><strong>1.2. 代码示例</strong></h4><ul><li><strong>消费者</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go/amqp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RabbitMQ 服务器</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法连接到 RabbitMQ 服务器：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 创建一个通道</span><br>ch, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法创建 RabbitMQ 通道：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 声明一个 Direct 类型的交换机</span><br>err = ch.ExchangeDeclare(<br><span class="hljs-string">&quot;direct_exchange&quot;</span>, <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-string">&quot;direct&quot;</span>,           <span class="hljs-comment">// 交换机类型</span><br><span class="hljs-literal">true</span>,               <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否自动删除</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否内部交换机</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否等待服务器响应</span><br><span class="hljs-literal">nil</span>,                <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法声明 Direct 交换机：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 声明一个队列</span><br>q, err := ch.QueueDeclare(<br><span class="hljs-string">&quot;direct_queue&quot;</span>, <span class="hljs-comment">// 队列名称</span><br><span class="hljs-literal">true</span>,           <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// 是否自动删除</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// 是否排他队列</span><br><span class="hljs-literal">false</span>,          <span class="hljs-comment">// 是否阻塞等待服务器响应</span><br><span class="hljs-literal">nil</span>,            <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法声明队列：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 将队列绑定到交换机，使用 &quot;direct_routing_key&quot; 作为路由键</span><br>err = ch.QueueBind(<br>q.Name,             <span class="hljs-comment">// 队列名称</span><br><span class="hljs-string">&quot;direct_routing_key&quot;</span>, <span class="hljs-comment">// 路由键</span><br><span class="hljs-string">&quot;direct_exchange&quot;</span>,   <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-literal">false</span>,               <span class="hljs-comment">// 是否等待服务器响应</span><br><span class="hljs-literal">nil</span>,                 <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法绑定队列到 Direct 交换机：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 消费消息</span><br>msgs, err := ch.Consume(<br>q.Name, <span class="hljs-comment">// 队列名称</span><br><span class="hljs-string">&quot;&quot;</span>,     <span class="hljs-comment">// 消费者标签，为空则由服务器自动生成</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否自动确认消息</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否排他消费者</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否阻塞等待服务器响应</span><br><span class="hljs-literal">false</span>,  <span class="hljs-comment">// 是否不等待服务器确认消费者创建完成</span><br><span class="hljs-literal">nil</span>,    <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法注册消费者：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 接收并处理消息</span><br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> msgs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;接收到消息：%s\n&quot;</span>, msg.Body)<br><span class="hljs-comment">// 手动确认消息已被消费</span><br>msg.Ack(<span class="hljs-literal">false</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>生产者</strong></li></ul><p>需要注意的是，需要推送消息成功确认，确保消息不丢失。</p><p>在这种模式下，如果不接受并处理已”确认回调信息”，那么推送消息的channel将会堵塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/signal&quot;</span><br><span class="hljs-string">&quot;syscall&quot;</span><br><br><span class="hljs-string">&quot;github.com/rabbitmq/amqp091-go/amqp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RabbitMQ 服务器</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法连接到 RabbitMQ 服务器：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 创建一个通道</span><br>ch, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法创建 RabbitMQ 通道：%v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch.Close()<br><br><span class="hljs-comment">// 启用消息推送确认模式</span><br><span class="hljs-keyword">if</span> err = ch.Confirm(<span class="hljs-literal">false</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法启用消息推送确认模式：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 注册消息推送确认回调函数</span><br>confirms := ch.NotifyPublish(<span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> amqp.Confirmation, <span class="hljs-number">1</span>))<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> confirmed := &lt;-confirms; !confirmed.Ack &#123;<br>log.Println(<span class="hljs-string">&quot;消息发送失败&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Println(<span class="hljs-string">&quot;消息发送成功&quot;</span>)<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// 声明一个 Direct 类型的交换机</span><br>err = ch.ExchangeDeclare(<br><span class="hljs-string">&quot;direct_exchange&quot;</span>, <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-string">&quot;direct&quot;</span>,           <span class="hljs-comment">// 交换机类型</span><br><span class="hljs-literal">true</span>,               <span class="hljs-comment">// 是否持久化</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否自动删除</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否内部交换机</span><br><span class="hljs-literal">false</span>,              <span class="hljs-comment">// 是否等待服务器响应</span><br><span class="hljs-literal">nil</span>,                <span class="hljs-comment">// 其他参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法声明 Direct 交换机：%v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 发布消息到 Direct 交换机</span><br>err = ch.Publish(<br><span class="hljs-string">&quot;direct_exchange&quot;</span>,   <span class="hljs-comment">// 交换机名称</span><br><span class="hljs-string">&quot;direct_routing_key&quot;</span>, <span class="hljs-comment">// 路由键</span><br><span class="hljs-literal">true</span>,                <span class="hljs-comment">// 是否强制发送（消息发送失败时会触发确认回调函数）</span><br><span class="hljs-literal">false</span>,               <span class="hljs-comment">// 是否立即发送</span><br>amqp.Publishing&#123;<br>ContentType: <span class="hljs-string">&quot;text/plain&quot;</span>,<br>Body:        []<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Hello, RabbitMQ!&quot;</span>),<br>&#125;, <span class="hljs-comment">// 消息内容</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;无法发布消息：%v&quot;</span>, err)<br>&#125;<br><br>fmt.Println(<span class="hljs-string">&quot;消息已成功发送&quot;</span>)<br><br><span class="hljs-comment">// 等待程序退出</span><br>waitForExit()<br>&#125;<br><br><span class="hljs-comment">// 等待程序退出的辅助函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">waitForExit</span><span class="hljs-params">()</span></span> &#123;<br>sigCh := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> os.Signal, <span class="hljs-number">1</span>)<br>signal.Notify(sigCh, syscall.SIGINT, syscall.SIGTERM)<br>&lt;-sigCh<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-不需要保证消费顺序，消息量巨大，允许部分消息消费失败"><a href="#2-不需要保证消费顺序，消息量巨大，允许部分消息消费失败" class="headerlink" title="2. 不需要保证消费顺序，消息量巨大，允许部分消息消费失败"></a>2. 不需要保证消费顺序，消息量巨大，允许部分消息消费失败</h3><p>这种场景的典型例子是热点数据异步更新到搜索引擎。比如电商商品促销活动，不定量的商品数据属性高频变动，导致在短时间内产生海量数据。</p><h4 id="2-1-功能配置"><a href="#2-1-功能配置" class="headerlink" title="2.1. 功能配置"></a><strong>2.1. 功能配置</strong></h4><ul><li>交换机模式：Direct<ul><li>如果需要多渠道通知，选择 Fanout</li><li>如果需要根据不同属性多渠道动态通知，选择 Topic</li></ul></li><li>生产者：<ul><li>消息持久化</li><li>消息推送不需要确认</li></ul></li><li>消费者：<ul><li>保证每个队列有多个消费者<ul><li>一个connect，创建多个channel，每个channel对应一个消费者<ul><li>如果使用 AutoAck 模式，可以一个channel创建多个consumer</li><li>每个consumer_tag尽量不同，方便cancel</li></ul></li></ul></li><li>设置Qos.PrefetchCount &#x3D; 100，尽可能多预取缓存，批量处理消息，增加消息消费速度</li><li>消费成功时手动 Ack，并且 multiple&#x3D;true，批量消费确认delivery_tag，delivery_tag是针对所属的channel的，对其他channel无影响<ul><li>条件更宽松时可以使用 AutoAck</li></ul></li><li>消费失败时手动 Nack，并且requeue&#x3D;false，使得消息能重回队首重新消费，否则消息将进入死信队列<ul><li>条件更宽松时可以消费失败也是用 Ack</li></ul></li></ul></li></ul><h4 id="2-2-代码示例"><a href="#2-2-代码示例" class="headerlink" title="2.2. 代码示例"></a><strong>2.2. 代码示例</strong></h4><ul><li><strong>消费者</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 连接 RabbitMQ 服务器</span><br>conn, err := amqp.Dial(<span class="hljs-string">&quot;amqp://guest:guest@localhost:5672/&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to connect to RabbitMQ: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-comment">// 创建 channel</span><br>ch1, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open channel: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch1.Close()<br><br>ch2, err := conn.Channel()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to open channel: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">defer</span> ch2.Close()<br><br><span class="hljs-comment">// 声明 exchange</span><br>err = ch1.ExchangeDeclare(<br><span class="hljs-string">&quot;test_exchange&quot;</span>, <span class="hljs-comment">// 名称</span><br><span class="hljs-string">&quot;direct&quot;</span>,        <span class="hljs-comment">// 类型</span><br><span class="hljs-literal">true</span>,            <span class="hljs-comment">// 持久化</span><br><span class="hljs-literal">false</span>,           <span class="hljs-comment">// 不自动删除</span><br><span class="hljs-literal">false</span>,           <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">false</span>,           <span class="hljs-comment">// 不等待 server 确认</span><br><span class="hljs-literal">nil</span>,             <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to declare exchange: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 声明队列</span><br>q, err := ch1.QueueDeclare(<br><span class="hljs-string">&quot;test_queue&quot;</span>,<br><span class="hljs-literal">true</span>,  <span class="hljs-comment">// 持久化</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 自动删除</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 独占</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">nil</span>,   <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to declare queue: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 绑定队列到 exchange 上</span><br><span class="hljs-keyword">if</span> err := ch1.QueueBind(q.Name, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;test_exchange&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to bind queue: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 绑定队列到两个 channel 上</span><br><span class="hljs-keyword">if</span> err := ch1.QueueBind(q.Name, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to bind queue: %v&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := ch2.QueueBind(q.Name, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to bind queue: %v&quot;</span>, err)<br>&#125;<br><br><span class="hljs-comment">// 创建两个 consumer</span><br>consumer1, err := ch1.Consume(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不自动应答</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 独占</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待 server 确认</span><br><span class="hljs-literal">nil</span>,   <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to register consumer: %v&quot;</span>, err)<br>&#125;<br><br>consumer2, err := ch2.Consume(<br>q.Name,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不自动应答</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 独占</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待</span><br><span class="hljs-literal">false</span>, <span class="hljs-comment">// 不等待 server 确认</span><br><span class="hljs-literal">nil</span>,   <span class="hljs-comment">// 额外参数</span><br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to register consumer: %v&quot;</span>, err)<br>    &#125;<br>    <br><span class="hljs-comment">// 每次取出 10 条消息，进行批量确认</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> msg, ok := &lt;-consumer1:<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Printf(<span class="hljs-string">&quot;channel closed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 处理消息</span><br>fmt.Printf(<span class="hljs-string">&quot;received message: %s\n&quot;</span>, msg.Body)<br><br><span class="hljs-comment">// 批量确认消息</span><br><span class="hljs-keyword">if</span> msg.DeliveryTag%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &#123;<br>                <span class="hljs-comment">// 这里也可以直接调用 msg.Ack(true) 代替，下同</span><br>err = ch1.Ack(msg.DeliveryTag, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;failed to ack message: %v&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br>        <span class="hljs-keyword">case</span> msg, ok := &lt;-consumer2:<br><span class="hljs-keyword">if</span> !ok &#123;<br>log.Printf(<span class="hljs-string">&quot;channel closed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 处理消息</span><br>fmt.Printf(<span class="hljs-string">&quot;received message: %s\n&quot;</span>, msg.Body)<br><br><span class="hljs-comment">// 批量确认消息</span><br><span class="hljs-keyword">if</span> msg.DeliveryTag%<span class="hljs-number">10</span> == <span class="hljs-number">0</span> &#123;<br>err = ch2.Ack(msg.DeliveryTag, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;failed to ack message: %v&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><strong>生产者</strong></p><p>同1.2生产者，省略。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.rabbitmq.com/specification.html">https://www.rabbitmq.com/specification.html</a> [RabbitMQ 兼容性和一致性]</li><li><a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">https://www.rabbitmq.com/tutorials/amqp-concepts.html</a> [AMQP 0-9-1 模型解释]</li><li><a href="https://github.com/rabbitmq/amqp091-go">https://github.com/rabbitmq/amqp091-go</a> [由 RabbitMQ 团队维护的 AMQP 0-9-1 Go 客户端]</li></ul>]]></content>
    
    
    <categories>
      
      <category>rabbitmq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>rabbitmq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-浅析net库http请求处理流程</title>
    <link href="/2023/03/07/golang/http_request/"/>
    <url>/2023/03/07/golang/http_request/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-浅析net库http请求处理流程"><a href="#Golang-浅析net库http请求处理流程" class="headerlink" title="Golang-浅析net库http请求处理流程"></a>Golang-浅析net库http请求处理流程</h1><p>主要记录HTTP请求在net包中经历的关键节点，基于go1.19.1</p><p>学习net包中使用 预分配内存、sync.Pool 提升性能技巧，以及其他优秀的设计思想。</p><h2 id="1-管理TCP连接"><a href="#1-管理TCP连接" class="headerlink" title="1. 管理TCP连接"></a>1. 管理TCP连接</h2><p>什么epoll、三次握手这些八股文不提了，这里从 <code>Serve()</code> 开始记录；</p><p>在 <strong>net&#x2F;http&#x2F;server.go</strong> 的 <code>func (srv *Server) Serve(l net.Listener) error</code> 方法中，关注以下流程：</p><p><img src="conn.jpg"></p><ul><li><code>l.Accept()</code> 得到一个 <code>*net.TCPConn</code> 类型的指针 <strong>rw</strong></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    .......<br>    <span class="hljs-keyword">for</span> &#123;<br>        rw, err := l.Accept()<br>        ......<br>        c := srv.newConn(rw)<br>        c.setState(c.rwc, StateNew, runHooks) <span class="hljs-comment">// before Serve can return</span><br>        <span class="hljs-keyword">go</span> c.serve(connCtx)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>这个*net.TCPConn是个什么东西？可以稍稍看看里面</p><ul><li>net&#x2F;tcpsock.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// TCPConn is an implementation of the Conn interface for TCP network</span><br><span class="hljs-comment">// connections.</span><br><span class="hljs-keyword">type</span> TCPConn <span class="hljs-keyword">struct</span> &#123;<br>conn<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>内部嵌套conn，net&#x2F;net.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> conn <span class="hljs-keyword">struct</span> &#123;<br>fd *netFD <span class="hljs-comment">// &lt;--找到这个命名就知道对了</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>net&#x2F;fd_posix.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Network file descriptor.</span><br><span class="hljs-keyword">type</span> netFD <span class="hljs-keyword">struct</span> &#123;<br>pfd poll.FD <span class="hljs-comment">// &lt;--找到稍微根源的东西了，这里先不深入了</span><br><br><span class="hljs-comment">// immutable until Close</span><br>family      <span class="hljs-type">int</span><br>sotype      <span class="hljs-type">int</span><br>isConnected <span class="hljs-type">bool</span> <span class="hljs-comment">// handshake completed or use of association with peer</span><br>net         <span class="hljs-type">string</span><br>laddr       Addr<br>raddr       Addr<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>srv.newConn(rw)</code> 中包装并返回 <code>server.conn</code> 对象指针（下面简称 <strong>conn</strong>），其中 server.conn.<strong>rwc</strong> 指向这个 <strong>rw</strong></p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Create new connection from rwc.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> newConn(rwc net.Conn) *conn &#123;<br>c := &amp;conn&#123;<br>server: srv, <span class="hljs-comment">// 保存Server的指针，这种设计很多见，这里用于处理连接状态变更后统一使用server.ConnState进行回调等等动作</span><br>        rwc:    rwc, <span class="hljs-comment">// Accept()得到的*net.TCPConn</span><br>&#125;<br><span class="hljs-keyword">if</span> debugServerConnections &#123;<br>c.rwc = newLoggingConn(<span class="hljs-string">&quot;server&quot;</span>, c.rwc)<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>经过 <code>c.setState()</code> 会将 <strong>rw</strong> 记录在 <code>server.activeConn</code> 中</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *Server)</span></span> trackConn(c *conn, add <span class="hljs-type">bool</span>) &#123;<br>s.mu.Lock()<br><span class="hljs-keyword">defer</span> s.mu.Unlock()<br><span class="hljs-keyword">if</span> s.activeConn == <span class="hljs-literal">nil</span> &#123;<br>s.activeConn = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[*conn]<span class="hljs-keyword">struct</span>&#123;&#125;)<br>&#125;<br><span class="hljs-keyword">if</span> add &#123;<br>        <span class="hljs-comment">// 对于新增conn首次设置状态走这里，将conn指针保存到server的活跃集合中。</span><br>        <span class="hljs-comment">// 此处实现了Server实例对conn后续管理的前提。</span><br>s.activeConn[c] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">delete</span>(s.activeConn, c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>并且 <strong>conn</strong> 会更新当前状态，这个状态使用一个 <strong>原子变量</strong> 存储保证一致性</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> setState(nc net.Conn, state ConnState, runHook <span class="hljs-type">bool</span>) &#123;<br>srv := c.server<br><span class="hljs-keyword">switch</span> state &#123;<br><span class="hljs-keyword">case</span> StateNew:<br>srv.trackConn(c, <span class="hljs-literal">true</span>) <span class="hljs-comment">// 见上文</span><br><span class="hljs-keyword">case</span> StateHijacked, StateClosed:<br>srv.trackConn(c, <span class="hljs-literal">false</span>)<br>&#125;<br><span class="hljs-keyword">if</span> state &gt; <span class="hljs-number">0xff</span> || state &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;internal error&quot;</span>)<br>&#125;<br>packedState := <span class="hljs-type">uint64</span>(time.Now().Unix()&lt;&lt;<span class="hljs-number">8</span>) | <span class="hljs-type">uint64</span>(state) <span class="hljs-comment">// 低8位保存当前状态，8位前保存变更时间戳</span><br>atomic.StoreUint64(&amp;c.curState.atomic, packedState) <span class="hljs-comment">// 更新当前状态</span><br><span class="hljs-keyword">if</span> !runHook &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">if</span> hook := srv.ConnState; hook != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// 这里会用到srv，如果Server有外置的钩子，conn每一次状态变更，都会在这里回调通知</span><br>hook(nc, state)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>最后这个 <strong>conn</strong> 带着一个”有故事的”上下文，在全新的goroutine中执行；</p><ul><li>这个上下文的前置处理有点东西，有很强的扩展性，简单记录一下</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(srv *Server)</span></span> Serve(l net.Listener) <span class="hljs-type">error</span> &#123;<br>    ......<br>    origListener := l<br>    ......<br>    baseCtx := context.Background() <span class="hljs-comment">// 先获取一个平平无奇的上下文</span><br>    <span class="hljs-keyword">if</span> srv.BaseContext != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// 这里可以利用srv指定的基础上下文获取方法替代原始baseCtx，是指Server层级的Context处理过程。</span><br>        <span class="hljs-comment">// 这里的l可以有很多种实例，这里是tcp，也可以是udp、uds等。</span><br>        baseCtx = srv.BaseContext(origListener)<br>        <span class="hljs-keyword">if</span> baseCtx == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;BaseContext returned a nil context&quot;</span>)<br>        &#125;<br>    &#125;<br>    ......<br>    <span class="hljs-comment">// 这里使用一个*valueCtx将baseCtx包裹在内，并使用ServerContextKey与srv的指针存储kv，方便在任何带有该上下文的方法中得到srv，可以说非常灵活。</span><br>    ctx := context.WithValue(baseCtx, ServerContextKey, srv)<br>    <span class="hljs-keyword">for</span> &#123;<br>        connCtx := ctx<br>        <span class="hljs-comment">// 这里利用srv指定Connect层级的Context处理过程，与上文的BaseContext相互照应，这种分离层级策略使得ctx的特殊处理更为细致与明确。</span><br>        <span class="hljs-comment">// 方便针对各种http框架的context在此处进行特殊业务处理。</span><br>        <span class="hljs-keyword">if</span> cc := srv.ConnContext; cc != <span class="hljs-literal">nil</span> &#123;<br>            connCtx = cc(connCtx, rw)<br>            <span class="hljs-keyword">if</span> connCtx == <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;ConnContext returned nil&quot;</span>)<br>            &#125;<br>        &#125;<br>        ......<br>        c := srv.newConn(rw)<br>        ......<br>        <span class="hljs-keyword">go</span> c.serve(connCtx) <span class="hljs-comment">// 最终ctx被带人到下一步的请求处理中</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="2-读取请求内容"><a href="#2-读取请求内容" class="headerlink" title="2. 读取请求内容"></a>2. 读取请求内容</h2><h3 id="2-1-主流程"><a href="#2-1-主流程" class="headerlink" title="2.1. 主流程"></a>2.1. 主流程</h3><ul><li>从 <code>func (c *conn) serve(ctx context.Context)</code> 进去主要关注以下流程：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> serve(ctx context.Context) &#123;<br>    ......<br>    <span class="hljs-comment">// 连接退出善后处理流程</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 先来一个recover，防止本goroutine发送panic导致主goroutine退出</span><br><span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &amp;&amp; err != ErrAbortHandler &#123;<br>            <span class="hljs-comment">// 这里是打印一些panic的堆栈信息</span><br><span class="hljs-keyword">const</span> size = <span class="hljs-number">64</span> &lt;&lt; <span class="hljs-number">10</span><br>buf := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size)<br>buf = buf[:runtime.Stack(buf, <span class="hljs-literal">false</span>)]<br>c.server.logf(<span class="hljs-string">&quot;http: panic serving %v: %v\n%s&quot;</span>, c.remoteAddr, err, buf)<br>&#125;<br>        <span class="hljs-comment">// 如果没有在外部调用劫持请求，将调用close方法释放资源，并更细连接状态为 Close(结束)</span><br>        <span class="hljs-comment">// 到这里可能疑惑：</span><br>        <span class="hljs-comment">//     如果劫持了，那么资源怎么释放？答案是劫持方法会返回*conn，需要在劫持处理完成后手工调用conn.Close()方法释放资源，否则出现资源泄露！</span><br><span class="hljs-keyword">if</span> !c.hijacked() &#123;<br>c.<span class="hljs-built_in">close</span>()<br>c.setState(c.rwc, StateClosed, runHooks)<br>&#125;<br>&#125;()<br>    ......<br>    c.r = &amp;connReader&#123;conn: c&#125;<br>    <span class="hljs-comment">// 申请内存空间，用于存储请求body数据</span><br>c.bufr = newBufioReader(c.r)<br>    ......<br>    ......<br>    <span class="hljs-comment">// 真正的核心流程开始，分6个主要流程</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <span class="hljs-comment">// 1.解析请求内容，并构造、填充req与resp信息对象</span><br>        w, err := c.readRequest(ctx)<br>        ......<br>        <span class="hljs-comment">// 2.通过回调的方式经过如洋葱一般的各层http框架的中间件再到达真实业务逻辑层，最终又原路返回</span><br>        serverHandler&#123;c.server&#125;.ServeHTTP(w, w.req)<br>        ......<br>        <span class="hljs-comment">// 3.请求处理完成，重置各种请求状态、释放各种临时资源</span><br>        w.finishRequest()<br>        <span class="hljs-comment">// 4.判断连接是否可重用，不可重用则直接返回释放连接</span><br>        <span class="hljs-keyword">if</span> !w.shouldReuseConnection() &#123;<br>            <span class="hljs-keyword">if</span> w.requestBodyLimitHit || w.closedRequestBodyEarly() &#123;<br>                <span class="hljs-comment">// 发送FIN报文，主动关闭连接，并等待一定时间(这里是500ms)，等待客户端将未处理的数据处理完</span><br>        c.closeWriteAndWait()<br>            &#125;<br>        <span class="hljs-keyword">return</span><br>&#125;<br>        <span class="hljs-comment">// 5.更新连接状态为 Idle (已完成)</span><br>c.setState(c.rwc, StateIdle, runHooks)<br>        <span class="hljs-comment">// 6.如果请求没有设置 keep_alive 选项，则直接结束连接</span><br>        <span class="hljs-comment">// 反之保持连接，等待下一次请求</span><br>        <span class="hljs-keyword">if</span> !w.conn.server.doKeepAlives() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-请求数据解析-x2F-存储流程"><a href="#2-2-请求数据解析-x2F-存储流程" class="headerlink" title="2.2. 请求数据解析&#x2F;存储流程"></a>2.2. 请求数据解析&#x2F;存储流程</h3><ul><li><p>申请存储数据的内存缓冲区</p><ul><li>net&#x2F;http&#x2F;server.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newBufioReader</span><span class="hljs-params">(r io.Reader)</span></span> *bufio.Reader &#123;<br>    <span class="hljs-comment">// 这里可以明白，这个内存首先尝试在一个sync.Pool中获取，说明后面逻辑中有将资源置入缓冲池里复用，避免频繁GC</span><br>    <span class="hljs-comment">// 在conn.close()和conn.closeWriteAndWait()都会将首次申请的缓冲区内存Put到池中，等待下一次连接重用</span><br><span class="hljs-keyword">if</span> v := bufioReaderPool.Get(); v != <span class="hljs-literal">nil</span> &#123;<br>br := v.(*bufio.Reader)<br>br.Reset(r)<br><span class="hljs-keyword">return</span> br<br>&#125;<br><span class="hljs-keyword">return</span> bufio.NewReader(r) <span class="hljs-comment">// &lt;--首次处理一个连接的请求时没有缓冲池，会真正申请一块连续内存</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>bufio&#x2F;bufio.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>defaultBufSize = <span class="hljs-number">4096</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(rd io.Reader)</span></span> *Reader &#123;<br><span class="hljs-keyword">return</span> NewReaderSize(rd, defaultBufSize) <span class="hljs-comment">// &lt;--这里会预分配一块4KB大小的内存</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReaderSize</span><span class="hljs-params">(rd io.Reader, size <span class="hljs-type">int</span>)</span></span> *Reader &#123;<br>......<br>r := <span class="hljs-built_in">new</span>(Reader)<br>r.reset(<span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, size), rd)<br><span class="hljs-keyword">return</span> r<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Reader)</span></span> reset(buf []<span class="hljs-type">byte</span>, r io.Reader) &#123;<br>*b = Reader&#123; <span class="hljs-comment">// &lt;--最终创建一个*bufio.Reader保存预分配的内存</span><br>buf:          buf,  <span class="hljs-comment">// 4KB空白内存</span><br>rd:           r,    <span class="hljs-comment">// *connReader</span><br>lastByte:     <span class="hljs-number">-1</span>,<br>lastRuneSize: <span class="hljs-number">-1</span>,<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>读取http-body数据到缓存区</p><ul><li>从连接中读取请求数据，以及初始化响应</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *conn)</span></span> readRequest(ctx context.Context) (w *response, err <span class="hljs-type">error</span>) &#123;<br>    ......<br>    <span class="hljs-comment">// 真正处理读取连接内容的方法</span><br>    req, err := readRequest(c.bufr, keepHostHeader)<br>    <span class="hljs-comment">// 构造resp</span><br>    w = &amp;response&#123;<br>        conn:          c,<br>        cancelCtx:     cancelCtx,<br>        req:           req,<br>        reqBody:       req.Body,<br>        ......<br>    &#125;<br>    ......<br>    <span class="hljs-keyword">return</span> w, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>解析请求，并构request对象</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readRequest</span><span class="hljs-params">(b *bufio.Reader, deleteHostHeader <span class="hljs-type">bool</span>)</span></span> (req *Request, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-comment">// 创建或从缓冲池中获取一个text格式协议的Reader，此时tp中携带了*bufio.Reade--&gt;b，在后续读取数据时将直接对b预申请的4KB缓冲区进行写操作</span><br>    <span class="hljs-comment">// 其内部会初始化所有的公共Header(单例模式)，用于后续读取公共Header时知道需要获取哪些Header-Value</span><br>tp := newTextprotoReader(b)<br>req = <span class="hljs-built_in">new</span>(Request)<br><br><span class="hljs-comment">// First line: GET /index.html HTTP/1.0</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>    <span class="hljs-comment">// 利用TextprotoReader读取conn信息，并填充b的4KB缓冲区</span><br><span class="hljs-keyword">if</span> s, err = tp.ReadLine(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>    <span class="hljs-comment">// TextprotoReader的善后处理</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>putTextprotoReader(tp) <span class="hljs-comment">// 将资源Put到缓冲池中等待下一个报文复用</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br>err = io.ErrUnexpectedEOF<br>&#125;<br>&#125;()<br>    <br>    ......<br>    <span class="hljs-comment">// 这里主要是解析URL上的请求参数，没啥好说的，比较简单，参数存储在req.URL.RawQuery中</span><br>rawurl := req.RequestURI<br><span class="hljs-keyword">if</span> req.ProtoMajor, req.ProtoMinor, ok = ParseHTTPVersion(req.Proto); !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, badStringError(<span class="hljs-string">&quot;malformed HTTP version&quot;</span>, req.Proto)<br>&#125;<br><span class="hljs-keyword">if</span> req.URL, err = url.ParseRequestURI(rawurl); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>    ......<br>    <br>    <span class="hljs-comment">// 这里获取newTextprotoReader()中初始化的所有Header-Key对用的Header-Value，返回KV接口的Header信息</span><br>mimeHeader, err := tp.ReadMIMEHeader()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>req.Header = Header(mimeHeader)<br>    <br>    ......<br>    <span class="hljs-comment">// 对于Body.len &gt; 0的请求，将b中4BK缓冲区的数据交给req.Body，这里交付的是指针对象，不存在深拷贝</span><br>    <span class="hljs-comment">// 并且尽可能通过读取Header: Content-Length得知真实Body内容大小，对b进行二次封装--&gt;io.LimitReader，记录有效内容字节数</span><br>    <span class="hljs-comment">// 后续可以通过字节数直接获取有效内容</span><br>    <span class="hljs-comment">// 对于Body.len == 0的请求，直接赋值 NoBody: struct&#123;&#125; 给到req.Body</span><br>    err = readTransfer(req, b)<br>    <br>    ......<br>    <span class="hljs-keyword">return</span> req, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>net</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APISIX-2.13.3-CentOS_7-单节点部署</title>
    <link href="/2022/09/02/apisix/APISIX-2.13.3-CentOS_7-SingleNode/"/>
    <url>/2022/09/02/apisix/APISIX-2.13.3-CentOS_7-SingleNode/</url>
    
    <content type="html"><![CDATA[<h1 id="APISIX-2-13-3-CentOS-7-单节点部署"><a href="#APISIX-2-13-3-CentOS-7-单节点部署" class="headerlink" title="APISIX-2.13.3-CentOS_7-单节点部署"></a>APISIX-2.13.3-CentOS_7-单节点部署</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><ul><li>APISIX服务、ETCD、Grafana使用docker容器部署</li><li>APISIX-Dashboard使用yum方式安装</li><li>ETCD版本：<a href="https://hub.docker.com/layers/bitnami/etcd/3.4.20/images/sha256-4ac42c73de723d764158e04b8c876806a992846c3320e80c24a73b5611fd1211?context=explore">3.4.20</a></li><li>APISIX版本：<a href="https://hub.docker.com/layers/apache/apisix/2.13.3-centos/images/sha256-f0555b53112bde34cfb40e411bd0660676adebd6451740787c2b7c9bf151a5ea?context=explore">2.13.3-centos</a></li><li>Grafana版本：<a href="https://hub.docker.com/layers/grafana/grafana/9.1.4/images/sha256-f776b98f6bc3115d04f76f9b52b8172ac0cd81a8a78933d7e48bf2b76ce13d95?context=explore">9.1.4</a></li><li>Prometheus版本：<a href="https://hub.docker.com/layers/prom/prometheus/v2.37.1/images/sha256-3e1ee1732b4a3d08d971ee05950f30ce54dd405d7f0255bcab2303827a01312e?context=explore">2.37.1</a></li><li>APISIX-Dashboard版本：2.13.3-centos</li><li>APISIX官方部署教程：<ul><li><a href="https://apisix.apache.org/zh/docs/apisix/installation-guide/">APISIX</a></li><li><a href="https://apisix.apache.org/zh/docs/dashboard/install/">APISIX-Dashboard</a></li></ul></li><li>单节点部署方式仅用于功能体验，不适用于真实生产环境；本样例使用较为快捷的方式安装，意于测试apisix的基础能力</li></ul><h2 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h2><ul><li>安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum install -y docker<br></code></pre></td></tr></table></figure><ul><li>运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure><h2 id="2-安装APISIX服务"><a href="#2-安装APISIX服务" class="headerlink" title="2. 安装APISIX服务"></a>2. 安装APISIX服务</h2><ul><li>安装ETCD</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>   --name etcd \<br>   --net host \<br>   -e ALLOW_NONE_AUTHENTICATION=yes \<br>   -e ETCD_ADVERTISE_CLIENT_URLS=http://127.0.0.1:2379 \<br>   bitnami/etcd:3.4.20<br></code></pre></td></tr></table></figure><ul><li>安装APISIX</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --name apache-apisix \<br>    --net host \<br>    -p 9091:9091 \<br>    apache/apisix:2.13.3-centos<br></code></pre></td></tr></table></figure><ul><li>安装好后默认账号与密码</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apisix:</span><br>  <span class="hljs-attr">admin_key:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">admin</span><br>      <span class="hljs-attr">key:</span> <span class="hljs-string">edd1c9f034335f136f87ad84b625c8f1</span>  <span class="hljs-comment"># using fixed API token has security risk, please update it when you deploy to production environment</span><br>      <span class="hljs-attr">role:</span> <span class="hljs-string">admin</span><br></code></pre></td></tr></table></figure><h2 id="3-安装APISIX-Dashboard服务"><a href="#3-安装APISIX-Dashboard服务" class="headerlink" title="3. 安装APISIX-Dashboard服务"></a>3. 安装APISIX-Dashboard服务</h2><ul><li>下载rpm安装包并安装</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo yum install -y https://github.com/apache/apisix-dashboard/releases/download/v2.13/apisix-dashboard-2.13-0.el7.x86_64.rpm<br></code></pre></td></tr></table></figure><ul><li>修改配置文件，使其能运行所有机器访问</li></ul><p>编辑文件：&#x2F;usr&#x2F;local&#x2F;apisix&#x2F;dashboard&#x2F;conf&#x2F;conf.yaml</p><p>注释掉 allow_list下面的IP地址默认配置项</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">33   allow_list:</span>             <span class="hljs-comment"># If we don&#x27;t set any IP list, then any IP access is allowed by default.</span><br><span class="hljs-number">34</span>   <span class="hljs-comment">#  - 0.0.0.0            # The rules are checked in sequence until the first match is found.</span><br><span class="hljs-number">35</span>   <span class="hljs-comment">#  - ::1                # In this example, access is allowed only for IPv4 network 127.0.0.1, and for IPv6 network ::1.</span><br><span class="hljs-number">36</span>                           <span class="hljs-comment"># It also support CIDR like 192.168.1.0/24 and 2001:0db8::/32</span><br></code></pre></td></tr></table></figure><ul><li>启动Dashboard服务</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start apisix-dashboard.service<br></code></pre></td></tr></table></figure><h2 id="4-安装Prometheus"><a href="#4-安装Prometheus" class="headerlink" title="4. 安装Prometheus"></a>4. 安装Prometheus</h2><h3 id="4-1-下载-amp-安装-amp-运行"><a href="#4-1-下载-amp-安装-amp-运行" class="headerlink" title="4.1 下载&amp;安装&amp;运行"></a>4.1 下载&amp;安装&amp;运行</h3><ul><li>拉取prometheus镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull prom/prometheus:v2.37.1<br></code></pre></td></tr></table></figure><ul><li>尝试运行容器</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=prometheus -p 9090:9090 prom/prometheus:v2.37.1<br></code></pre></td></tr></table></figure><p>执行后会报错9090端口已经被占用，查了一下使用情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">[root@localhost data]# netstat -anp | grep 9090<br>tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN      121999/nginx: maste<br><br>[root@localhost data]# netstat -anp | grep 121999<br>tcp        0      0 0.0.0.0:9080            0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp        0      0 127.0.0.1:9090          0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp        0      0 0.0.0.0:9443            0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp        0      0 127.0.0.1:9091          0.0.0.0:*               LISTEN      121999/nginx: maste <br>tcp6       0      0 :::9080                 :::*                    LISTEN      121999/nginx: maste <br>tcp6       0      0 :::9443                 :::*                    LISTEN      121999/nginx: maste <br>unix  3      [ ]         STREAM     CONNECTED     568778   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568773   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568775   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568779   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568774   121999/nginx: maste  <br>unix  3      [ ]         STREAM     CONNECTED     568772   121999/nginx: maste<br></code></pre></td></tr></table></figure><p>是apisix主服务占用了9090端口，因此需要修改prometheus的web服务监听端口为19090；</p><p>注意：执行前删除刚刚创建失败的prometheus容器，上面一步也可以使用 <code>docker pull</code> 拉取镜像不创建容器；</p><ul><li>在宿主机创建prometheus配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /usr/local/prometheus/data<br>cd /usr/local/prometheus/data<br>vim prometheus.yaml<br></code></pre></td></tr></table></figure><ul><li>修建如下配置项</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">60s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">60s</span><br>    <br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;127.0.0.1:19090&quot;</span>]<br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br></code></pre></td></tr></table></figure><p>注意：上面的 <code>job_name:&quot;prometheus&quot;</code> 配置只是一个采集目标端口，用于自检，并不是prom-web的开放端口配置。后续可以在 <code>http://&lt;ip&gt;:&lt;port&gt;/targets?search=</code> 中看到该配置的效果；</p><ul><li>运行prometheus容器<ul><li>–net&#x3D;host：与宿主机共享同一个网络</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d \<br>    --name=prometheus \<br>    --net=host \<br>    -v /usr/local/prometheus/data:/data \<br>    prom/prometheus:v2.37.1 \<br>    --config.file=/data/prometheus.yaml \<br>    --web.listen-address=:19090<br></code></pre></td></tr></table></figure><ul><li>web访问地址：http:&#x2F;&#x2F;&lt;ip&gt;:19090<ul><li>如果不能访问看【设置防火墙】一节，放通19090端口给外网访问</li></ul></li></ul><h3 id="4-2-APISIX接入Prometheus"><a href="#4-2-APISIX接入Prometheus" class="headerlink" title="4.2 APISIX接入Prometheus"></a>4.2 APISIX接入Prometheus</h3><ul><li><p>查看APISIX配置，找到提供给prom采集数据的接口及路径</p><ul><li>配置文件：conf&#x2F;config-default.yaml</li><li>开放端口：9091</li><li>开放路径：&#x2F;apisix&#x2F;prometheus&#x2F;metrics</li></ul></li><li><p>修改prometheus.yaml，添加APISIX监控端口</p></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-string">......</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;apisix&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/apisix/prometheus/metrics</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9091&quot;</span>]<br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">instance:</span> <span class="hljs-string">&quot;apisix&quot;</span><br></code></pre></td></tr></table></figure><ul><li>重启prometheus，可以在 <a href="http://192.168.142.129:19090/targets?search=">http://192.168.142.129:19090/targets?search=</a> 路径查看是否添加成功</li></ul><p><img src="screenshot-20220913-203233.png"></p><h2 id="5-安装Grafana"><a href="#5-安装Grafana" class="headerlink" title="5. 安装Grafana"></a>5. 安装Grafana</h2><h3 id="5-1-下载-amp-安装-amp-运行"><a href="#5-1-下载-amp-安装-amp-运行" class="headerlink" title="5.1 下载&amp;安装&amp;运行"></a>5.1 下载&amp;安装&amp;运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run -d --name=grafana -p 3000:3000 grafana/grafana:9.1.4<br></code></pre></td></tr></table></figure><ul><li>重启docker</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl restart docker<br></code></pre></td></tr></table></figure><ul><li><p>找到grafana的容器重新运行</p></li><li><p>web访问地址：http:&#x2F;&#x2F;&lt;ip&gt;:3000</p></li><li><p>初始账号密码：admin&#x2F;admin</p></li></ul><h3 id="5-2-Grafana接入Prometheus"><a href="#5-2-Grafana接入Prometheus" class="headerlink" title="5.2 Grafana接入Prometheus"></a>5.2 Grafana接入Prometheus</h3><ul><li><p>配置apisix监控样式：</p><ul><li>下载json：<a href="https://github.com/apache/apisix/tree/2.13.3/docs/assets/other/json">https://github.com/apache/apisix/tree/2.13.3/docs/assets/other/json</a></li><li>配置promtheus数据源</li></ul><p><img src="screenshot-20220913-182222.png"></p><ul><li>填写prometheus访问地址</li></ul><p><img src="screenshot-20220913-182339.png"></p><ul><li>导入apisix-dashboard样式json文件</li></ul><p><img src="screenshot-20220913-182509.png"></p><ul><li>数据源选择刚刚添加好的prometheus</li></ul><p><img src="screenshot-20220913-182528.png"></p><ul><li>保存得到最终效果如下：</li></ul><p><img src="screenshot-20220913-203722.png"></p></li></ul><h3 id="5-3-Grafana嵌入APISIX"><a href="#5-3-Grafana嵌入APISIX" class="headerlink" title="5.3 Grafana嵌入APISIX"></a>5.3 Grafana嵌入APISIX</h3><ul><li>进入容器，修改grafana配置，使之运行匿名登录及嵌入浏览</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker exec -it --user root &lt;容器id&gt; /bin/bash<br></code></pre></td></tr></table></figure><ul><li>编辑 defaults.ini 文件</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vi /conf/defaults.ini<br></code></pre></td></tr></table></figure><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 允许嵌入浏览</span><br><span class="hljs-attr">allow_embedding</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 允许匿名登录</span><br><span class="hljs-section">[auth.anonymous]</span><br><span class="hljs-attr">enabled</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="6-设置防火墙"><a href="#6-设置防火墙" class="headerlink" title="6. 设置防火墙"></a>6. 设置防火墙</h2><ul><li>如果之前disable过防火墙，需要加上这步，否则不需要</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shel">systemctl unmask firewalld.service<br>systemctl start firewalld.service<br></code></pre></td></tr></table></figure><ul><li>放通9000、9080端口<ul><li>9000端口用于访问APISIX-Dashboard</li><li>9080端口用于访问APISIX网关入口</li><li>19090端口用于访问Prometheus-WEB后台</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=9000/tcp --permanent<br>firewall-cmd --zone=public --add-port=9080/tcp --permanent<br>firewall-cmd --zone=public --add-port=19090/tcp --permanent<br></code></pre></td></tr></table></figure><ul><li>防火墙重新加载配置</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --reload<br></code></pre></td></tr></table></figure><h2 id="7-参考资料"><a href="#7-参考资料" class="headerlink" title="7. 参考资料"></a>7. 参考资料</h2><ul><li><a href="https://blog.csdn.net/ichen820/article/details/117930543">如何更改prometheus监控系统启动的默认端口号</a></li><li><a href="https://blog.csdn.net/qq_42883074/article/details/114499518">prometheus使用 (二) 监控主机节点</a></li><li><a href="https://juejin.cn/post/7076829002224107551">APISIX+grafana网关安装全记录</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>apisix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apisix</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>APISIX-2.13.3-路由与插件</title>
    <link href="/2022/09/02/apisix/APISIX-2.13.3-Function/"/>
    <url>/2022/09/02/apisix/APISIX-2.13.3-Function/</url>
    
    <content type="html"><![CDATA[<h1 id="APISIX-2-13-3-路由与插件"><a href="#APISIX-2-13-3-路由与插件" class="headerlink" title="APISIX-2.13.3-路由与插件"></a>APISIX-2.13.3-路由与插件</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li><p>本文是基于官方使用说明，结合实践的过程记录。</p><ul><li>官方使用说明：<a href="https://apisix.apache.org/zh/docs/apisix/2.13/architecture-design/apisix/">https://apisix.apache.org/zh/docs/apisix/2.13/architecture-design/apisix/</a></li></ul></li><li><p>客户端实验平台：windows10</p></li><li><p>http压力测试工具：Apache Bench VS16</p></li></ul><h2 id="1-路由基础"><a href="#1-路由基础" class="headerlink" title="1. 路由基础"></a>1. 路由基础</h2><h3 id="1-1-前提准备"><a href="#1-1-前提准备" class="headerlink" title="1.1. 前提准备"></a>1.1. 前提准备</h3><ul><li><p>简单的http测试服务，使用go快速编写，提供&#x2F;ping1<del>&#x2F;ping3、&#x2F;test1</del>test3接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>port, flag := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>]<br><br>http.HandleFunc(<span class="hljs-string">&quot;/ping1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ping1_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/ping2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ping2_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/ping3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ping3_&quot;</span> + flag))<br>&#125;)<br><br>http.HandleFunc(<span class="hljs-string">&quot;/test1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test1_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/test2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test2_&quot;</span> + flag))<br>&#125;)<br>http.HandleFunc(<span class="hljs-string">&quot;/test3&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test3_&quot;</span> + flag))<br>&#125;)<br><br>http.ListenAndServe(<span class="hljs-string">&quot;:&quot;</span>+port, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">go build main.go<br>.\main.exe 9101 A &amp;<br>.\main.exe 9102 B &amp;<br>.\main.exe 9103 C &amp;<br></code></pre></td></tr></table></figure></li><li><p>测试过程中加入prometheus监控插件</p></li></ul><h3 id="1-2-路径路由"><a href="#1-2-路径路由" class="headerlink" title="1.2. 路径路由"></a>1.2. 路径路由</h3><ul><li><p>添加2组 <strong>上游</strong> 配置，配置如下：（这里只摘抄json格式配置，也可以在APISIX Dashboard中添加）</p></li><li><p>使用三个相同的服务节点，提供相同的<code>http-GET</code>接口组，绑定2组 <strong>上游</strong> 配置</p><ul><li><strong>ping接口组</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 三组节点，分流权重都是1</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 服务所在IP地址</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9102</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 均衡负载算法：带权轮询</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping接口组&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 上游组名称</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>   <span class="hljs-comment">// 连接池配置，默认值</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test接口组</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9102</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>最终得到结果：</li></ul><p><img src="image-20220915140858565.png"></p></li><li><p>添加2组 <strong>路由</strong> 配置，配置如下：（这里只摘抄json格式配置，也可以在APISIX Dashboard中添加）</p><ul><li><strong>ping接口组路由</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/ping*&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 匹配路由</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping接口组路由&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>  <span class="hljs-comment">// 插件组：添加prometheus</span><br>        <span class="hljs-attr">&quot;prometheus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425504991357175601&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 绑定ping接口组</span><br>    <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;API_VERSION&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>  <span class="hljs-comment">// 发布状态</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><strong>test接口组路由</strong></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/test*&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 匹配路由</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组路由&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;prometheus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 绑定test接口组</span><br>    <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;API_VERSION&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span>  <span class="hljs-comment">// 未发布状态</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>最终得到结果：</li></ul><p><img src="screenshot-20220915-141401.png"></p></li><li><p>请求测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_A<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_B<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_C<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/ping1<br>ping1_A<br>&#x27;200&#x27;<br><br>curl.exe -w &#x27;%&#123;http_code&#125;&#x27; http://192.168.142.129:9080/test1<br>&#123;&quot;error_msg&quot;:&quot;404 Route Not Found&quot;&#125;<br>&#x27;404&#x27;<br></code></pre></td></tr></table></figure><ul><li><strong>ping接口组路由</strong> 成功过滤了未匹配路径的请求；后续发布 <strong>test接口组路由</strong> 可以看到 &#x2F;test1 可以请求成功；</li><li><strong>ping接口组</strong> 上游配置均衡负载算法生效；</li></ul></li></ul><h3 id="1-3-域名路由"><a href="#1-3-域名路由" class="headerlink" title="1.3. 域名路由"></a>1.3. 域名路由</h3><ul><li><p>添加并发布2组 <strong>路由</strong> 配置，并下架1.2中配置的路径路由组，配置如下</p><p><img src="image-20220915162132387.png"></p></li><li><p>在请求端上添加 <a href="http://www.ping_service.com/">www.ping_service.com</a> 与 <a href="http://www.test_service.com/">www.test_service.com</a> 的域名解析</p></li><li><p>请求测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl.exe -I http://www.ping_service.com:9080/test1<br>HTTP/1.1 404 Not Found<br>Date: Thu, 15 Sep 2022 08:27:23 GMT<br>Content-Type: text/plain; charset=utf-8<br>Connection: keep-alive<br>Server: APISIX/2.13.3<br><br>curl.exe http://www.ping_service.com:9080/ping1<br>ping1_A<br><br>curl.exe http://www.ping_service.com:9080/ping1<br>ping1_B<br><br>curl.exe http://www.ping_service.com:9080/ping1<br>ping1_C<br><br>curl.exe http://www.test_service.com:9080/test1<br>test1_B<br></code></pre></td></tr></table></figure><ul><li><p><strong>ping接口组路由2</strong> 成功过滤了未匹配域名+路径的请求；后续尝试的 <strong>test接口组路由2</strong> 可以看到 &#x2F;test1 可以请求成功；</p></li><li><p><strong>ping接口组</strong> 上游配置均衡负载算法生效；</p></li></ul></li></ul><h3 id="1-4-异常场景"><a href="#1-4-异常场景" class="headerlink" title="1.4. 异常场景"></a>1.4. 异常场景</h3><h4 id="1-4-1-目标节点失活"><a href="#1-4-1-目标节点失活" class="headerlink" title="1.4.1. 目标节点失活"></a>1.4.1. 目标节点失活</h4><ul><li><p>复用1.3的配置，将端口是9103的服务关停，此时<strong>ping接口组</strong>中目标节点只有9101与9102存活</p></li><li><p>修改<strong>ping接口组-连接超时</strong>配置为<strong>6</strong>s</p></li><li><p>使用curl不断请求 <a href="http://www.ping_service.com:9080/ping1">http://www.ping_service.com:9080/ping1</a> 接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; --connect-timeout 10 -m 20 http://www.ping_service.com:9080/ping1<br>ping1_A<br>===================================================<br>   time_namelookup: 0.005903s<br>      time_connect: 0.006257s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.006287s<br>time_starttransfer: 2.015412s<br>    speed_download: 3byte/s<br>---------------------------------------------------<br>        time_total: 2.015588s<br>===================================================<br><br><br>curl -w &quot;@curl_format.txt&quot; --connect-timeout 10 -m 20 http://www.ping_service.com:9080/ping1<br>ping1_B<br>===================================================<br>   time_namelookup: 0.005980s<br>      time_connect: 0.006373s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.006407s<br>time_starttransfer: 0.019240s<br>    speed_download: 359byte/s<br>---------------------------------------------------<br>        time_total: 0.019460s<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>可见<strong>连接超时配置不起效果</strong>，但不排除是curl的–connect-timeout设置问题，但是用chrome请求浏览器依然复现此问题；</li><li>有1个节点失效后会轮询到下一节点尝试，间隔时间2s，但不会自动摘除；</li></ul></li><li><p>对这个异常场景，官方是有解决方案的，这时添加节点<strong>健康检查</strong>配置</p><ul><li><p>先来看<a href="https://apisix.apache.org/zh/docs/apisix/2.13/health-check/#upstream-%E7%9A%84%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5">官方说明</a>的描述</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">Apache APISIX 的健康检查使用 lua-resty-healthcheck 实现。<br><br>注意:<br>- 只有在 upstream 被请求时才会开始健康检查，如果 upstream 被配置但没有被请求，不会触发启动健康检查。<br>- 如果没有健康的节点，那么请求会继续发送给上游。<br>- 如果 upstream 中只有一个节点时不会触发启动健康检查，该唯一节点无论是否健康，请求都将转发给上游。<br>- 主动健康检查是必须的，这样不健康的节点才会恢复。<br></code></pre></td></tr></table></figure></li><li><p><strong>首先这里有个疑问？为什么节点组只能配一个节点的监控检查？</strong></p><ul><li>查阅<a href="https://apisix.apache.org/zh/docs/apisix/2.13/health-check/#%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B">官方文档</a>示例后，解除疑惑，原来端口不是必填项，所以这个场景只需要填写域名即可；如果包含多ip的情况，host填写域名即可；</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;active&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;concurrency&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;healthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">302</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;successes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;http_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/check&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;unhealthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">429</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">404</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">501</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">502</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">503</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">504</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">505</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tcp_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;timeouts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    ......<br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>在9103服务的代码中添加&#x2F;check接口</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">http.HandleFunc(<span class="hljs-string">&quot;/check&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>    log.Println(time.Now().Format(time.RFC3339Nano))<br>    _, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;ok&quot;</span>))<br>&#125;)<br></code></pre></td></tr></table></figure><ul><li>请求关停服务的&#x2F;check接口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; 192.168.4.72:9103/check<br>ok<br>===================================================<br>   time_namelookup: 0.000054s<br>      time_connect: 0.000686s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.000729s<br>time_starttransfer: 0.001069s<br>    speed_download: 1657byte/s<br>---------------------------------------------------<br>        time_total: 0.001207s<br>         http_code: 500<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>持续请求网关的&#x2F;ping1接口<ul><li>观察到的现象是首次请求到9103时会等待超时，且触发监控检查，如官方描述：<strong>监控检查需要有请求时才触发</strong>，验证<strong>健康检查-异常节点摘除</strong>功能正常；</li><li>15秒后请求不再打到9103节点，请求响应时间恢复正常；</li><li>重启9103节点服务，会收到2次&#x2F;check请求，然后恢复接收&#x2F;ping1请求，验证<strong>健康检查-异常节点恢复</strong>功能正常；</li></ul></li></ul><h4 id="1-4-2-HTTP响应超时"><a href="#1-4-2-HTTP响应超时" class="headerlink" title="1.4.2. HTTP响应超时"></a>1.4.2. HTTP响应超时</h4><ul><li>写一个简单的超时接口</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/time_out&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">20</span>)  <span class="hljs-comment">// 20秒返回</span><br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;time_out&quot;</span>))<br>&#125;)<br>http.ListenAndServe(<span class="hljs-string">&quot;:9120&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>先直接请求到超时服务查看结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; 127.0.0.1:9120/time_out<br>time_out<br>===================================================<br>   time_namelookup: 0.000055s<br>      time_connect: 0.000654s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.000696s<br>time_starttransfer: 20.003177s<br>    speed_download: 0byte/s<br>---------------------------------------------------<br>        time_total: 20.003387s<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>在APISIX配置一组上游节点+路由配置，提供超时测试</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/*&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;time_out路由&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425650610830837553&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9120</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;time_out接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求APISIX接口路由</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; http://192.168.142.129:9080/time_out<br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;504 Gateway Time-out&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;center&gt;&lt;h1&gt;504 Gateway Time-out&lt;/h1&gt;&lt;/center&gt;<br>&lt;hr&gt;&lt;center&gt;openresty&lt;/center&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br>===================================================<br>   time_namelookup: 0.000056s<br>      time_connect: 0.000833s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.000876s<br>time_starttransfer: 10.147496s<br>    speed_download: 16byte/s<br>---------------------------------------------------<br>        time_total: 10.149126s<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>验证配置响应超时时间有效</li></ul><h2 id="2-插件基础"><a href="#2-插件基础" class="headerlink" title="2. 插件基础"></a>2. 插件基础</h2><h3 id="2-1-插件作用域"><a href="#2-1-插件作用域" class="headerlink" title="2.1. 插件作用域"></a>2.1. 插件作用域</h3><h4 id="2-1-1-全局插件"><a href="#2-1-1-全局插件" class="headerlink" title="2.1.1. 全局插件"></a>2.1.1. 全局插件</h4><ul><li><p>顾名思义该插件组全局生效，前提是已经搭建好prometheus+grafana与apisix的监控环境</p></li><li><p>复用1.3中的既有配置</p></li><li><p>添加prometheus全局插件</p></li><li><p>连续请求 <a href="http://www.test_service.com:9080/test1">http://www.test_service.com:9080/test1</a> 接口观察请求数涨幅</p><p><img src="screenshot-20220915-165429.png"></p></li></ul><h4 id="2-1-2-局部插件"><a href="#2-1-2-局部插件" class="headerlink" title="2.1.2. 局部插件"></a>2.1.2. 局部插件</h4><ul><li>顾名思义该插件只在绑定的局部链路下生效</li><li>局部插件可以在 <strong>路由&#x2F;服务&#x2F;消费者</strong> 中绑定<ul><li>多个<strong>路由</strong>可以绑定同一个<strong>服务</strong>，避免相同的插件组需要在多个路由中重复配置</li><li><strong>消费者</strong>控制权限类插件的能力，<strong>路由</strong>控制权限类插件是否在本路由生效，因此<strong>消费者</strong>与<strong>路由</strong>无直接绑定关系</li></ul></li></ul><h3 id="2-2-插件类型"><a href="#2-2-插件类型" class="headerlink" title="2.2. 插件类型"></a>2.2. 插件类型</h3><h4 id="2-2-1-路由流控"><a href="#2-2-1-路由流控" class="headerlink" title="2.2.1. 路由流控"></a>2.2.1. 路由流控</h4><ul><li><strong>窗口时间请求数限制</strong></li><li>复用1.3中的既有路由配置，绑定**<a href="https://apisix.apache.org/zh/docs/apisix/2.13/plugins/limit-count/">limit-count</a>**插件，窗口时间为1s，限制请求数2，设置如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;limit-count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;allow_degradation&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;count&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 窗口期内最大请求数</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;key_type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;var&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 可以设置针对header中的某个key(如remote_addr)来实现针对单个ip的流控</span><br>        <span class="hljs-attr">&quot;policy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;local&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// 计数器被以内存方式保存在节点本地，默认选项;这个插件支持使用Redis集群，从而可以跨节点共享结果，通常用它来完成全局限速</span><br>        <span class="hljs-attr">&quot;rejected_code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">503</span><span class="hljs-punctuation">,</span>  <span class="hljs-comment">// 超量后返回http-status-code</span><br>        <span class="hljs-attr">&quot;show_limit_quota_header&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// http-header是否携带流控信息</span><br>        <span class="hljs-attr">&quot;time_window&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span>  <span class="hljs-comment">// 窗口时间(s)</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>快速连续请求 <a href="http://www.ping_service.com:9080/ping1">http://www.ping_service.com:9080/ping1</a> 接口得到如下结果：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -I http://www.ping_service.com:9080/ping1  <br>HTTP/1.1 200 OK                                   <br>Content-Type: text/plain; charset=utf-8           <br>Content-Length: 7                                 <br>Connection: keep-alive                            <br>X-RateLimit-Limit: 2      # 限制2个请求<br>X-RateLimit-Remaining: 1  # 剩余放通请求数<br>Date: Fri, 16 Sep 2022 10:01:07 GMT               <br>Server: APISIX/2.13.3                             <br><br>curl -I http://www.ping_service.com:9080/ping1  <br>HTTP/1.1 200 OK                                   <br>Content-Type: text/plain; charset=utf-8           <br>Content-Length: 7                                 <br>Connection: keep-alive                            <br>X-RateLimit-Limit: 2      # 限制2个请求<br>X-RateLimit-Remaining: 0  # 剩余放通请求数<br>Date: Fri, 16 Sep 2022 10:01:07 GMT               <br>Server: APISIX/2.13.3<br><br>curl -I http://www.ping_service.com:9080/ping1  <br>HTTP/1.1 503 Service Temporarily Unavailable  # 超量返回预设错误码<br>Date: Fri, 16 Sep 2022 10:01:07 GMT<br>Content-Type: text/html; charset=utf-8            <br>Content-Length: 194                               <br>Connection: keep-alive<br>Server: APISIX/2.13.3<br></code></pre></td></tr></table></figure><h4 id="2-2-2-黑白名单"><a href="#2-2-2-黑白名单" class="headerlink" title="2.2.2. 黑白名单"></a>2.2.2. 黑白名单</h4><ul><li><p>包含多个插件，当前以最常用的 ip黑名单 测试</p></li><li><p>复用1.3中的既有路由配置，绑定**<a href="https://apisix.apache.org/zh/docs/apisix/plugins/ip-restriction/">ip-restriction</a>**插件，设置如下：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;ip-restriction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Do you want to do something bad?&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 自定义返回信息</span><br>    <span class="hljs-attr">&quot;whitelist&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;127.0.0.1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;192.168.4.72&quot;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求接口结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -I http://www.ping_service.com:9080/ping1<br>HTTP/1.1 403 Forbidden<br>Date: Mon, 19 Sep 2022 09:08:44 GMT<br>Content-Type: text/plain; charset=utf-8<br>Connection: keep-alive<br>Server: APISIX/2.15.0<br><br>curl http://www.ping_service.com:9080/ping1<br>&#123;&quot;message&quot;:&quot;Do you want to do something bad?&quot;&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-3-登录鉴权"><a href="#2-2-3-登录鉴权" class="headerlink" title="2.2.3. 登录鉴权"></a>2.2.3. 登录鉴权</h4><ul><li><p>包含多种登录态校验插件，当前以最常用的 jwt 测试</p></li><li><p>配置消费者，配置**<a href="https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/">jwt</a>**插件</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;jwt_test&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;jwt-auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;exp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">86400</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;data&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;secret&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>复用1.3中的既有路由配置，绑定**<a href="https://apisix.apache.org/zh/docs/apisix/plugins/jwt-auth/">jwt</a>**插件，设置如下：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;jwt-auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-comment">// ......</span><br></code></pre></td></tr></table></figure><ul><li>尝试不携带 jwt-token 信息请求</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -w &quot;@curl_format.txt&quot; http://www.ping_service.com:9080/ping1<br>&#123;&quot;message&quot;:&quot;Missing JWT token in request&quot;&#125;<br><br>===================================================<br>   time_namelookup: 0.006392s<br>      time_connect: 0.006845s<br>   time_appconnect: 0.000000s<br>  time_pretransfer: 0.006875s<br>time_starttransfer: 0.007312s<br>    speed_download: 5687byte/s<br>---------------------------------------------------<br>        time_total: 0.007560s<br>         http_code: 401<br>===================================================<br></code></pre></td></tr></table></figure><ul><li>尝试携带 jwt-token 信息（使用url参数携带）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://www.ping_service.com:9080/ping1?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJkYXRh IjpbXSwiaWF0IjoxNjYzNTgxMTExLCJleHAiOjE2NjM1ODQ1OTksImF1ZCI6IiIsImlzcyI6IiIsInN1YiI6IiJ9.nMskTlYVx2PbHDcELnchdDBgespNT_bX3ikTWoQ6X6U<br>ping1_A<br></code></pre></td></tr></table></figure><h4 id="2-2-4-镜像请求"><a href="#2-2-4-镜像请求" class="headerlink" title="2.2.4. 镜像请求"></a>2.2.4. 镜像请求</h4><ul><li>代理镜像插件，该插件提供了镜像客户端请求的能力。</li><li>修改 &#x2F;test 的路由插件配置：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;proxy-mirror&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://192.168.4.72:9104&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sample_ratio&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0.01</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>修改 &#x2F;test 的上游只保留一个节点：</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><ul><li>在 9104 节点可以获取到**1%**的请求量</li></ul><h2 id="3-进阶能力"><a href="#3-进阶能力" class="headerlink" title="3. 进阶能力"></a>3. 进阶能力</h2><h3 id="3-1-金丝雀-灰度-发布"><a href="#3-1-金丝雀-灰度-发布" class="headerlink" title="3.1. 金丝雀(灰度)发布"></a>3.1. 金丝雀(灰度)发布</h3><h4 id="3-1-1-编写简单的批量发送测试客户端"><a href="#3-1-1-编写简单的批量发送测试客户端" class="headerlink" title="3.1.1. 编写简单的批量发送测试客户端"></a>3.1.1. 编写简单的批量发送测试客户端</h4><ul><li>利用http-header中的uid进行流量划分，实现恢复发布</li><li>uid范围[0-19]，方便观察</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">splitReqs</span><span class="hljs-params">(src []*http.Request, size <span class="hljs-type">int</span>)</span></span> [][]*http.Request &#123;<br><span class="hljs-keyword">if</span> src == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> [][]*http.Request&#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> (<br>j      <span class="hljs-type">int</span><br>length = <span class="hljs-built_in">len</span>(src)<br>res    = <span class="hljs-built_in">make</span>([][]*http.Request, <span class="hljs-number">0</span>)<br>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; length; i += size &#123;<br>j += size<br><span class="hljs-keyword">if</span> j &gt; length &#123;<br>j = length<br>&#125;<br>res = <span class="hljs-built_in">append</span>(res, src[i:j])<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newClient</span><span class="hljs-params">()</span></span> *http.Client &#123;<br><span class="hljs-keyword">return</span> &amp;http.Client&#123;<br>Transport: &amp;http.Transport&#123;<br>DialContext: (&amp;net.Dialer&#123;<br>Timeout:   <span class="hljs-number">30</span> * time.Second,<br>KeepAlive: <span class="hljs-number">30</span> * time.Second,<br>&#125;).DialContext,<br>MaxIdleConns:          <span class="hljs-number">100</span>,<br>IdleConnTimeout:       <span class="hljs-number">90</span> * time.Second,<br>TLSHandshakeTimeout:   <span class="hljs-number">10</span> * time.Second,<br>ExpectContinueTimeout: <span class="hljs-number">1</span> * time.Second,<br>&#125;,<br>Timeout: <span class="hljs-number">30</span> * time.Second,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>url, tmpCount := os.Args[<span class="hljs-number">1</span>], os.Args[<span class="hljs-number">2</span>]<br>count, err := strconv.ParseInt(tmpCount, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>client := newClient()<br>reqs := <span class="hljs-built_in">make</span>([]*http.Request, <span class="hljs-number">0</span>, count)<br>userCount := <span class="hljs-number">20</span><br><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-type">int</span>(count); j++ &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; userCount; i++ &#123;<br>req, err := http.NewRequest(http.MethodGet, url, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br>header := http.Header&#123;&#125;<br>header.Add(<span class="hljs-string">&quot;uid&quot;</span>, strconv.Itoa(i))<br>req.Header = header<br><br>reqs = <span class="hljs-built_in">append</span>(reqs, req)<br>&#125;<br>&#125;<br><br>reqsGroup := splitReqs(reqs, userCount)<br><span class="hljs-keyword">for</span> _, subReqs := <span class="hljs-keyword">range</span> reqsGroup &#123;<br>w := sync.WaitGroup&#123;&#125;<br>w.Add(<span class="hljs-built_in">len</span>(subReqs))<br><br><span class="hljs-keyword">for</span> _, req := <span class="hljs-keyword">range</span> subReqs &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r *http.Request)</span></span> &#123;<br>_, err := client.Do(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>w.Done()<br>&#125;(req)<br>&#125;<br>w.Wait()<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="3-1-2-方案一"><a href="#3-1-2-方案一" class="headerlink" title="3.1.2. 方案一"></a>3.1.2. 方案一</h4><ul><li><p><strong>一致性哈希均衡负载+权重</strong></p></li><li><p>修改 &#x2F;test1 的上游配置，使用一致性哈希均衡负载</p><ul><li>9101~9103节点权重设置：3</li><li>9104节点权重设置：1（灰度节点）</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9102</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9104</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;chash&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hash_on&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;header&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;uid&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ping接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ......</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="screenshot-20220920-114408.png"></p><ul><li><p>请求 &#x2F;test1 接口，查看各服务日志</p><ul><li>9101节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br>2022/09/20 11:40:41 test1_A | uid: 5 <br>2022/09/20 11:40:41 test1_A | uid: 13<br></code></pre></td></tr></table></figure><ul><li>9102节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 17<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 2 <br>2022/09/20 11:40:41 test1_B | uid: 19<br>2022/09/20 11:40:41 test1_B | uid: 19<br>2022/09/20 11:40:41 test1_B | uid: 2 <br>2022/09/20 11:40:41 test1_B | uid: 17<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 2 <br>2022/09/20 11:40:41 test1_B | uid: 19<br>2022/09/20 11:40:41 test1_B | uid: 12<br>2022/09/20 11:40:41 test1_B | uid: 17<br></code></pre></td></tr></table></figure><ul><li>9103节点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs she">......<br>2022/09/20 11:40:41 test1_C | uid: 18<br>2022/09/20 11:40:41 test1_C | uid: 10<br>2022/09/20 11:40:41 test1_C | uid: 11<br>2022/09/20 11:40:41 test1_C | uid: 18<br>2022/09/20 11:40:41 test1_C | uid: 1<br>2022/09/20 11:40:41 test1_C | uid: 7<br>2022/09/20 11:40:41 test1_C | uid: 9<br>2022/09/20 11:40:41 test1_C | uid: 10<br>2022/09/20 11:40:41 test1_C | uid: 4<br>2022/09/20 11:40:41 test1_C | uid: 3<br>2022/09/20 11:40:41 test1_C | uid: 11<br>2022/09/20 11:40:41 test1_C | uid: 6<br>2022/09/20 11:40:41 test1_C | uid: 15<br>2022/09/20 11:40:41 test1_C | uid: 14<br></code></pre></td></tr></table></figure><ul><li>9104节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 8<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 0<br>2022/09/20 11:40:41 test1_D | uid: 16<br>2022/09/20 11:40:41 test1_D | uid: 8<br></code></pre></td></tr></table></figure></li><li><p>接下来把配置摘到2个节点：</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9104</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// ......</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>得到了正常的流量分配，9104节点的请求信息如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">......<br>2022/09/20 13:38:32 test1_D | uid: 16<br>2022/09/20 13:38:32 test1_D | uid: 8<br>2022/09/20 13:38:32 test1_D | uid: 16<br>2022/09/20 13:38:32 test1_D | uid: 16<br>2022/09/20 13:38:32 test1_D | uid: 8<br>2022/09/20 13:38:32 test1_D | uid: 8<br>2022/09/20 13:38:32 test1_D | uid: 16<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong><ul><li><p>使用一致性哈希均衡负载进行灰度发布，<strong>权重不生效</strong>；</p></li><li><p>如果开启健康检查，触发节点摘除的场景，因为节点数量变化，流量有可能会被分到非灰度节点，<strong>流量不稳定</strong>；</p></li><li><p>如果结合k8s对上游节点进行均衡负载，即上游节点其实为k8s均衡负载服务，则<strong>可以规避上述问题</strong>，但会增加一层转发损耗；</p></li><li><p>在测试过程中，添加&#x2F;删除&#x2F;修改路由节点，对请求的响应率没有可见性的影响；</p></li></ul></li></ul><h4 id="3-1-3-方案二-推荐"><a href="#3-1-3-方案二-推荐" class="headerlink" title="3.1.3. 方案二(推荐)"></a>3.1.3. 方案二(推荐)</h4><ul><li><p><strong>traffic-split插件</strong></p></li><li><p>修改 <strong>test接口组</strong> 上游配置中的节点数量为2个：9101、9102</p></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9101</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;active&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;concurrency&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;healthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">302</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;successes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;http_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/check&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;unhealthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">429</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">404</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">501</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">502</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">503</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">504</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">505</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tcp_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;timeouts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>新增 <strong>test接口组（灰度）</strong> 上游配置中的节点数量为2个：9103、9104</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;nodes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9103</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9104</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;connect&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;send&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;read&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;roundrobin&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;active&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;concurrency&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;healthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">200</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">302</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;successes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;192.168.4.72&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;http_path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/check&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;unhealthy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;http_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;http_statuses&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-number">429</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">404</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">500</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">501</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">502</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">503</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">504</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-number">505</span><br>                <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;tcp_failures&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;timeouts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;scheme&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;pass_host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;pass&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口组（灰度）&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;keepalive_pool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;idle_timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">60</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;requests&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1000</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">320</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="screenshot-20220920-154757.png"></p><ul><li>在 &#x2F;test 路由组配置traffic-split插件，上游425605109443987249与上游426356608394594097的流量比例为9:1</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/test*&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;test接口路由组2&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;methods&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;GET&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;POST&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PUT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;DELETE&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;PATCH&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;HEAD&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;OPTIONS&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;CONNECT&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-string">&quot;TRACE&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;www.test_service.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;traffic-split&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;weighted_upstreams&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">9</span><br>                        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;426356608394594097&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;API_VERSION&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;v1&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li><p>使用3.1.1的批量发送工具发送100个请求测试流量分布</p><ul><li>9101和9102节点各接收到45个请求</li><li>9103和9104节点个接收到5个请求</li><li><strong>符合分流权重配置要求</strong></li><li>因为没有配置匹配规则，因此<strong>流量是随机划分</strong>的</li></ul></li><li><p>加入匹配规则控制灰度用户流量精准投递到灰度节点</p><ul><li>匹配规则插件文档：<a href="https://github.com/api7/lua-resty-expr#operator-list">lua-resty-expr</a></li></ul><table><thead><tr><th>operator</th><th>description</th><th>example</th></tr></thead><tbody><tr><td>&#x3D;&#x3D;</td><td>equal</td><td>{“arg_name”, “&#x3D;&#x3D;”, “json”}</td></tr><tr><td>~&#x3D;</td><td>not equal</td><td>{“arg_name”, “~&#x3D;”, “json”}</td></tr><tr><td>&gt;</td><td>greater than</td><td>{“arg_age”, “&gt;”, 24}</td></tr><tr><td>&lt;</td><td>less than</td><td>{“arg_age”, “&lt;”, 24}</td></tr><tr><td>~~</td><td>Regular match</td><td>{“arg_name”, “~~”, “[a-z]+”}</td></tr><tr><td>~*</td><td>Case insensitive regular match</td><td>{“arg_name”, “~*”, “[a-z]+”}</td></tr><tr><td>in</td><td>find in array</td><td>{“arg_name”, “in”, {“1”,”2”}}</td></tr><tr><td>has</td><td>left value array has value in the right</td><td>{“graphql_root_fields”, “has”, “repo”}</td></tr><tr><td>!</td><td>reverse the result</td><td>{“arg_name”, “!”, “~~”, “[a-z]+”}</td></tr><tr><td>ipmatch</td><td>ip address match</td><td>{“remote_addr”, “ipmatch”, {“127.0.0.1”, “192.168.0.0&#x2F;16”}}</td></tr></tbody></table><ul><li>修改 &#x2F;test 路由配置，使用正则表达式过滤出uid尾号为0的请求分配到灰度上游</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;traffic-split&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;vars&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                                <span class="hljs-punctuation">[</span><br>                                    <span class="hljs-string">&quot;http_uid&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;~~&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;[0$]&quot;</span><br>                                <span class="hljs-punctuation">]</span><br>                            <span class="hljs-punctuation">]</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;weighted_upstreams&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                        <span class="hljs-punctuation">&#123;</span><br>                            <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;426356608394594097&quot;</span><span class="hljs-punctuation">,</span><br>                            <span class="hljs-attr">&quot;weight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><br>                        <span class="hljs-punctuation">&#125;</span><br>                    <span class="hljs-punctuation">]</span><br>                <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">]</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;upstream_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;425605109443987249&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>使用3.1.1的批量发送工具发送100个请求测试流量分布</p><ul><li>尾号为0的uid全部分流到9103、9104节点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 10<br>2022/09/20 16:56:27 test1_C | uid: 0<br>2022/09/20 16:56:28 test1_C | uid: 10<br>2022/09/20 16:56:28 test1_C | uid: 0<br>2022/09/20 16:56:28 test1_C | uid: 10<br></code></pre></td></tr></table></figure></li><li><p><strong>结论：</strong></p><ul><li>使用<strong>traffic-split插件</strong>进行灰度发布符合业务要求</li><li>插件对上游配置无侵入性修改，修改、删除灰度分流只需要改动路由插件配置或关停插件</li></ul></li></ul><h3 id="3-2-插件开发"><a href="#3-2-插件开发" class="headerlink" title="3.2. 插件开发"></a>3.2. 插件开发</h3><ul><li><p>开发自定义插件分<strong>lua插件</strong>与<strong>外部插件</strong>，<strong>新增、修改、删除插件均不支持热加载</strong></p></li><li><p>lua插件调用方式为内部调用；</p><ul><li>lua插件开发思路参考：**<a href="https://apisix.apache.org/zh/docs/apisix/plugin-develop/">插件开发</a>**</li></ul></li><li><p>扩展插件调用方式为RPC调用；</p><ul><li>外部插件按执行时序分三类，见：**<a href="https://apisix.apache.org/zh/docs/apisix/external-plugin/">External Plugin</a>**</li><li><strong>插件稳定性需要进一步测试，不建议立即使用</strong></li><li>RPC通信配置需要提前协商配置，避免后续需要重启APISIX</li></ul></li></ul><h4 id="3-2-1-外部插件-Go"><a href="#3-2-1-外部插件-Go" class="headerlink" title="3.2.1. 外部插件-Go"></a>3.2.1. 外部插件-Go</h4><ul><li><p>Go插件：<a href="https://github.com/apache/apisix-go-plugin-runner"><strong>apisix-go-plugin-runner</strong></a></p></li><li><p>下载插件源码release-0.4版本–&gt;编译–&gt;复制到APISIX的docker容器中</p></li><li><p>修改APISIX配置文件：config.yaml，在末尾追加以下内容</p><ul><li>另一种外部插件加载方式，在下一小节使用</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ext-plugin:</span><br>  <span class="hljs-attr">cmd:</span> [<span class="hljs-string">&quot;/usr/local/apisix/plugins/go-runner&quot;</span>, <span class="hljs-string">&quot;run&quot;</span>]<br></code></pre></td></tr></table></figure><ul><li>重启APISIX容器，查看APISIX启动日志，已显示有加载Go插件的日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022-09-21T05:56:42.968ZINFOplugin/plugin.go:73register plugin limit-req<br>2022-09-21T05:56:42.968ZINFOplugin/plugin.go:73register plugin response-rewrite<br>2022-09-21T05:56:42.968ZINFOplugin/plugin.go:73register plugin say<br>2022-09-21T05:56:42.968ZWARNserver/server.go:185conf cache ttl is 1h12m0s<br>2022-09-21T05:56:42.968ZWARNserver/server.go:193listening to /usr/local/apisix/conf/apisix-46.sock<br></code></pre></td></tr></table></figure><ul><li>复用1.3中的路由配置，将插件配置为 say 插件<ul><li><strong>注意：外部插件无法像内部插件一样生成插件图标显示在Dashboard的列表中</strong></li><li><strong>顺带一提：使用服务配置外部插件，绑定到上游，不生效</strong></li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ext-plugin-post-req&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;conf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;say&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&#123;\&quot;body\&quot;:\&quot;hello\&quot;&#125;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求 &#x2F;ping1 接口</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">curl.exe http<span class="hljs-punctuation">:</span><span class="hljs-comment">//www.ping_service.com:9080/ping1</span><br>hello<br></code></pre></td></tr></table></figure><ul><li><strong>结论：</strong><ul><li>外部插件<strong>不支持冷加载</strong></li><li>外部插件只能通过修改json格式配置项方式控制</li><li>外部插件在服务配置中不生效</li></ul></li></ul><h4 id="3-2-2-自定义外部插件-Go"><a href="#3-2-2-自定义外部插件-Go" class="headerlink" title="3.2.2. 自定义外部插件-Go"></a>3.2.2. 自定义外部插件-Go</h4><ul><li>修改Go插件：<a href="https://github.com/apache/apisix-go-plugin-runner"><strong>apisix-go-plugin-runner</strong></a></li><li>添加以下文件：cmd&#x2F;go-runner&#x2F;plugins&#x2F;header_rewrite.go</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> plugins<br><br><span class="hljs-keyword">import</span> (<br>pkgHTTP <span class="hljs-string">&quot;github.com/apache/apisix-go-plugin-runner/pkg/http&quot;</span><br><span class="hljs-string">&quot;github.com/apache/apisix-go-plugin-runner/pkg/log&quot;</span><br><span class="hljs-string">&quot;github.com/apache/apisix-go-plugin-runner/pkg/plugin&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>err := plugin.RegisterPlugin(&amp;HeaderRewrite&#123;&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;failed to register plugin header_rewrite: %s&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// HeaderRewrite 意于重写http请求头</span><br><span class="hljs-keyword">type</span> HeaderRewrite <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// Embed the default plugin here,</span><br><span class="hljs-comment">// so that we don&#x27;t need to reimplement all the methods.</span><br>plugin.DefaultPlugin<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HeaderRewrite)</span></span> Name() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;header_rewrite&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HeaderRewrite)</span></span> ParseConf(in []<span class="hljs-type">byte</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *HeaderRewrite)</span></span> RequestFilter(conf <span class="hljs-keyword">interface</span>&#123;&#125;, w http.ResponseWriter, r pkgHTTP.Request) &#123;<br>r.Header().Set(<span class="hljs-string">&quot;X-GO-PLUGIN-TEST&quot;</span>, <span class="hljs-string">&quot;OK&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>编译</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make build<br></code></pre></td></tr></table></figure><ul><li>修改APISIX配置config.yaml</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">ext-plugin<span class="hljs-punctuation">:</span><br>  path_for_test<span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/tmp/x.sock&quot;</span><br></code></pre></td></tr></table></figure><ul><li>重启APISIX</li><li>添加环境变量</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export APISIX_LISTEN_ADDRESS=unix:/tmp/x.sock<br></code></pre></td></tr></table></figure><ul><li>运行go-runner</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json">./go-runner run &amp;<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin fault-injection<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin header_rewrite<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin limit-req<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin response-rewrite<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZINFOplugin/plugin.go<span class="hljs-punctuation">:</span><span class="hljs-number">73</span>register plugin say<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZWARNserver/server.go<span class="hljs-punctuation">:</span><span class="hljs-number">185</span>conf cache ttl is <span class="hljs-number">1</span>h12m0s<br><span class="hljs-number">2022</span><span class="hljs-number">-09</span><span class="hljs-number">-21</span>T08<span class="hljs-punctuation">:</span><span class="hljs-number">58</span><span class="hljs-punctuation">:</span><span class="hljs-number">56.798</span>ZWARNserver/server.go<span class="hljs-punctuation">:</span><span class="hljs-number">193</span>listening to /tmp/x.sock<br></code></pre></td></tr></table></figure><ul><li>复用1.3中的路由配置，将插件配置为 header_rewrite 插件<ul><li><strong>注意：外部插件无法像内部插件一样生成插件图标显示在Dashboard的列表中</strong></li><li><strong>顺带一提：使用服务配置外部插件，绑定到上游，不生效</strong></li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;plugins&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ext-plugin-post-req&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;conf&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;header_rewrite&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;disable&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ul><li>请求 &#x2F;ping2 接口</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl.exe http://www.ping_service.com:9080/ping2<br></code></pre></td></tr></table></figure><ul><li>在 9101 中得到req-header，包含X-Go-Plugin-Test:[OK]</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/09/21 17:10:43 ping2_A | header: map[Accept:[*/*] User-Agent:[curl/7.83.1] X-Forwarded-For:[192.168.142.1] X-Forwarded-Host:[www.ping_service.com] X-Forwarded-Port:[9080] X-Forwarded-Proto:[http] X-Go-Plugin-Test:[OK] X-Real-Ip:[192.168.142.1]]<br></code></pre></td></tr></table></figure><ul><li>插件日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022-09-21T09:08:02.491ZINFOserver/server.go:108Client connected (unix)<br>2022-09-21T09:08:02.491ZINFOserver/server.go:124receive rpc type: 2 data length: 228<br>2022-09-21T09:08:02.491ZINFOplugin/plugin.go:120run plugin header_rewrite<br></code></pre></td></tr></table></figure><ul><li>模拟插件异常，杀死go-runner进程</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022-09-21T09:14:50.430ZWARNserver/server.go:245server receive terminated and exit<br></code></pre></td></tr></table></figure><ul><li>再次请求 &#x2F;ping2 接口，返回503。查看APISIX日志</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">2022/09/21 09:15:28 [warn] 47#47: *38406 [lua] plugin.lua:901: run_plugin(): ext-plugin-post-req exits with http status code 503, client: 192.168.142.1, server: _, request: &quot;GET /ping2 HTTP/1.1&quot;, host: &quot;www.ping_service.com:9080&quot;<br>2022/09/21 09:15:28 [crit] 47#47: *38424 connect() to unix:/tmp/x.sock failed (2: No such file or directory), client: 192.168.142.1, server: _, request: &quot;GET /ping2 HTTP/1.1&quot;, host: &quot;www.ping_service.com:9080&quot;<br>2022/09/21 09:15:28 [error] 47#47: *38424 [lua] init.lua:841: phase_func(): failed to connect to the unix socket unix:/tmp/x.sock: no such file or directory, client: 192.168.142.1, server: _, request: &quot;GET /ping2 HTTP/1.1&quot;, host: &quot;www.ping_service.com:9080&quot;<br></code></pre></td></tr></table></figure><ul><li>重启go-runner，请求成功</li><li><strong>结论：</strong><ul><li>第一次配置外部插件时不支持热加载</li><li>go-runner进程必须有验活机制</li><li>在服务配置中不生效</li></ul></li></ul><h3 id="3-3-数据监控"><a href="#3-3-数据监控" class="headerlink" title="3.3. 数据监控"></a>3.3. 数据监控</h3><h4 id="3-3-1-采集-amp-观测"><a href="#3-3-1-采集-amp-观测" class="headerlink" title="3.3.1. 采集&amp;观测"></a>3.3.1. 采集&amp;观测</h4><ul><li>使用 Prometheus + Grafana 组合</li></ul><h4 id="3-3-2-指标"><a href="#3-3-2-指标" class="headerlink" title="3.3.2. 指标"></a>3.3.2. 指标</h4><p><img src="screenshot-20220923-182911.png"></p><h4 id="3-3-3-模拟测试"><a href="#3-3-3-模拟测试" class="headerlink" title="3.3.3. 模拟测试"></a>3.3.3. 模拟测试</h4><ul><li><strong>前提条件</strong><ul><li>1000RPS</li><li>请求到上文中<strong>test接口路由组2</strong>-ID：<strong>425637854408869681</strong></li></ul></li><li><strong>Nginx数据视窗</strong><ul><li>从请求速率一项可以看到RPS为1000</li></ul></li></ul><p><img src="screenshot-20220923-175134.png"></p><ul><li><strong>带宽视窗</strong><ul><li>从route一项可以看到 ID：425637854408869681 的带宽情况</li></ul></li></ul><p><img src="screenshot-20220923-175530.png"></p><ul><li><strong>HTTP视窗</strong><ul><li>可以看到开始请求的一瞬间延迟是最大</li><li>P90指标与P95指标很直观表现出链路延迟值</li></ul></li></ul><p><img src="image-20220923175909631.png"></p><ul><li><strong>Misc视窗</strong><ul><li>可以看到Etcd等组件的活跃情况</li></ul></li></ul><p><img src="screenshot-20220923-180357.png"></p><h4 id="3-3-4-告警"><a href="#3-3-4-告警" class="headerlink" title="3.3.4. 告警"></a>3.3.4. 告警</h4><ul><li>可以利用 Prometheus - AlertManager 的能力进行触发，此处不演示</li></ul>]]></content>
    
    
    <categories>
      
      <category>apisix</category>
      
    </categories>
    
    
    <tags>
      
      <tag>apisix</tag>
      
      <tag>网关</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-Error处理</title>
    <link href="/2022/05/23/golang/error/"/>
    <url>/2022/05/23/golang/error/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-Error处理"><a href="#Golang-Error处理" class="headerlink" title="Golang-Error处理"></a>Golang-Error处理</h1><p align="right">Lamber</p><p align="right">2022-05-23</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇基于GO 1.17版本代码进行阐释。</p><p>写过C&#x2F;C++的伙伴应该印象深刻，C&#x2F;C++的”错误”是围绕”错误码”定义的，比如C语言使用errno(一个整型)来表示错误及传达错误信息，常见的以-1表示。</p><p>这种设计导致了这个问题：</p><ul><li>当触发的错误所处的代码层级较深，且错误码又与其他类型错误相同时：编码者为了避免错误码被混淆，会在底层进行大量的错误码映射，直到将错误信息精妙地传递到展示层；或者直接将错误吞没不处理，打印错误日志；又或直接中断程序。</li></ul><p>体会到C语言处理错误的复杂性和不可控问题，GO号称提供了拓展性极强的错误处理方式，将错误处理的方式：</p><ul><li>抛给设计程序者自己去决策与处理<del>（可以说是摆烂吗？）</del>。</li></ul><p>GO面对致命性异常也不再像C程序一样需要分析core dump文件，而使用panic输出尽可能多的信息帮助开发者定位问题，本篇不涉及panic的内容。</p><p>那么GO的”error”关键字到底是什么？它为什么具备拓展性？又带来了什么问题？又是如何利用GO的error设计思想去解决问题的？</p><h2 id="1-关键字”error”"><a href="#1-关键字”error”" class="headerlink" title="1.  关键字”error”"></a>1.  关键字”error”</h2><h3 id="1-1-error是什么？"><a href="#1-1-error是什么？" class="headerlink" title="1.1. error是什么？"></a>1.1. error是什么？</h3><ul><li><strong>error 关键字是一个接口类型</strong></li></ul><blockquote><p>摘自 Go&#x2F;src&#x2F;builtin&#x2F;builtin.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The error built-in interface type is the conventional interface for</span><br><span class="hljs-comment">// representing an error condition, with the nil value representing no error.</span><br><span class="hljs-comment">// 内置接口类型是表示错误情况的常规接口，nil 值表示没有错误。</span><br><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从接口方法 <code>Error() string</code> 可以看出，它仅仅表示用一个字符串就能诠释的错误，它能满足基本编码的需要吗？</p><p>我们带着疑问往下探索GO官方提供的两种error实现：<code>errorString</code> 与 <code>wrapError</code>。</p><h3 id="1-2-errorString"><a href="#1-2-errorString" class="headerlink" title="1.2. errorString"></a>1.2. errorString</h3><p>乍一看，可能会有些陌生。</p><p>其实，它正是errors包对error接口的实现，想起各种教程中提及的 <code>errors.New()</code> 了吗？</p><ul><li><strong>errorString 是error接口的一种实现</strong> (也是官方提供的最基础的实现)</li></ul><blockquote><p>摘自 Go&#x2F;src&#x2F;errors&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-comment">// Each call to New returns a distinct error value even if the text is identical.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p>errorString 本身极其简单，仅仅实现了 error接口 的基础能力：保存一个错误描述字符串，并能将其输出，没有然后。</p><p>这种设计仅仅能满足与简单的业务场景，或简短的demo；如果在中型项目中使用errorString，可以想象到每次使用字符串作错误判断依据的痛苦吧？</p><p>但存在即是合理，它有它的优势：足够轻量级（吧？）。</p><h3 id="1-3-Wrap"><a href="#1-3-Wrap" class="headerlink" title="1.3. Wrap()"></a>1.3. Wrap()</h3><p>顾名思义，包裹error，即把目标error包裹到新error内部。</p><p>官方的 <code>fmt.Errorf()</code> 支持这种能力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Errorf 根据格式说明符进行格式化，并将字符串作为满足错误的值返回。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>p := newPrinter()<br>p.wrapErrs = <span class="hljs-literal">true</span><br>p.doPrintf(format, a)  <span class="hljs-comment">// &lt;--这一步会判断format中是否包含%w占位符，如果有就将入参err赋值给wrappedErr，且%w占位符只能存在一个。</span><br>s := <span class="hljs-type">string</span>(p.buf)<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> &#123;<br>err = errors.New(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = &amp;wrapError&#123;s, p.wrappedErr&#125;  <span class="hljs-comment">// 包裹error并返回新error</span><br>&#125;<br>p.free()<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> &#123;<br>msg <span class="hljs-type">string</span><br>err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> e.err<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>可以看以下示例：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorWrap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err1 := errors.New(<span class="hljs-string">&quot;error-1&quot;</span>)<br>err2 := fmt.Errorf(<span class="hljs-string">&quot;error-2. %w&quot;</span>, err1)<br>err3 := fmt.Errorf(<span class="hljs-string">&quot;error-3. %w&quot;</span>, err2)<br><br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err1)<br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err2)<br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err3)<br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorWrap</span><br><span class="hljs-comment">//     emoji_test.go:70: &amp;errors.errorString&#123;s:&quot;error-1&quot;&#125;</span><br><span class="hljs-comment">//     emoji_test.go:71: &amp;fmt.wrapError&#123;msg:&quot;error-2. error-1&quot;, err:(*errors.errorString)(0xc000088fc0)&#125;</span><br><span class="hljs-comment">//     emoji_test.go:72: &amp;fmt.wrapError&#123;msg:&quot;error-3. error-2. error-1&quot;, err:(*fmt.wrapError)(0xc0001cf540)&#125;</span><br><span class="hljs-comment">// --- PASS: TestErrorWrap (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><ul><li><p>fmt包的作者依然为多次嵌套error提供了反解能力：</p><ul><li><p>使用 <strong>%w占位符</strong> 表达err时，会将传入的error保存到 wrapError 内部的err变量中；</p></li><li><p>实现了 <strong>Unwrap()</strong> 方法，使得通过 fmt.Errorf() 方法包裹的原始err可以在外部进行比对及反解（Unwrap下一小节记录）。</p></li></ul></li><li><p>但需要注意几点：</p><ul><li><p>必须使用%w占位符才生效，否则fmt.Errorf内部将创建一个新的errors.errorString保存错误信息；</p></li><li><p>当%w个数&gt;1时，多出的占位符对应的err不会生效；</p></li><li><p>传入的err没有实现Unwrap()方法不生效；</p></li></ul></li></ul><h3 id="1-4-Unwrap"><a href="#1-4-Unwrap" class="headerlink" title="1.4. Unwrap()"></a>1.4. Unwrap()</h3><p>除了吐槽官方偷懒之外，errors包的另一个文件wrap.go，被许多开源库借鉴，主要是提供多个解决error多重嵌产物的方法。</p><ul><li><strong>Unwrap() 反解嵌套error</strong> ，即取出本error中包裹的error。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unwrap</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-comment">// 判断这个error的实现类是否实现了Unwrap()方法</span><br>u, ok := err.(<span class="hljs-keyword">interface</span> &#123;<br>Unwrap() <span class="hljs-type">error</span><br>&#125;)<br>    <span class="hljs-comment">// 没有实现直接返回nil</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br>    <span class="hljs-comment">// 有实现就调用实现类的Unwrap方法</span><br><span class="hljs-keyword">return</span> u.Unwrap()<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是： <strong>Unwrap()</strong> 方法不属于 Error-Interface 的抽象方法，即error的”实现类”不一定要实现这个方法。</p><ul><li>要满足反解error嵌套的能力，error的”实现类” 必须实现 <strong>Unwrap(error) error</strong>  方法，如上一节提到的<code>wrapError</code>。</li></ul><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorUnwrap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err1 := errors.New(<span class="hljs-string">&quot;error-1&quot;</span>)<br>err2 := fmt.Errorf(<span class="hljs-string">&quot;error-2. %w&quot;</span>, err1)<br>err3 := fmt.Errorf(<span class="hljs-string">&quot;error-3. %w&quot;</span>, err2)<br><br>t.Log(err3)<br><span class="hljs-keyword">for</span> e := err3; e != <span class="hljs-literal">nil</span>; &#123;<br>e = errors.Unwrap(e)<br>t.Log(e)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorUnwrap</span><br><span class="hljs-comment">//     emoji_test.go:80: error-3. error-2. error-1</span><br><span class="hljs-comment">//     emoji_test.go:83: error-2. error-1</span><br><span class="hljs-comment">//     emoji_test.go:83: error-1</span><br><span class="hljs-comment">//     emoji_test.go:83: &lt;nil&gt;</span><br><span class="hljs-comment">// --- PASS: TestErrorUnwrap (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Is-x2F-As"><a href="#1-5-Is-x2F-As" class="headerlink" title="1.5. Is()&#x2F;As()"></a>1.5. Is()&#x2F;As()</h3><p>作者想到开发者可能会将error多层嵌套，即形成error链，如err1–&gt;err2–&gt;err3逐层包裹，于是官方提供了下面2个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Is</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>......<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">As</span><span class="hljs-params">(err, target <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>......<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>Is()</strong> 可以判断在error嵌套链中是否存在目标error的实例，即error实例的&#x3D;&#x3D;运算：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> derrors <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorIs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> (<br>err1 = errors.New(<span class="hljs-string">&quot;xx&quot;</span>)<br>err2 = errors.New(<span class="hljs-string">&quot;xx&quot;</span>)<br>)<br>    err := derrors.Wrap(err1, <span class="hljs-string">&quot;yy&quot;</span>)<br>err = fmt.Errorf(<span class="hljs-string">&quot;%w&quot;</span>, err)  <span class="hljs-comment">// 这里error包裹链：wrapError--&gt;wrapMessage--&gt;proto.RedisError</span><br>    t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err3)<br><br><span class="hljs-keyword">var</span> err2 = errors.New(<span class="hljs-string">&quot;xx&quot;</span>) <span class="hljs-comment">// 新建一个stringError实例</span><br><br>t.Log(errors.Is(err, err1))<br>    t.Log(errors.Is(err, err2)) <span class="hljs-comment">// 即使err2与err1内容一致，但输出结果为false，证实Is()对比的是实例本身</span><br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorIs</span><br><span class="hljs-comment">//     version_test.go:67: &amp;fmt.wrapError&#123;msg:&quot;yy: xx&quot;, err:(*errors.withStack)(0xc00009cb88)&#125;</span><br><span class="hljs-comment">//     version_test.go:71: true</span><br><span class="hljs-comment">//     version_test.go:72: false</span><br><span class="hljs-comment">// --- PASS: TestErrorIs (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><ul><li><strong>As()</strong> 可以判断目标error的实例类型是否存在与error嵌套链中：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> derrors <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestErrorAs</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>err1 := errors.New(<span class="hljs-string">&quot;xx&quot;</span>)<br>err2 := derrors.Wrap(err1, <span class="hljs-string">&quot;yy&quot;</span>)<br>err3 := fmt.Errorf(<span class="hljs-string">&quot;%w&quot;</span>, err2)<br>t.Logf(<span class="hljs-string">&quot;%#v&quot;</span>, err3)<br><br><span class="hljs-keyword">var</span> (<br>a = errors.New(<span class="hljs-string">&quot;xyz&quot;</span>)<br>b = derrors.New(<span class="hljs-string">&quot;123&quot;</span>)<br>)<br>t.Log(errors.As(err3, &amp;a)) <span class="hljs-comment">// 纵使a与b内容与err3嵌套链中不一致，但实例类型一致，因此可以检查出err3嵌套链中是否包含目标类型的error</span><br>t.Log(errors.As(err3, &amp;b))<br>&#125;<br><br><span class="hljs-comment">// === RUN   TestErrorAs</span><br><span class="hljs-comment">//     version_test.go:79: &amp;fmt.wrapError&#123;msg:&quot;yy: xx&quot;, err:(*errors.withStack)(0xc00009cb88)&#125;</span><br><span class="hljs-comment">//     version_test.go:85: true</span><br><span class="hljs-comment">//     version_test.go:86: true</span><br><span class="hljs-comment">// --- PASS: TestErrorAs (0.00s)</span><br><span class="hljs-comment">// PASS</span><br></code></pre></td></tr></table></figure><ul><li>当然，这两个方法的实现内部都需要调用 <strong>Unwrap()</strong> 。</li></ul><h3 id="1-6-error接口有什么问题？"><a href="#1-6-error接口有什么问题？" class="headerlink" title="1.6. error接口有什么问题？"></a>1.6. error接口有什么问题？</h3><p>综合 1.1 ~ 1.3 小节，可以总结出官方提供的 <code>errorString</code> 存在的问题：</p><ul><li><p>只保存了简单的字符串信息，无法追溯错误发生的源头；</p></li><li><p>或需要煞费苦心地对比错误的字符串内容是否为自己所需的，才能进行下一步业务操作；</p></li><li><p>为了代码的健壮性考虑，函数返回的每一个错误，都不能忽略；</p><ul><li>因为按GO的编码习惯，当返回参数包含err非nil时，很可能返回一个nil的对象；此时如果不对err进行判断，很可能会引发panic；这就使得代码中error出现的频率非常高，显得非常冗长。</li></ul><p>下面是常见的代码示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := doSomething1(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理error</span><br>&#125;<br><span class="hljs-keyword">if</span> err := doSomething2(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理error</span><br>&#125;<br><span class="hljs-keyword">if</span> err := doSomething3(); err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理error</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种处理方式像极了C语言中的处理，显得非常冗长。</p><p>于是就有人会抱怨起来，为什么GO不使用高级语言中的try..catch..finally机制去处理错误？</p><p>在官方的FAQ中已经有解释：<a href="https://golang.google.cn/doc/faq">https://golang.google.cn/doc/faq</a></p><blockquote><p><strong>Why does Go not have exceptions?</strong></p><p>We believe that coupling exceptions to a control structure, as in the <code>try-catch-finally</code> idiom, results in convoluted code. It also tends to encourage programmers to label too many ordinary errors, such as failing to open a file, as exceptional.</p><p>Go takes a different approach. For plain error handling, Go’s multi-value returns make it easy to report an error without overloading the return value. <a href="https://golang.google.cn/doc/articles/error_handling.html">A canonical error type, coupled with Go’s other features</a>, makes error handling pleasant but quite different from that in other languages.</p><p>Go also has a couple of built-in functions to signal and recover from truly exceptional conditions. The recovery mechanism is executed only as part of a function’s state being torn down after an error, which is sufficient to handle catastrophe but requires no extra control structures and, when used well, can result in clean error-handling code.</p><p>See the <a href="https://golang.google.cn/doc/articles/defer_panic_recover.html">Defer, Panic, and Recover</a> article for details. Also, the <a href="https://blog.golang.org/errors-are-values">Errors are values</a> blog post describes one approach to handling errors cleanly in Go by demonstrating that, since errors are just values, the full power of Go can be deployed in error handling.</p></blockquote><blockquote><p><strong>为什么 Go 没有异常？</strong></p><p>我们相信将异常耦合到控制结构中，就像在<code>try-catch-finally</code>成语中一样，会导致代码复杂。它还倾向于鼓励程序员将太多的普通错误（例如无法打开文件）标记为异常。</p><p>Go 采用了不同的方法。对于简单的错误处理，Go 的多值返回可以很容易地报告错误而不会重载返回值。 <a href="https://golang.google.cn/doc/articles/error_handling.html">规范的错误类型，加上 Go 的其他特性</a>，使得错误处理令人愉快，但与其他语言中的错误处理完全不同。</p><p>Go 还有一些内置函数可以发出信号并从真正的异常情况中恢复。恢复机制仅作为函数状态的一部分在错误后被拆除，这足以处理灾难但不需要额外的控制结构，并且如果使用得当，可以产生干净的错误处理代码。</p><p>有关详细信息，请参阅<a href="https://golang.google.cn/doc/articles/defer_panic_recover.html">延迟、恐慌和恢复</a>文章。此外，<a href="https://blog.golang.org/errors-are-values">Errors are values</a>博客文章描述了一种在 Go 中干净地处理错误的方法，通过演示，由于错误只是值，因此可以在错误处理中部署 Go 的全部功能。</p></blockquote><p>​</p><p>GO设计者之一 Russ Cox 也解释过同样的问题：<a href="https://studygolang.com/articles/1674">https://studygolang.com/articles/1674</a></p><blockquote><p>Go是为编写大型软件而设计的。我们喜欢让程序保持简洁，而不是为大量程序员编写的大型程序不断投入维护成本。基于异常的错误处理的一个诱惑是，对于小的程序它工作得很好。但是在一个庞大的代码库里，对于每一行代码，每一个普通的操作，都需要考虑它们是否会触发一个需要处理的异常。这对于生产效率和工程时间是个很大的拖累。我自己在编写大型Python程序时就遇到这样的问题。必须承认，Go语言里函数返回错误对于调用者来说并不方便，但它们很明白地表明了程序和类型系统里发生错误的可能性。当遇到函数返回错误时，小程序可能只想打印出错误然后退出程序；但是更精心设计的程序通常会根据不同的错误来源作出不同的处理。在这种情况，try和catch的处理方式会比显式的错误返回值处理更冗长。虽然Python语言的10行代码用Go语言来实现确实可能会更冗长，但是，Go语言的首要目标不是编写10行代码的程序。</p></blockquote><p>从客观的角度来讲，GO在error处理的设计上有弊有利；从我主观的角度来讲，对于弊，只是大多参与到GO项目的编写者因为保留了第一语言的习惯，使用GO有所不适罢了。比较认同上文的一句话：</p><blockquote><p>虽然Python语言的10行代码用Go语言来实现确实可能会更冗长，但是，Go语言的首要目标不是编写10行代码的程序。</p></blockquote></li></ul><p>综上，也只是阐述了官方提供的error包的两种实现，得益于error接口本身的设计，具备良好的拓展性，可以灵活地实现所需。</p><p>然而灵活性也带来了多样性，从而给处理众多实现各异三方库中的error时带来了相当的复杂性。</p><p>再往下探究，官方如何引导GO使用者学习error的设计思想，又如何优雅地处理error。</p><h2 id="2-处理error"><a href="#2-处理error" class="headerlink" title="2. 处理error"></a>2. 处理error</h2><blockquote><p><strong>Don’t just check errors, handle them gracefully</strong>  </p><p>– Dave Cheney</p><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p></blockquote><p>不要只检查错误，要优雅地处理它们。</p><h3 id="2-1-Errors-are-just-values"><a href="#2-1-Errors-are-just-values" class="headerlink" title="2.1. Errors are just values"></a>2.1. Errors are just values</h3><p>错误只是值，或者这样理解——把错误视为值。</p><p>这本身有很多故事，这里只做部分举例与阐明结论，想知道详细故事请自行查看相关的GoCon。</p><p>Rob Pike 在 2015.1.12 发了一篇博客，回应 2014 年秋季在东京举行的 GoCon 中提及error处理的问题；</p><p>标题为Errors are values：<a href="https://go.dev/blog/errors-are-values%E3%80%82">https://go.dev/blog/errors-are-values。</a></p><p>文末总结：</p><blockquote><p>然而，关键的教训是错误是值，Go 编程语言的有足够能力去处理它们。</p><p>使用本语言来简化您的错误处理。</p><p>但请记住：无论您做什么，都要检查您的错误！</p></blockquote><p>Dave Cheney 为 2016.4.23 在日本举行的 GoCon 针对error的论述做了记录：</p><blockquote><p>我花了很多时间思考在 Go 程序中处理错误的最佳方法。我真的希望有一种单一的方法来进行错误处理，我们可以死记硬背地教所有 Go 程序员，就像我们可以教数学或字母表一样。 </p><p>但是，我得出的结论是，没有单一的方法可以处理错误。相反，我认为 Go 的错误处理可以分为三个核心策略。</p></blockquote><p>我们往下逐一分析这三种核心策略：</p><ul><li><p><strong>Sentinel errors</strong> —— 哨兵错误</p></li><li><p><strong>Error types</strong> —— 错误类型化</p></li><li><p><strong>Opaque errors</strong> —— 不透明的错误（”黑盒”错误）</p></li></ul><h4 id="2-1-1-Sentinel-errors"><a href="#2-1-1-Sentinel-errors" class="headerlink" title="2.1.1. Sentinel errors"></a>2.1.1. Sentinel errors</h4><blockquote><p>哨兵错误，应该理解为：哨兵值，无论是否有错误，基本上都是特殊的、预定义的值，您认为这些值可能是特定上下文中特定进程的结果。</p><p>使用哨兵值是最不灵活的错误处理策略，因为调用者必须使用相等运算符将结果与预先声明的值进行比较。当您想提供更多上下文时，这会出现问题，因为返回不同的错误会破坏相等性检查。</p><p>甚至像使用<code>fmt.Errorf</code>为错误添加一些上下文一样有意义的东西也会破坏调用者的相等性测试。相反，调用者将被迫查看 <code>error.Error()</code> 方法的输出以查看它是否与特定字符串匹配。</p></blockquote><p>Dave Cheney总结了 <strong>Sentinel errors</strong> 的三项关键特征：</p><ul><li><strong>永远不要检查 error.Error() 的输出</strong></li><li><strong>哨兵错误成为公共 API 的一部分</strong></li><li><strong>哨兵错误在两个包之间创建依赖关系</strong></li></ul><p>原文的措辞与例子可能比较抽象，我就用更接地气的示例，由上到下逐一分析这些特征并展开这些特征带来的问题。</p><ul><li><strong>永远不要检查 error.Error() 的输出</strong></li></ul><blockquote><p>对于这句话，我的理解是：永远不要通过校验 error.Error() 的输出作为错误判断的预期依据</p></blockquote><p>为什么如此绝对？我们可以反过来想，什么情况下才要检查error.Error()的输出（文本信息）？</p><p>在下面例子中有直观感受</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...... <span class="hljs-comment">// 执行了步骤1</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤1执行异常&quot;</span>)<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤2</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤2执行异常&quot;</span>)<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤3</span><br>    ...... <span class="hljs-comment">// 以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在需要新增一个逻辑，doSomething() ；当步骤1执行异常后，执行逻辑A，当步骤2执行异常后，执行逻辑B….；你只能按如下相似的代码判断：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">()</span></span> &#123;<br>    err := doSomething()<br>    <span class="hljs-keyword">switch</span> err.Error() &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;步骤1执行异常&quot;</span>:<br>        doPlanA()<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;步骤2执行异常&quot;</span>:<br>        doPlanB()<br>    <span class="hljs-keyword">case</span> .....<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OK，代码执行起来没问题，但是对于后面维护的人来说真是日了狗了，有下面两种场景：</p><ul><li><p>如果需要使用 doSomething() 这个方法，就需要去准确判断该方法返回的所有错误；</p></li><li><p>如果这个 doSomething() 被多处代码引用，后面的维护人不能轻易修改错误描述，否则外部判断需要同时准确修正；</p></li></ul><p>当人有人会提出使用常量去定义错误描述，那又可以看看下面这种情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...... <span class="hljs-comment">// 执行了步骤1</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤1执行异常&quot;</span>)<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤2</span><br>    <span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;步骤2执行异常&quot;</span>)<br>    <br>    x := getRandom()<br>    ...... <span class="hljs-comment">// 执行了步骤3</span><br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;步骤3执行异常. 随机值: %s&quot;</span>, x)<br>    <br>    <span class="hljs-comment">// 以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>请问步骤3异常的情况怎么判断呢？还能用常量吗？然后又会有人提出，可以截取前半段字符串匹配啊。这就只会在错误的路上越走越远，然后暗暗骂一句，GO处理错误的方式真垃圾！</p><p>好了，看到这里相信你已经可以理解为什么 <strong>永远不要校验 error.Error() 的输出</strong>。</p><p>在官方的源码中，可以发现有不少局部使用 errors.New() 定义的error并作为返参，但这些error不是逻辑错误，大多为系统级别触发的error。</p><p>也就是说在绝大多数场景下，开发者并不需要判断错误的文本内容，而是需要根据错误信息来获知服务之外的，如MySQL表数据写入失败、第三方接口异常等不可预知的问题。</p><p>在这种前提下，局部地返回纯文本error是可以被理解的，如下面这个示例：</p><blockquote><p> 摘自Go&#x2F;src&#x2F;log&#x2F;syslog&#x2F;syslog_unix.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// unixSyslog opens a connection to the syslog daemon running on the</span><br><span class="hljs-comment">// local machine using a Unix domain socket.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">unixSyslog</span><span class="hljs-params">()</span></span> (conn serverConn, err <span class="hljs-type">error</span>) &#123;<br>logTypes := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;unixgram&quot;</span>, <span class="hljs-string">&quot;unix&quot;</span>&#125;<br>logPaths := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;/dev/log&quot;</span>, <span class="hljs-string">&quot;/var/run/syslog&quot;</span>, <span class="hljs-string">&quot;/var/run/log&quot;</span>&#125;<br><span class="hljs-keyword">for</span> _, network := <span class="hljs-keyword">range</span> logTypes &#123;<br><span class="hljs-keyword">for</span> _, path := <span class="hljs-keyword">range</span> logPaths &#123;<br>conn, err := net.Dial(network, path)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> &amp;netConn&#123;conn: conn, local: <span class="hljs-literal">true</span>&#125;, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;Unix syslog delivery error&quot;</span>)  <span class="hljs-comment">// &lt;-- 如果出错，只需要知道这个func内部发生错误，并知道错误信息即可，并不需要根据错误信息来进行逻辑分支处理。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>那如果前同事写了类似上文 <strong>doSomething()</strong> 的代码，怎么解困呢？</p><p>我们来看下GO官方包内部是怎么处理这种问题的：</p><blockquote><p>摘自Go&#x2F;src&#x2F;io&#x2F;io.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>摘自Go&#x2F;src&#x2F;fmt&#x2F;scan.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *stringReader)</span></span> Read(b []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>n = <span class="hljs-built_in">copy</span>(b, *r)<br>*r = (*r)[n:]<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br>err = io.EOF  <span class="hljs-comment">// 注意这里，返回了一个io.EOF错误，该使用了标记值错误</span><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>摘自Go&#x2F;src&#x2F;io&#x2F;io.go，当我们判断这个EOF时，需要判断这个error是否为 io.EOF</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadAll</span><span class="hljs-params">(r Reader)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>......<br><span class="hljs-keyword">for</span> &#123;<br>......<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err == EOF &#123;  <span class="hljs-comment">// 这里直接使用==运算符对比error是否为io.EOF</span><br>err = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> b, err<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到这里如释重负，我们可以把整个错误提取出来作为全局变量提供外部包使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">Step1Err := errors.New(<span class="hljs-string">&quot;步骤1执行异常&quot;</span>)<br>Step2Err := errors.New(<span class="hljs-string">&quot;步骤2执行异常&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    ...... <span class="hljs-comment">// 执行了步骤1</span><br>    <span class="hljs-keyword">return</span> Step1Err<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤2</span><br>    <span class="hljs-keyword">return</span> Step2Err<br>    <br>    ...... <span class="hljs-comment">// 执行了步骤3</span><br>    ...... <span class="hljs-comment">// 以此类推</span><br>&#125;<br></code></pre></td></tr></table></figure><p>但这种全局化的做法同时带来了另外一些问题：</p><ul><li><strong>一种错误描述对应一个全局变量，并定义在包头，增加了包的”厚度”，显得代码比较冗余；</strong></li><li><strong>其他包想使用该包内的方法时，需要绑定使用该包的错误，如果该错误的传递层次较多，那么最外部文件中还需要import该包；</strong><ul><li><strong>如果一个逻辑包含了多个使用sentinel errors的包，那么需要把它们都import一遍进行判断，这会使得需要import的包非常多；</strong></li></ul></li></ul><p>以上两点一一对应了Dave Cheney总结 <strong>Sentinel errors</strong> 的后两种特征：</p><ul><li><p><strong>哨兵错误成为公共 API 的一部分</strong></p><ul><li>这个特征还有另外一个原因：使用了非实现error接口的值作为错误，这种做法很奇葩，违反error接口的根本设计理念，忽略</li></ul></li><li><p><strong>哨兵错误在两个包之间创建依赖关系</strong></p></li></ul><p>最终Dave Cheney也有自己对 <strong>Sentinel errors</strong> 的使用结论：</p><blockquote><p><strong>Conclusion: avoid sentinel errors</strong></p><p>So, my advice is to avoid using sentinel error values in the code you write. There are a few cases where they are used in the standard library, but this is not a pattern that you should emulate.</p><p>If someone asks you to export an error value from your package, you should politely decline and instead suggest an alternative method, such as the ones I will discuss next.</p></blockquote><blockquote><p>结论：避免哨兵错误 </p><p>因此，我的建议是避免在您编写的代码中使用哨兵错误。在标准库中使用它们的情况很少，但这不是您应该效仿的模式。 </p><p>如果有人要求你从你的包中导出一个错误值，你应该礼貌地拒绝，而是建议一种替代方法，比如我将在下面讨论的方法。</p></blockquote><p>认真阅读本文的小可爱一定还记得上文  <strong>doSomething()</strong> 示例中还存在 带变参 的错误没有得到解决，这种错误是没办法通过全局变量的方式替换的。需要使用Dave Cheney提到的第二种核心策略：<strong>Error types</strong>。</p><h4 id="2-1-2-Error-types"><a href="#2-1-2-Error-types" class="headerlink" title="2.1.2. Error types"></a>2.1.2. Error types</h4><blockquote><p>错误类型是指实现错误接口的类型。</p></blockquote><p>它的一个重要的好处是，类型中除了异常文本描述之外，还可以附带其他字段，从而提供额外的信息。</p><p>我们以官方包的<strong>PathError</strong>举例：</p><blockquote><p>摘自Go&#x2F;src&#x2F;io&#x2F;fs&#x2F;fs.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// PathError records an error and the operation and file path that caused it.</span><br><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>Op   <span class="hljs-type">string</span><br>Path <span class="hljs-type">string</span><br>Err  <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error() &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> e.Err &#125;<br><br><span class="hljs-comment">// Timeout reports whether this error represents a timeout.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Timeout() <span class="hljs-type">bool</span> &#123;<br>t, ok := e.Err.(<span class="hljs-keyword">interface</span>&#123; Timeout() <span class="hljs-type">bool</span> &#125;)<br><span class="hljs-keyword">return</span> ok &amp;&amp; t.Timeout()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>PathError</strong> 能够记录出错时的文件路径与操作类型。外层业务逻辑可以使用类型断言来判断错误：</p><blockquote><p>摘自Go&#x2F;src&#x2F;cmd&#x2F;go&#x2F;internal&#x2F;lockedfile&#x2F;internal&#x2F;filelock&#x2F;filelock.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// underlyingError returns the underlying error for known os error types.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">underlyingError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *fs.PathError:<br><span class="hljs-keyword">return</span> err.Err<br><span class="hljs-keyword">case</span> *os.LinkError:<br><span class="hljs-keyword">return</span> err.Err<br><span class="hljs-keyword">case</span> *os.SyscallError:<br><span class="hljs-keyword">return</span> err.Err<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>但这种也存在以下问题：</p><ul><li><strong>该接口的所有实现者都需要依赖于定义错误类型的包。</strong></li><li><strong>创建与调用时都是与类型强耦合，降低了API的灵活性。</strong>（这句话可能描述得有点抽象，大白话是：如<strong>PathError</strong>一样的结构虽然实现了error接口，但其创建时仍然是直接返回指针对象，而不是一个error接口，还是对开发者有心智负担）</li></ul><p>最终Dave Cheney也有自己对 <strong>Error types</strong> 的使用结论：</p><blockquote><p><strong>Conclusion: avoid error types</strong></p><p>While error types are better than sentinel error values, because they can capture more context about what went wrong, error types share many of the problems of error values.</p><p>So again my advice is to avoid error types, or at least, avoid making them part of your public API.</p><p>结论：避免错误类型</p><p>虽然错误类型比哨兵错误更好，因为它们可以捕获更多关于出错的上下文，但错误类型仍然携带着需要导包等问题。</p><p>所以我的建议是避免错误类型，或者至少避免将它们作为公共 API 的一部分。</p></blockquote><p>最后Dave Cheney提出了一种终极方案：<strong>Opaque errors</strong>，下面我们来分析一下<strong>Opaque errors</strong>到底有多神。</p><h4 id="2-1-3-Opaque-errors"><a href="#2-1-3-Opaque-errors" class="headerlink" title="2.1.3. Opaque errors"></a>2.1.3. Opaque errors</h4><blockquote><p>现在我们来到第三类错误处理。在我看来，这是最灵活的错误处理策略，因为它需要您的代码和调用者之间的耦合最少。</p><p>我将这种风格称为不透明错误处理，因为当您知道发生了错误时，您无法查看错误内部。作为调用者，您所知道的关于操作结果的所有信息都是它有效，或者它没有。</p><p>这就是不透明错误处理的全部内容——只需返回错误而不假设其内容。如果您采用这种立场，那么错误处理作为调试辅助工具会变得更加有用。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> “github.com/quux/bar”<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        x, err := bar.Foo()<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-comment">// use x</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就是 <strong>Opaque errors</strong> 的策略，作为调用方，只需要知道 Foo 是否正常执行，一旦err不为空，直接返回错误；</p><p>但在真实场景中，调用的三方库会非常多，复杂的业务中难免会遇到根据err来走不同逻辑分支的情形。这时候，光有Foo已经不够用，需要一种方法获知错误是否具备某种行为，而不需要判断错误类型是什么：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> temporary <span class="hljs-keyword">interface</span> &#123;<br>        Temporary() <span class="hljs-type">bool</span><br>&#125;<br> <br><span class="hljs-comment">// IsTemporary returns true if err is temporary.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsTemporary</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>        te, ok := err.(temporary)<br>        <span class="hljs-keyword">return</span> ok &amp;&amp; te.Temporary()<br>&#125;<br></code></pre></td></tr></table></figure><p>这么做的好处是：</p><ul><li><strong>业务层不需要import具体类型的包；</strong></li><li><strong>业务层不需要知道error的内部类型，再进行具体错误原因的对比；而是直接判断接口是否具备某种行为；</strong></li></ul><p>这种设计方式，也被称为<strong>面向接口编程</strong>。</p><h3 id="2-2-Don’t-just-check-errors-handle-them-gracefully"><a href="#2-2-Don’t-just-check-errors-handle-them-gracefully" class="headerlink" title="2.2. Don’t just check errors, handle them gracefully"></a>2.2. Don’t just check errors, handle them gracefully</h3><p>检查并优雅地处理错误，这是本篇的重点内容。</p><h4 id="2-2-1-避免冗长的错误处理代码"><a href="#2-2-1-避免冗长的错误处理代码" class="headerlink" title="2.2.1. 避免冗长的错误处理代码"></a>2.2.1. 避免冗长的错误处理代码</h4><p>Dave Cheney在<a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">[3]</a>中给出一个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        err := authenticate(r.User)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>很明显代码可以简化到如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AuthenticateRequest</span><span class="hljs-params">(r *Request)</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">return</span> authenticate(r.User)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是最基本的应对措施。</p><h4 id="2-2-2-携带堆栈信息"><a href="#2-2-2-携带堆栈信息" class="headerlink" title="2.2.2. 携带堆栈信息"></a>2.2.2. 携带堆栈信息</h4><p>尽管代码足够简约，返回的error信息还是太贫瘠，仅包含一个字符串形式的信息，例如它是：**”No such file or directory”**。</p><p>当错误产生在代码层次较深时，我们根本不知道这个错误来自于哪里？？？</p><p>如果错误中能携带堆栈信息，就能解决这一困境。</p><p>这就不得不说一个具有启蒙意义的第三方包：**”github.com&#x2F;pkg&#x2F;errors”**，一个携带有堆栈信息的错误管理包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// New 使用提供的消息返回错误。</span><br><span class="hljs-comment">// New 还会记录调用时的堆栈跟踪。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(message <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;fundamental&#123;<br>msg:   message,<br>stack: callers(),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Errorf 根据格式说明符进行格式化，并将字符串作为满足错误的值返回。</span><br><span class="hljs-comment">// Errorf 还会记录调用时的堆栈跟踪。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;fundamental&#123;<br>msg:   fmt.Sprintf(format, args...),<br>stack: callers(),<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// fundamental是一个错误，它有一个消息和一个堆栈，但没有调用者。</span><br><span class="hljs-keyword">type</span> fundamental <span class="hljs-keyword">struct</span> &#123;<br>msg <span class="hljs-type">string</span><br>*stack<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fundamental</strong> 结构包含堆栈信息 *<strong>stack</strong> 与自定义错误描述 <strong>msg</strong>，只要使用常规的 <strong>New</strong>() 与 <strong>Errorf()</strong> 新建error，就能记录当前位置的堆栈。</p><p>除此之外，<strong>fundamental</strong> 还提供了 **Format()**方法，实现了 <strong>Formatter</strong> 接口。使用 *<em>fmt.Printf(“%+v”, (<em>fundamental类型的error)</em></em> 时可以输出详细的堆栈信息。</p><blockquote><p>摘自Go&#x2F;src&#x2F;fmt&#x2F;print.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Formatter is implemented by any value that has a Format method.</span><br><span class="hljs-comment">// The implementation controls how State and rune are interpreted,</span><br><span class="hljs-comment">// and may call Sprint(f) or Fprint(f) etc. to generate its output.</span><br><span class="hljs-keyword">type</span> Formatter <span class="hljs-keyword">interface</span> &#123;<br>   Format(f State, verb <span class="hljs-type">rune</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>摘自pkg&#x2F;mod&#x2F;github.com&#x2F;pkg&#x2F;<a href="mailto:&#x65;&#x72;&#x72;&#x6f;&#x72;&#115;&#x40;&#x76;&#x30;&#46;&#57;&#46;&#49;">&#x65;&#x72;&#x72;&#x6f;&#x72;&#115;&#x40;&#x76;&#x30;&#46;&#57;&#46;&#49;</a>&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *fundamental)</span></span> Format(s fmt.State, verb <span class="hljs-type">rune</span>) &#123;<br><span class="hljs-keyword">switch</span> verb &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;v&#x27;</span>:<br><span class="hljs-keyword">if</span> s.Flag(<span class="hljs-string">&#x27;+&#x27;</span>) &#123;  <span class="hljs-comment">// &lt;---可以重点看这里的逻辑，进入这个分支可以输出详细的堆栈。</span><br>io.WriteString(s, f.msg)<br>f.stack.Format(s, verb)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">fallthrough</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>io.WriteString(s, f.msg)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;q&#x27;</span>:<br>fmt.Fprintf(s, <span class="hljs-string">&quot;%q&quot;</span>, f.msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">readfile.go:27: could not read config<br>readfile.go:14: open failed<br>open /Users/dfc/.settings.xml: no such file or directory<br></code></pre></td></tr></table></figure><p>这对于定位问题来说就简单多了，不需要反复重现或debug，就能直接知道问题的根源。</p><h4 id="2-2-3-嵌套error链"><a href="#2-2-3-嵌套error链" class="headerlink" title="2.2.3. 嵌套error链"></a>2.2.3. 嵌套error链</h4><p>在1.3小节我们提到过嵌套错误的问题。当业务流程中，需要携带的错误不止一个时，可以用嵌套error的方式实现。</p><p>**”github.com&#x2F;pkg&#x2F;errors”<strong>也有一套</strong>“包装”<strong>与</strong>“解包”**的方法</p><blockquote><p>摘自pkg&#x2F;mod&#x2F;github.com&#x2F;pkg&#x2F;<a href="mailto:&#101;&#114;&#x72;&#x6f;&#x72;&#115;&#64;&#118;&#48;&#x2e;&#x39;&#x2e;&#x31;">&#101;&#114;&#x72;&#x6f;&#x72;&#115;&#64;&#118;&#48;&#x2e;&#x39;&#x2e;&#x31;</a>&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WithStack 在调用 WithStack 时使用堆栈跟踪注释 err。</span><br><span class="hljs-comment">// 如果 err 为 nil，WithStack 返回 nil。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WithStack</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> &amp;withStack&#123;<br>err,<br>callers(),<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> withStack <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">error</span><br>*stack<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *withStack)</span></span> Cause() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> w.<span class="hljs-type">error</span> &#125;<br><br><span class="hljs-comment">// Unwrap 为 Go 1.13 错误链提供兼容性。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *withStack)</span></span> Unwrap() <span class="hljs-type">error</span> &#123; <span class="hljs-keyword">return</span> w.<span class="hljs-type">error</span> &#125;<br></code></pre></td></tr></table></figure><p>类似地，<strong>withStack</strong> 与 <strong>fundamental</strong> 提供了记录堆栈的能力，但扩展了一套 <strong>Cause()</strong> 与 <strong>WithStack()</strong> 方法，意于装载任意的错误，当必要时可以通过解包获取最内部的错误，或对比整个嵌套链的错误包含有业务场景关注的错误。</p><blockquote><p>摘自pkg&#x2F;mod&#x2F;github.com&#x2F;pkg&#x2F;<a href="mailto:&#101;&#114;&#x72;&#x6f;&#x72;&#x73;&#64;&#118;&#48;&#x2e;&#x39;&#46;&#49;">&#101;&#114;&#x72;&#x6f;&#x72;&#x73;&#64;&#118;&#48;&#x2e;&#x39;&#46;&#49;</a>&#x2F;errors.go</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 如果错误没有实现Cause，则返回原来的错误。如果错误为 nil，则将返回 nil 而无需进一步调查。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Cause</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">type</span> causer <span class="hljs-keyword">interface</span> &#123;<br>Cause() <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> &#123;<br>cause, ok := err.(causer)<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>err = cause.Cause()<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>这个 <strong>Cause()</strong> 方法是否与1.2小节中提到的 <strong>Unwrap()</strong> 很相像？其实在Go1.13版本前，是没有Unwrap()方法的，我们可以追溯到Go1.12最后一个发布版本的errors官方包代码，errors包下只有一个errors.go文件及其单元测试文件：</p><ul><li><p>摘自 <a href="https://github.com/golang/go/blob/go1.12.17/src/errors/errors.go">https://github.com/golang/go/blob/go1.12.17/src/errors/errors.go</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Copyright 2011 The Go Authors. All rights reserved.</span><br><span class="hljs-comment">// Use of this source code is governed by a BSD-style</span><br><span class="hljs-comment">// license that can be found in the LICENSE file.</span><br><br><span class="hljs-comment">// Package errors implements functions to manipulate errors.</span><br><span class="hljs-keyword">package</span> errors<br><br><span class="hljs-comment">// New returns an error that formats as the given text.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-comment">// errorString is a trivial implementation of error.</span><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>在Go1.13的第一个发布版本时，errors包下加入了wrap.go文件。<strong>Unwrap()</strong> 正式替代了 Cause() 方法。</p><p>有兴趣可以看：<a href="https://github.com/golang/go/blob/go1.13/src/errors/wrap.go">https://github.com/golang/go/blob/go1.13/src/errors/wrap.go</a></p><h3 id="2-3-Only-handle-errors-once"><a href="#2-3-Only-handle-errors-once" class="headerlink" title="2.3. Only handle errors once"></a>2.3. Only handle errors once</h3><blockquote><p>I want to mention that you should only handle errors once. Handling an error means inspecting the error value, and making a decision.</p><p>我想提一下，你应该只处理一次错误。处理错误意味着检查错误值并做出决定。</p></blockquote><h4 id="2-3-1-妥善处理每一个错误"><a href="#2-3-1-妥善处理每一个错误" class="headerlink" title="2.3.1. 妥善处理每一个错误"></a>2.3.1. 妥善处理每一个错误</h4><p>我们来看一下没处理错误的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Data)</span></span> ConvData(b []<span class="hljs-type">byte</span>) &#123;<br>    ...... <span class="hljs-comment">// 其他逻辑</span><br>    ......<br>    json.Unmarshal(b, d)   <span class="hljs-comment">// &lt;---此处直接吞掉了Unmarshal()的返回值error</span><br>    ......<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-comment">// 检查格式是否正确。</span><br><span class="hljs-comment">// 避免在发现 JSON 语法错误之前填写半个数据结构。</span><br><span class="hljs-keyword">var</span> d decodeState<br>err := checkValid(data, &amp;d.scan)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>d.init(data)<br><span class="hljs-keyword">return</span> d.unmarshal(v)<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个<strong>非常不好的习惯</strong>，当<strong>b</strong>的内容不是一个合法的json结构时，<strong>Unmarshal()</strong> 的错误没有被外层感知，调用 <strong>ConvData()</strong> 的开发者很可能认为内部不会发生错误，且在<strong>d</strong>在必须非空数据的业务场景时引发了业务错误，并且难以排查。</p><p>正如 Rob Pike 所说：**”But remember: Whatever you do, always check your errors!”**</p><p>但万事都有极端情况，当你非常确认该错误可以忽略时，请你用 <strong>_</strong> (下划线显式说明忽略该返回值)，起到一定的提示作用。</p><p>（goland编辑器针对隐式省略返回值的代码行也会进行高亮提示）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Data)</span></span> ConvData(b []<span class="hljs-type">byte</span>) &#123;<br>    _ = json.Unmarshal(b, d)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-只处理错误一次"><a href="#2-3-2-只处理错误一次" class="headerlink" title="2.3.2. 只处理错误一次"></a>2.3.2. 只处理错误一次</h4><p>针对一个错误做出多个决定也是有问题的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Write</span><span class="hljs-params">(w io.Writer, buf []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>        _, err := w.Write(buf)<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                <span class="hljs-comment">// 带注释的错误进入日志文件</span><br>                log.Println(<span class="hljs-string">&quot;unable to write:&quot;</span>, err)<br>            <br>                <span class="hljs-comment">// 未注释的错误返回给调用者</span><br>                <span class="hljs-keyword">return</span> err<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在此示例中，如果在 <code>Write</code> 期间发生错误，会将一行写入日志文件，记录发生错误的文件和行，并将错误也返回给上层。上层调用者可能也会记录日志并返回错误给上上层。最终，会在日志文件中得到一堆重复的行，但在最外层，仅仅得到一个没有任何上下文的原始错误。这样的日志会给排查问题的人带来疑惑，到底发生了几次错误呢？</p><p>因此推荐只处理错误一次。</p><h3 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4. 总结"></a>2.4. 总结</h3><p>最后，Dave Cheney给出了他的总结：</p><blockquote><p>In conclusion, errors are part of your package’s public API, treat them with as much care as you would any other part of your public API.</p><p>For maximum flexibility I recommend that you try to treat all errors as opaque. In the situations where you cannot do that, assert errors for behaviour, not type or value.</p><p>Minimise the number of sentinel error values in your program and convert errors to opaque errors by wrapping them with <code>errors.Wrap</code> as soon as they occur.</p><p>Finally, use <code>errors.Cause</code> to recover the underlying error if you need to inspect it.</p></blockquote><p>这些总结也成为了处理错误和设计自定义错误结构的准则：</p><ul><li><p><strong>首先，错误隶属于包中 公共API 的一部分，请像对待公共 API 的任何其他部分一样小心对待它们。</strong></p></li><li><p><strong>为了获得最大的灵活性，建议尝试将所有错误视为不透明的。在你不能这样做的情况下，断言错误的行为，而不是类型或值。</strong></p></li><li><p><strong>最大限度地减少程序中 Sentinel errors 的数量，并通过在错误发生时，立即使用<code>errors.Wrap</code>将其包装起来，将错误转换为 opaque errors。</strong></p></li><li><p><strong>最后，如果您需要检查错误原因，请使用<code>errors.Cause</code>来恢复底层错误。</strong></p></li></ul><p>最终，结合业务场景，目前已经诞生出非常多的自定义error结构方案，下面我们着重分析一下go-brick中的实现。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol><li><p><a href="https://golang.google.cn/doc/faq">https://golang.google.cn/doc/faq</a> [GO官方FAQ]</p></li><li><p><a href="https://studygolang.com/articles/1674">https://studygolang.com/articles/1674</a> [Russ Cox回应“Why I’m not leaving python for go”]</p></li><li><p><a href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully">https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a> [Dave Cheney阐述如何优雅处理error]</p></li><li><p><a href="https://go.dev/blog/errors-are-values">https://go.dev/blog/errors-are-values</a> [Rob Pike阐述错误处理思想]</p></li><li><p><a href="https://github.com/golang/go">https://github.com/golang/go</a> [go语言官方开源库]</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>error</tag>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-资源泄露</title>
    <link href="/2022/05/09/golang/leak/"/>
    <url>/2022/05/09/golang/leak/</url>
    
    <content type="html"><![CDATA[<h1 id="Golang-资源泄露"><a href="#Golang-资源泄露" class="headerlink" title="Golang-资源泄露"></a>Golang-资源泄露</h1><p align="right">Lamber</p><p align="right">2022-05-09</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本篇主要记录一些生产环境中遇到的各种资源问题，及对应的排查、解决方法。</p><h2 id="1-HTTP-Body泄露（2022-05-09）"><a href="#1-HTTP-Body泄露（2022-05-09）" class="headerlink" title="1. HTTP-Body泄露（2022-05-09）"></a>1. HTTP-Body泄露（2022-05-09）</h2><ul><li><p>运维监控发现生产环境某服务所有节点出现OOM现象，但预发布、测试环境未出现该现象，初步判断内存泄露与请求数成正比关系。但该服务同时承载HTTP与gRPC请求，需要进一步排查。</p><ul><li>下图5月7日内存泄露现象。</li></ul></li></ul><p><img src="buffer_leak.jpg"></p><ul><li><p>使用pprof工具采集测试环境服务内存使用信息，将采集后的信息下载到本地稍后分析。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -G &lt;被测服务域名&gt;/debug/pprof/heap &gt; heap.profile<br></code></pre></td></tr></table></figure></li><li><p>使用go工具链绘制调用流程图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool pprof -http :8111 ./profile<br></code></pre></td></tr></table></figure></li></ul><p><img src="buffer_leak_profile.png"></p><ul><li><p>由图中可以发现http的newBufioReader后续操作存在内存泄露，查代码发现在http中间件中有对Body数据重置的情况，但没有关闭io.Reader，因此造成内存泄露。修复方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    _ = c.Request.Body.Close()<br>    c.Request.Body = ioutil.NopCloser(bytes.NewBuffer(body))<br>&#125;()<br></code></pre></td></tr></table></figure></li><li><p>但是光懂得Close()还不够，要理解为什么原来的Body没有被释放，这里涉及到bytes.Buffer的内部实现，在另外的文章记录。</p></li></ul><h2 id="2-定时器泄露（2023-02-27）"><a href="#2-定时器泄露（2023-02-27）" class="headerlink" title="2. 定时器泄露（2023-02-27）"></a>2. 定时器泄露（2023-02-27）</h2><ul><li>运维监控发现生产环境某2个微服务的cpu有持续上升趋势，并在测试环境中有相同的现象，初步判断是有某种工具泄露。<ul><li>下图2月28日前的cpu占用率是未修复前的现象，乘持续上升趋势，且该服务没有cpu密集型任务。27日下午修复后CPU占用率恢复正常。</li></ul></li></ul><p><img src="timer_leak_1.png"></p><ul><li><p>使用pprof工具采集测试环境服务30秒的CPU使用信息，将采集后的信息下载到本地稍后分析。</p><ul><li>我们的服务内嵌了pprof，使用白名单方式做安全限制。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl &lt;被测服务域名&gt;/debug/pprof/profile --output ./profile<br></code></pre></td></tr></table></figure></li><li><p>使用go工具链绘制调用流程图。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go tool pprof -http :8111 ./profile<br></code></pre></td></tr></table></figure></li></ul><p><img src="timer_leak_profile_1.png"></p><ul><li>从图中发现占了86%CPU资源的是定时器，没有其他更有价值的线索了。并且只有2个服务出现该情况，排除是三方库导致的问题。于是定位该服务中所有使用定时器的地方。于是发现有一处代码循环创建定时器： <strong>time.NewTimer()</strong> ，但没有调用 <strong>Stop()</strong> 方法。<ul><li>解决方式比较简单，使用 <strong>Reset()</strong> 方法每次重试定时器即可，这里不列出代码了；</li><li>相对于解决问题，认识定时器内部实现还比较重要。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>pprof</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
